
C:\Users\eroshandel\AppData\Local\Temp\arduino\sketches\9E50C72F1B2D4B252FC994134068876D/BME680andIR.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
       0:	0c 94 71 01 	jmp	0x2e2	; 0x2e2 <__ctors_end>
       4:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
       8:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
       c:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      10:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      14:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      18:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      1c:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      20:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      24:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      28:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      2c:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      30:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      34:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      38:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      3c:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      40:	0c 94 81 06 	jmp	0xd02	; 0xd02 <__vector_16>
      44:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      48:	0c 94 f1 06 	jmp	0xde2	; 0xde2 <__vector_18>
      4c:	0c 94 cb 06 	jmp	0xd96	; 0xd96 <__vector_19>
      50:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      54:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      58:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      5c:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      60:	0c 94 23 07 	jmp	0xe46	; 0xe46 <__vector_24>
      64:	0c 94 99 01 	jmp	0x332	; 0x332 <__bad_interrupt>
      68:	07 63       	ori	r16, 0x37	; 55
      6a:	42 36       	cpi	r20, 0x62	; 98
      6c:	b7 9b       	sbis	0x16, 7	; 22
      6e:	d8 a7       	std	Y+40, r29	; 0x28
      70:	1a 39       	cpi	r17, 0x9A	; 154
      72:	68 56       	subi	r22, 0x68	; 104
      74:	18 ae       	std	Y+56, r1	; 0x38
      76:	ba ab       	std	Y+50, r27	; 0x32
      78:	55 8c       	ldd	r5, Z+29	; 0x1d
      7a:	1d 3c       	cpi	r17, 0xCD	; 205
      7c:	b7 cc       	rjmp	.-1682   	; 0xfffff9ec <__eeprom_end+0xff7ef9ec>
      7e:	57 63       	ori	r21, 0x37	; 55
      80:	bd 6d       	ori	r27, 0xDD	; 221
      82:	ed fd       	.word	0xfded	; ????
      84:	75 3e       	cpi	r23, 0xE5	; 229
      86:	f6 17       	cp	r31, r22
      88:	72 31       	cpi	r23, 0x12	; 18
      8a:	bf 00       	.word	0x00bf	; ????
      8c:	00 00       	nop
      8e:	80 3f       	cpi	r24, 0xF0	; 240
      90:	08 00       	.word	0x0008	; ????
      92:	00 00       	nop
      94:	be 92       	st	-X, r11
      96:	24 49       	sbci	r18, 0x94	; 148
      98:	12 3e       	cpi	r17, 0xE2	; 226
      9a:	ab aa       	std	Y+51, r10	; 0x33
      9c:	aa 2a       	or	r10, r26
      9e:	be cd       	rjmp	.-1156   	; 0xfffffc1c <__eeprom_end+0xff7efc1c>
      a0:	cc cc       	rjmp	.-1640   	; 0xfffffa3a <__eeprom_end+0xff7efa3a>
      a2:	4c 3e       	cpi	r20, 0xEC	; 236
      a4:	00 00       	nop
      a6:	00 80       	ld	r0, Z
      a8:	be ab       	std	Y+54, r27	; 0x36
      aa:	aa aa       	std	Y+50, r10	; 0x32
      ac:	aa 3e       	cpi	r26, 0xEA	; 234
      ae:	00 00       	nop
      b0:	00 00       	nop
      b2:	bf 00       	.word	0x00bf	; ????
      b4:	00 00       	nop
      b6:	80 3f       	cpi	r24, 0xF0	; 240
      b8:	00 00       	nop
      ba:	00 00       	nop
      bc:	00 08       	sbc	r0, r0
      be:	41 78       	andi	r20, 0x81	; 129
      c0:	d3 bb       	out	0x13, r29	; 19
      c2:	43 87       	std	Z+11, r20	; 0x0b
      c4:	d1 13       	cpse	r29, r17
      c6:	3d 19       	sub	r19, r13
      c8:	0e 3c       	cpi	r16, 0xCE	; 206
      ca:	c3 bd       	out	0x23, r28	; 35
      cc:	42 82       	std	Z+2, r4	; 0x02
      ce:	ad 2b       	or	r26, r29
      d0:	3e 68       	ori	r19, 0x8E	; 142
      d2:	ec 82       	std	Y+4, r14	; 0x04
      d4:	76 be       	out	0x36, r7	; 54
      d6:	d9 8f       	std	Y+25, r29	; 0x19
      d8:	e1 a9       	ldd	r30, Z+49	; 0x31
      da:	3e 4c       	sbci	r19, 0xCE	; 206
      dc:	80 ef       	ldi	r24, 0xF0	; 240
      de:	ff be       	out	0x3f, r15	; 63
      e0:	01 c4       	rjmp	.+2050   	; 0x8e4 <TwoWire::write(unsigned char const*, unsigned int)+0x40>
      e2:	ff 7f       	andi	r31, 0xFF	; 255
      e4:	3f 00       	.word	0x003f	; ????
      e6:	00 00       	nop
	...

000000ea <__trampolines_end>:
__trampolines_start():
      ea:	0a 2d       	mov	r16, r10
      ec:	20 49       	sbci	r18, 0x90	; 144
      ee:	6e 69       	ori	r22, 0x9E	; 158
      f0:	74 69       	ori	r23, 0x94	; 148
      f2:	61 6c       	ori	r22, 0xC1	; 193
      f4:	69 7a       	andi	r22, 0xA9	; 169
      f6:	69 6e       	ori	r22, 0xE9	; 233
      f8:	67 20       	and	r6, r7
      fa:	42 4d       	sbci	r20, 0xD2	; 210
      fc:	45 36       	cpi	r20, 0x65	; 101
      fe:	38 30       	cpi	r19, 0x08	; 8
     100:	20 73       	andi	r18, 0x30	; 48
     102:	65 6e       	ori	r22, 0xE5	; 229
     104:	73 6f       	ori	r23, 0xF3	; 243
     106:	72 20       	and	r7, r2
     108:	32 20       	and	r3, r2
     10a:	61 74       	andi	r22, 0x41	; 65
     10c:	20 61       	ori	r18, 0x10	; 16
     10e:	64 64       	ori	r22, 0x44	; 68
     110:	72 65       	ori	r23, 0x52	; 82
     112:	73 73       	andi	r23, 0x33	; 51
     114:	20 4d       	sbci	r18, 0xD0	; 208
     116:	4c 58       	subi	r20, 0x8C	; 140
     118:	39 30       	cpi	r19, 0x09	; 9
     11a:	36 31       	cpi	r19, 0x16	; 22
     11c:	34 0a       	sbc	r3, r20
	...

0000011f <setup::__c>:
     11f:	2d 20 53 65 74 74 69 6e 67 20 67 61 73 20 6d 65     - Setting gas me
     12f:	61 73 75 72 65 6d 65 6e 74 20 74 6f 20 33 32 30     asurement to 320
     13f:	c2 b0 43 20 66 6f 72 20 31 35 30 6d 73 0a 00        ..C for 150ms..

0000014e <setup::__c>:
     14e:	2d 20 53 65 74 74 69 6e 67 20 49 49 52 20 66 69     - Setting IIR fi
     15e:	6c 74 65 72 20 74 6f 20 61 20 76 61 6c 75 65 20     lter to a value 
     16e:	6f 66 20 34 20 73 61 6d 70 6c 65 73 0a 00           of 4 samples..

0000017c <setup::__c>:
     17c:	2d 20 53 65 74 74 69 6e 67 20 31 36 78 20 6f 76     - Setting 16x ov
     18c:	65 72 73 61 6d 70 6c 69 6e 67 20 66 6f 72 20 61     ersampling for a
     19c:	6c 6c 20 73 65 6e 73 6f 72 73 0a 00                 ll sensors..

000001a8 <setup::__c>:
     1a8:	2d 20 20 55 6e 61 62 6c 65 20 74 6f 20 66 69 6e     -  Unable to fin
     1b8:	64 20 42 4d 45 36 38 30 2e 20 54 72 79 69 6e 67     d BME680. Trying
     1c8:	20 61 67 61 69 6e 20 69 6e 20 35 20 73 65 63 6f      again in 5 seco
     1d8:	6e 64 73 2e 0a 00                                   nds...

000001de <setup::__c>:
     1de:	2d 20 49 6e 69 74 69 61 6c 69 7a 69 6e 67 20 42     - Initializing B
     1ee:	4d 45 36 38 30 20 73 65 6e 73 6f 72 0a 00           ME680 sensor..

000001fc <setup::__c>:
     1fc:	53 74 61 72 74 69 6e 67 20 49 32 43 44 65 6d 6f     Starting I2CDemo
     20c:	20 65 78 61 6d 70 6c 65 20 70 72 6f 67 72 61 6d      example program
     21c:	20 66 6f 72 20 42 4d 45 36 38 30 0a 00               for BME680..

00000229 <loop::__c>:
     229:	e2 84 a6 0a 3d 3d 3d 3d 20 3d 3d 3d 3d 3d 3d 20     ....==== ====== 
     239:	3d 3d 3d 3d 3d 3d 20 3d 3d 3d 3d 3d 3d 3d 3d 3d     ====== =========
     249:	20 3d 3d 3d 3d 3d 3d 3d 20 3d 3d 3d 3d 3d 3d 0a      ======= ======.
	...

0000025a <loop::__c>:
     25a:	0a 4c 6f 6f 70 20 54 65 6d 70 c2 b0 43 20 48 75     .Loop Temp..C Hu
     26a:	6d 69 64 25 20 50 72 65 73 73 20 68 50 61 20 20     mid% Press hPa  
     27a:	20 41 6c 74 20 6d 20 41 69 72 20 6d 00               Alt m Air m.

00000287 <port_to_output_PGM>:
     287:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

00000291 <port_to_input_PGM>:
     291:	00 00 00 00 23 00 26 00 29 00                       ....#.&.).

0000029b <digital_pin_to_port_PGM>:
     29b:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
     2ab:	03 03 03 03 02 02 03                                .......

000002b2 <digital_pin_to_bit_mask_PGM>:
     2b2:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
     2c2:	04 08 10 20 40 80 40                                ... @.@

000002c9 <digital_pin_to_timer_PGM>:
     2c9:	00 00 00 09 00 03 02 00 00 04 05 08 00 00 00 00     ................
     2d9:	00 00 00 00 00 00 00                                .......

000002e0 <__ctors_start>:
__ctors_start():
     2e0:	4e 08       	sbc	r4, r14

000002e2 <__ctors_end>:
__dtors_end():
     2e2:	11 24       	eor	r1, r1
     2e4:	1f be       	out	0x3f, r1	; 63
     2e6:	cf ef       	ldi	r28, 0xFF	; 255
     2e8:	d8 e0       	ldi	r29, 0x08	; 8
     2ea:	de bf       	out	0x3e, r29	; 62
     2ec:	cd bf       	out	0x3d, r28	; 61

000002ee <__do_clear_bss>:
__do_clear_bss():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     2ee:	23 e0       	ldi	r18, 0x03	; 3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     2f0:	ac ed       	ldi	r26, 0xDC	; 220
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     2f2:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     2f4:	01 c0       	rjmp	.+2      	; 0x2f8 <.do_clear_bss_start>

000002f6 <.do_clear_bss_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     2f6:	1d 92       	st	X+, r1

000002f8 <.do_clear_bss_start>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     2f8:	aa 3f       	cpi	r26, 0xFA	; 250
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     2fa:	b2 07       	cpc	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     2fc:	e1 f7       	brne	.-8      	; 0x2f6 <.do_clear_bss_loop>

000002fe <__do_copy_data>:
__do_copy_data():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2409
     2fe:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2410
     300:	a0 e0       	ldi	r26, 0x00	; 0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2411
     302:	b1 e0       	ldi	r27, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2412
     304:	e4 ed       	ldi	r30, 0xD4	; 212
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2413
     306:	fe e3       	ldi	r31, 0x3E	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2414
     308:	02 c0       	rjmp	.+4      	; 0x30e <__do_copy_data+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2417
     30a:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2422
     30c:	0d 92       	st	X+, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2424
     30e:	ac 3d       	cpi	r26, 0xDC	; 220
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2425
     310:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2426
     312:	d9 f7       	brne	.-10     	; 0x30a <__do_copy_data+0xc>

00000314 <__do_global_ctors>:
__do_global_ctors():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     314:	11 e0       	ldi	r17, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     316:	c1 e7       	ldi	r28, 0x71	; 113
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     318:	d1 e0       	ldi	r29, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     31a:	04 c0       	rjmp	.+8      	; 0x324 <__do_global_ctors+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     31c:	21 97       	sbiw	r28, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     31e:	fe 01       	movw	r30, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     320:	0e 94 3f 1f 	call	0x3e7e	; 0x3e7e <__tablejump2__>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     324:	c0 37       	cpi	r28, 0x70	; 112
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     326:	d1 07       	cpc	r29, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     328:	c9 f7       	brne	.-14     	; 0x31c <__do_global_ctors+0x8>
     32a:	0e 94 91 08 	call	0x1122	; 0x1122 <main>
     32e:	0c 94 68 1f 	jmp	0x3ed0	; 0x3ed0 <_exit>

00000332 <__bad_interrupt>:
__vector_22():
     332:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>:
beginTransaction():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:206
      digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
    }
    inTransactionFlag = 1;
    #endif

    SPCR = settings.spcr;
     336:	8c bd       	out	0x2c, r24	; 44
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:207
    SPSR = settings.spsr;
     338:	9d bd       	out	0x2d, r25	; 45
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:208
  }
     33a:	08 95       	ret

0000033c <TwoWire::endTransmission() [clone .constprop.41]>:
endTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:225
//  devices will behave oddly if they do not see a STOP.
//
uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
  // transmit buffer (blocking)
  uint8_t ret = twi_writeTo(txAddress, txBuffer, txBufferLength, 1, sendStop);
     33c:	90 91 a2 02 	lds	r25, 0x02A2	; 0x8002a2 <TwoWire::txBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:269
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < length){
    return 1;
     340:	81 e0       	ldi	r24, 0x01	; 1
twi_writeTo():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:268
 *          5 .. timeout
 */
uint8_t twi_writeTo(uint8_t address, uint8_t* data, uint8_t length, uint8_t wait, uint8_t sendStop)
{
  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < length){
     342:	91 32       	cpi	r25, 0x21	; 33
     344:	08 f0       	brcs	.+2      	; 0x348 <TwoWire::endTransmission() [clone .constprop.41]+0xc>
     346:	43 c0       	rjmp	.+134    	; 0x3ce <TwoWire::endTransmission() [clone .constprop.41]+0x92>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:282
        twi_handleTimeout(twi_do_reset_on_timeout);
        return (5);
      }
    }
  #else
    while(TWI_READY != twi_state){
     348:	80 91 7e 02 	lds	r24, 0x027E	; 0x80027e <twi_state>
     34c:	81 11       	cpse	r24, r1
     34e:	fc cf       	rjmp	.-8      	; 0x348 <TwoWire::endTransmission() [clone .constprop.41]+0xc>
endTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:225
     350:	80 91 a1 02 	lds	r24, 0x02A1	; 0x8002a1 <TwoWire::txAddress>
twi_writeTo():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:287
      continue;
    }
  #endif

  twi_state = TWI_MTX;
     354:	22 e0       	ldi	r18, 0x02	; 2
     356:	20 93 7e 02 	sts	0x027E, r18	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:288
  twi_sendStop = sendStop;
     35a:	21 e0       	ldi	r18, 0x01	; 1
     35c:	20 93 7d 02 	sts	0x027D, r18	; 0x80027d <twi_sendStop>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:290
  // reset error state (0xFF.. no error occurred)
  twi_error = 0xFF;
     360:	2f ef       	ldi	r18, 0xFF	; 255
     362:	20 93 7c 02 	sts	0x027C, r18	; 0x80027c <twi_error>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:293

  // initialize buffer iteration vars
  twi_masterBuffer = data;
     366:	21 e8       	ldi	r18, 0x81	; 129
     368:	32 e0       	ldi	r19, 0x02	; 2
     36a:	30 93 7b 02 	sts	0x027B, r19	; 0x80027b <twi_masterBuffer+0x1>
     36e:	20 93 7a 02 	sts	0x027A, r18	; 0x80027a <twi_masterBuffer>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:294
  twi_masterBufferIndex = 0;
     372:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <twi_masterBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:295
  twi_masterBufferLength = length;
     376:	90 93 78 02 	sts	0x0278, r25	; 0x800278 <twi_masterBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:298

  // build sla+w, slave device address + w bit
  twi_slarw = TW_WRITE;
     37a:	10 92 77 02 	sts	0x0277, r1	; 0x800277 <twi_slarw>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:299
  twi_slarw |= address << 1;
     37e:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <twi_slarw>
     382:	88 0f       	add	r24, r24
     384:	89 2b       	or	r24, r25
     386:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <twi_slarw>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:304

  // if we're in a repeated start, then we've already sent the START
  // in the ISR. Don't do it again.
  //
  if (true == twi_inRepStart) {
     38a:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <twi_inRepStart>
     38e:	81 30       	cpi	r24, 0x01	; 1
     390:	29 f5       	brne	.+74     	; 0x3dc <TwoWire::endTransmission() [clone .constprop.41]+0xa0>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:311
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the 
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false; // Remember, we're dealing with an ASYNC ISR
     392:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <twi_inRepStart>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:322
          return (5);
        }
      } while(TWCR & _BV(TWWC));
    #else
      do {
        TWDR = twi_slarw;
     396:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <twi_slarw>
     39a:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:323
      } while(TWCR & _BV(TWWC));
     39e:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
     3a2:	83 fd       	sbrc	r24, 3
     3a4:	f8 cf       	rjmp	.-16     	; 0x396 <TwoWire::endTransmission() [clone .constprop.41]+0x5a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:325
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
     3a6:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:329
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA); // enable INTs
     3a8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:341
        twi_handleTimeout(twi_do_reset_on_timeout);
        return (5);
      }
    }
  #else
    while(wait && (TWI_MTX == twi_state)){
     3ac:	80 91 7e 02 	lds	r24, 0x027E	; 0x80027e <twi_state>
     3b0:	82 30       	cpi	r24, 0x02	; 2
     3b2:	e1 f3       	breq	.-8      	; 0x3ac <TwoWire::endTransmission() [clone .constprop.41]+0x70>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:346
      continue;
    }
  #endif

  if (twi_error == 0xFF)
     3b4:	80 91 7c 02 	lds	r24, 0x027C	; 0x80027c <twi_error>
     3b8:	8f 3f       	cpi	r24, 0xFF	; 255
     3ba:	91 f0       	breq	.+36     	; 0x3e0 <TwoWire::endTransmission() [clone .constprop.41]+0xa4>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:348
    return 0; // success
  else if (twi_error == TW_MT_SLA_NACK)
     3bc:	80 91 7c 02 	lds	r24, 0x027C	; 0x80027c <twi_error>
     3c0:	80 32       	cpi	r24, 0x20	; 32
     3c2:	81 f0       	breq	.+32     	; 0x3e4 <TwoWire::endTransmission() [clone .constprop.41]+0xa8>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:350
    return 2; // error: address send, nack received
  else if (twi_error == TW_MT_DATA_NACK)
     3c4:	80 91 7c 02 	lds	r24, 0x027C	; 0x80027c <twi_error>
     3c8:	80 33       	cpi	r24, 0x30	; 48
     3ca:	71 f0       	breq	.+28     	; 0x3e8 <TwoWire::endTransmission() [clone .constprop.41]+0xac>
endTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:353
    return 3; // error: data send, nack received
  else
    return 4; // other twi error
     3cc:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:227
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     3ce:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:228
  txBufferLength = 0;
     3d2:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:230
  // indicate that we are done transmitting
  transmitting = 0;
     3d6:	10 92 7f 02 	sts	0x027F, r1	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:240
//  definition, and expected behaviour, of endTransmission
//
uint8_t TwoWire::endTransmission(void)
{
  return endTransmission(true);
}
     3da:	08 95       	ret
twi_writeTo():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:329
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE) | _BV(TWSTA); // enable INTs
     3dc:	85 ee       	ldi	r24, 0xE5	; 229
     3de:	e4 cf       	rjmp	.-56     	; 0x3a8 <TwoWire::endTransmission() [clone .constprop.41]+0x6c>
endTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:347
      continue;
    }
  #endif

  if (twi_error == 0xFF)
    return 0; // success
     3e0:	80 e0       	ldi	r24, 0x00	; 0
     3e2:	f5 cf       	rjmp	.-22     	; 0x3ce <TwoWire::endTransmission() [clone .constprop.41]+0x92>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:349
  else if (twi_error == TW_MT_SLA_NACK)
    return 2; // error: address send, nack received
     3e4:	82 e0       	ldi	r24, 0x02	; 2
     3e6:	f3 cf       	rjmp	.-26     	; 0x3ce <TwoWire::endTransmission() [clone .constprop.41]+0x92>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:351
  else if (twi_error == TW_MT_DATA_NACK)
    return 3; // error: data send, nack received
     3e8:	83 e0       	ldi	r24, 0x03	; 3
     3ea:	f1 cf       	rjmp	.-30     	; 0x3ce <TwoWire::endTransmission() [clone .constprop.41]+0x92>

000003ec <TwoWire::available()>:
available():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:290
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return rxBufferLength - rxBufferIndex;
     3ec:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
     3f0:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:291
}
     3f4:	89 1b       	sub	r24, r25
     3f6:	99 0b       	sbc	r25, r25
     3f8:	08 95       	ret

000003fa <turnOffPWM>:
turnOffPWM():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:77
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
  switch (timer)
     3fa:	84 30       	cpi	r24, 0x04	; 4
     3fc:	81 f0       	breq	.+32     	; 0x41e <__LOCK_REGION_LENGTH__+0x1e>
     3fe:	28 f4       	brcc	.+10     	; 0x40a <__LOCK_REGION_LENGTH__+0xa>
     400:	82 30       	cpi	r24, 0x02	; 2
     402:	e9 f0       	breq	.+58     	; 0x43e <__LOCK_REGION_LENGTH__+0x3e>
     404:	83 30       	cpi	r24, 0x03	; 3
     406:	f9 f0       	breq	.+62     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
     408:	08 95       	ret
     40a:	88 30       	cpi	r24, 0x08	; 8
     40c:	71 f0       	breq	.+28     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
     40e:	89 30       	cpi	r24, 0x09	; 9
     410:	91 f0       	breq	.+36     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
     412:	85 30       	cpi	r24, 0x05	; 5
     414:	b9 f4       	brne	.+46     	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:87
        TCCR1A &= ~_BV(COM1A1);
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
     416:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     41a:	8f 7d       	andi	r24, 0xDF	; 223
     41c:	03 c0       	rjmp	.+6      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:82
  switch (timer)
  {
    // Timer1
    #if defined(TCCR1A) && defined(COM1A1)
      case TIMER1A:
        TCCR1A &= ~_BV(COM1A1);
     41e:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     422:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:87
        break;
    #endif
    #if defined(TCCR1A) && defined(COM1B1)
      case TIMER1B:
        TCCR1A &= ~_BV(COM1B1);
     424:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
     428:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:104
        TCCR2 &= ~_BV(COM21);
        break;
    #endif
    #if defined(TCCR2A) && defined(COM2A1)
      case TIMER2A:
        TCCR2A &= ~_BV(COM2A1);
     42a:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     42e:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:109
        break;
    #endif
    #if defined(TCCR2A) && defined(COM2B1)
      case TIMER2B:
        TCCR2A &= ~_BV(COM2B1);
     430:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     434:	08 95       	ret
     436:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
     43a:	8f 7d       	andi	r24, 0xDF	; 223
     43c:	f9 cf       	rjmp	.-14     	; 0x430 <__LOCK_REGION_LENGTH__+0x30>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:176
        TCCR0 &= ~_BV(COM01);
        break;
    #endif
    #if defined(TCCR0A) && defined(COM0A1)
      case TIMER0A:
        TCCR0A &= ~_BV(COM0A1);
     43e:	84 b5       	in	r24, 0x24	; 36
     440:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:181
        break;
    #endif
    #if defined(TCCR0A) && defined(COM0B1)
      case TIMER0B:
        TCCR0A &= ~_BV(COM0B1);
     442:	84 bd       	out	0x24, r24	; 36
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:185
        break;
    #endif
  }
}
     444:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:181
        TCCR0A &= ~_BV(COM0A1);
        break;
    #endif
    #if defined(TCCR0A) && defined(COM0B1)
      case TIMER0B:
        TCCR0A &= ~_BV(COM0B1);
     446:	84 b5       	in	r24, 0x24	; 36
     448:	8f 7d       	andi	r24, 0xDF	; 223
     44a:	fb cf       	rjmp	.-10     	; 0x442 <__LOCK_REGION_LENGTH__+0x42>

0000044c <digitalRead>:
digitalRead():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:215

  SREG = oldSREG;
}

int digitalRead(uint8_t pin)
{
     44c:	cf 93       	push	r28
     44e:	df 93       	push	r29
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:216
  uint8_t timer = digitalPinToTimer(pin);
     450:	28 2f       	mov	r18, r24
     452:	30 e0       	ldi	r19, 0x00	; 0
     454:	f9 01       	movw	r30, r18
     456:	e7 53       	subi	r30, 0x37	; 55
     458:	fd 4f       	sbci	r31, 0xFD	; 253
     45a:	84 91       	lpm	r24, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:217
  uint8_t bit = digitalPinToBitMask(pin);
     45c:	f9 01       	movw	r30, r18
     45e:	ee 54       	subi	r30, 0x4E	; 78
     460:	fd 4f       	sbci	r31, 0xFD	; 253
     462:	d4 91       	lpm	r29, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:218
  uint8_t port = digitalPinToPort(pin);
     464:	f9 01       	movw	r30, r18
     466:	e5 56       	subi	r30, 0x65	; 101
     468:	fd 4f       	sbci	r31, 0xFD	; 253
     46a:	c4 91       	lpm	r28, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:220

  if (port == NOT_A_PIN) return LOW;
     46c:	cc 23       	and	r28, r28
     46e:	a1 f0       	breq	.+40     	; 0x498 <digitalRead+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:224

  // If the pin that support PWM output, we need to turn it off
  // before getting a digital reading.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     470:	81 11       	cpse	r24, r1
     472:	0e 94 fd 01 	call	0x3fa	; 0x3fa <turnOffPWM>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:226

  if (*portInputRegister(port) & bit) return HIGH;
     476:	ec 2f       	mov	r30, r28
     478:	f0 e0       	ldi	r31, 0x00	; 0
     47a:	ee 0f       	add	r30, r30
     47c:	ff 1f       	adc	r31, r31
     47e:	ef 56       	subi	r30, 0x6F	; 111
     480:	fd 4f       	sbci	r31, 0xFD	; 253
     482:	a5 91       	lpm	r26, Z+
     484:	b4 91       	lpm	r27, Z
     486:	ec 91       	ld	r30, X
     488:	ed 23       	and	r30, r29
     48a:	81 e0       	ldi	r24, 0x01	; 1
     48c:	90 e0       	ldi	r25, 0x00	; 0
     48e:	09 f4       	brne	.+2      	; 0x492 <digitalRead+0x46>
     490:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:228
  return LOW;
}
     492:	df 91       	pop	r29
     494:	cf 91       	pop	r28
     496:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:220
{
  uint8_t timer = digitalPinToTimer(pin);
  uint8_t bit = digitalPinToBitMask(pin);
  uint8_t port = digitalPinToPort(pin);

  if (port == NOT_A_PIN) return LOW;
     498:	80 e0       	ldi	r24, 0x00	; 0
     49a:	90 e0       	ldi	r25, 0x00	; 0
     49c:	fa cf       	rjmp	.-12     	; 0x492 <digitalRead+0x46>

0000049e <digitalWrite>:
digitalWrite():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:188
    #endif
  }
}

void digitalWrite(uint8_t pin, uint8_t val)
{
     49e:	1f 93       	push	r17
     4a0:	cf 93       	push	r28
     4a2:	df 93       	push	r29
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:189
  uint8_t timer = digitalPinToTimer(pin);
     4a4:	28 2f       	mov	r18, r24
     4a6:	30 e0       	ldi	r19, 0x00	; 0
     4a8:	f9 01       	movw	r30, r18
     4aa:	e7 53       	subi	r30, 0x37	; 55
     4ac:	fd 4f       	sbci	r31, 0xFD	; 253
     4ae:	84 91       	lpm	r24, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:190
  uint8_t bit = digitalPinToBitMask(pin);
     4b0:	f9 01       	movw	r30, r18
     4b2:	ee 54       	subi	r30, 0x4E	; 78
     4b4:	fd 4f       	sbci	r31, 0xFD	; 253
     4b6:	d4 91       	lpm	r29, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:191
  uint8_t port = digitalPinToPort(pin);
     4b8:	f9 01       	movw	r30, r18
     4ba:	e5 56       	subi	r30, 0x65	; 101
     4bc:	fd 4f       	sbci	r31, 0xFD	; 253
     4be:	c4 91       	lpm	r28, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:194
  volatile uint8_t *out;

  if (port == NOT_A_PIN) return;
     4c0:	cc 23       	and	r28, r28
     4c2:	a9 f0       	breq	.+42     	; 0x4ee <digitalWrite+0x50>
     4c4:	16 2f       	mov	r17, r22
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:198

  // If the pin that support PWM output, we need to turn it off
  // before doing a digital write.
  if (timer != NOT_ON_TIMER) turnOffPWM(timer);
     4c6:	81 11       	cpse	r24, r1
     4c8:	0e 94 fd 01 	call	0x3fa	; 0x3fa <turnOffPWM>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:200

  out = portOutputRegister(port);
     4cc:	ec 2f       	mov	r30, r28
     4ce:	f0 e0       	ldi	r31, 0x00	; 0
     4d0:	ee 0f       	add	r30, r30
     4d2:	ff 1f       	adc	r31, r31
     4d4:	e9 57       	subi	r30, 0x79	; 121
     4d6:	fd 4f       	sbci	r31, 0xFD	; 253
     4d8:	a5 91       	lpm	r26, Z+
     4da:	b4 91       	lpm	r27, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:202

  uint8_t oldSREG = SREG;
     4dc:	8f b7       	in	r24, 0x3f	; 63
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:203
  cli();
     4de:	f8 94       	cli
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:206

  if (val == LOW) {
    *out &= ~bit;
     4e0:	ec 91       	ld	r30, X
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:205
  out = portOutputRegister(port);

  uint8_t oldSREG = SREG;
  cli();

  if (val == LOW) {
     4e2:	11 11       	cpse	r17, r1
     4e4:	08 c0       	rjmp	.+16     	; 0x4f6 <digitalWrite+0x58>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:206
    *out &= ~bit;
     4e6:	d0 95       	com	r29
     4e8:	de 23       	and	r29, r30
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:208
  } else {
    *out |= bit;
     4ea:	dc 93       	st	X, r29
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:211
  }

  SREG = oldSREG;
     4ec:	8f bf       	out	0x3f, r24	; 63
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:212
}
     4ee:	df 91       	pop	r29
     4f0:	cf 91       	pop	r28
     4f2:	1f 91       	pop	r17
     4f4:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring_digital.c:208
  cli();

  if (val == LOW) {
    *out &= ~bit;
  } else {
    *out |= bit;
     4f6:	de 2b       	or	r29, r30
     4f8:	f8 cf       	rjmp	.-16     	; 0x4ea <digitalWrite+0x4c>

000004fa <micros>:
micros():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:237
  unsigned char f; // temporary storage for millis fraction counter
  unsigned char q = 0; // record whether an overflow is flagged
#endif
  // t will be the number where the timer0 counter stopped
  uint8_t t;
  uint8_t oldSREG = SREG;
     4fa:	3f b7       	in	r19, 0x3f	; 63
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:240

  // Stop all interrupts
  cli();
     4fc:	f8 94       	cli
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:247
#ifdef CORRECT_EXACT_MICROS
  // combine exact millisec and 8usec counters
  m = timer0_millis;
  f = timer0_fract;
#else
  m = timer0_overflow_count;
     4fe:	80 91 40 02 	lds	r24, 0x0240	; 0x800240 <timer0_overflow_count>
     502:	90 91 41 02 	lds	r25, 0x0241	; 0x800241 <timer0_overflow_count+0x1>
     506:	a0 91 42 02 	lds	r26, 0x0242	; 0x800242 <timer0_overflow_count+0x2>
     50a:	b0 91 43 02 	lds	r27, 0x0243	; 0x800243 <timer0_overflow_count+0x3>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:252
#endif

  // TCNT0 : The Timer Counter Register
#if defined(TCNT0)
  t = TCNT0;
     50e:	26 b5       	in	r18, 0x26	; 38
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:261
  #error TIMER 0 not defined
#endif

  // Timer0 Interrupt Flag Register
#ifdef TIFR0
  if ((TIFR0 & _BV(TOV0)) && (t < 255))
     510:	a8 9b       	sbis	0x15, 0	; 21
     512:	05 c0       	rjmp	.+10     	; 0x51e <micros+0x24>
     514:	2f 3f       	cpi	r18, 0xFF	; 255
     516:	19 f0       	breq	.+6      	; 0x51e <micros+0x24>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:263
#ifndef CORRECT_EXACT_MICROS
    m++;
     518:	01 96       	adiw	r24, 0x01	; 1
     51a:	a1 1d       	adc	r26, r1
     51c:	b1 1d       	adc	r27, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:276
#else
    q = 1;
#endif
#endif
  // Restore SREG
  SREG = oldSREG;
     51e:	3f bf       	out	0x3f, r19	; 63
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:292
      ((t * MICROSECONDS_PER_TIMER0_OVERFLOW) >> 8);
  return q ? m + MICROSECONDS_PER_TIMER0_OVERFLOW : m;
#elif 1
  /* All power-of-two Megahertz frequencies enter here, as well as 12.8 MHz.
     We only end up here if right shift before multiplication is exact. */
  return ((m << 8) + t) * (MICROSECONDS_PER_TIMER0_OVERFLOW >> 8);
     520:	ba 2f       	mov	r27, r26
     522:	a9 2f       	mov	r26, r25
     524:	98 2f       	mov	r25, r24
     526:	88 27       	eor	r24, r24
     528:	bc 01       	movw	r22, r24
     52a:	cd 01       	movw	r24, r26
     52c:	62 0f       	add	r22, r18
     52e:	71 1d       	adc	r23, r1
     530:	81 1d       	adc	r24, r1
     532:	91 1d       	adc	r25, r1
     534:	43 e0       	ldi	r20, 0x03	; 3
     536:	66 0f       	add	r22, r22
     538:	77 1f       	adc	r23, r23
     53a:	88 1f       	adc	r24, r24
     53c:	99 1f       	adc	r25, r25
     53e:	4a 95       	dec	r20
     540:	d1 f7       	brne	.-12     	; 0x536 <micros+0x3c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:393
  // m & t are multiplied by 4 (since it was already multiplied by 256)
  // t is multiplied by 4
  return ((m << 8) + t) * (64 / clockCyclesPerMicrosecond());
#endif
#endif // 0
}
     542:	08 95       	ret

00000544 <delay>:
delay():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:396

void delay(unsigned long ms)
{
     544:	8f 92       	push	r8
     546:	9f 92       	push	r9
     548:	af 92       	push	r10
     54a:	bf 92       	push	r11
     54c:	cf 92       	push	r12
     54e:	df 92       	push	r13
     550:	ef 92       	push	r14
     552:	ff 92       	push	r15
     554:	4b 01       	movw	r8, r22
     556:	5c 01       	movw	r10, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:397
  unsigned long start = micros();
     558:	0e 94 7d 02 	call	0x4fa	; 0x4fa <micros>
     55c:	6b 01       	movw	r12, r22
     55e:	7c 01       	movw	r14, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:401

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
     560:	0e 94 7d 02 	call	0x4fa	; 0x4fa <micros>
     564:	6c 19       	sub	r22, r12
     566:	7d 09       	sbc	r23, r13
     568:	8e 09       	sbc	r24, r14
     56a:	9f 09       	sbc	r25, r15
     56c:	68 3e       	cpi	r22, 0xE8	; 232
     56e:	73 40       	sbci	r23, 0x03	; 3
     570:	81 05       	cpc	r24, r1
     572:	91 05       	cpc	r25, r1
     574:	a8 f3       	brcs	.-22     	; 0x560 <delay+0x1c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:402
      ms--;
     576:	21 e0       	ldi	r18, 0x01	; 1
     578:	82 1a       	sub	r8, r18
     57a:	91 08       	sbc	r9, r1
     57c:	a1 08       	sbc	r10, r1
     57e:	b1 08       	sbc	r11, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:403
      start += 1000UL;
     580:	88 ee       	ldi	r24, 0xE8	; 232
     582:	c8 0e       	add	r12, r24
     584:	83 e0       	ldi	r24, 0x03	; 3
     586:	d8 1e       	adc	r13, r24
     588:	e1 1c       	adc	r14, r1
     58a:	f1 1c       	adc	r15, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:401
{
  unsigned long start = micros();

  while (ms > 0UL) {
    yield();
    while (ms > 0UL && (micros() - start) >= 1000UL) {
     58c:	81 14       	cp	r8, r1
     58e:	91 04       	cpc	r9, r1
     590:	a1 04       	cpc	r10, r1
     592:	b1 04       	cpc	r11, r1
     594:	29 f7       	brne	.-54     	; 0x560 <delay+0x1c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:406
      ms--;
      start += 1000UL;
    }
  }
}
     596:	ff 90       	pop	r15
     598:	ef 90       	pop	r14
     59a:	df 90       	pop	r13
     59c:	cf 90       	pop	r12
     59e:	bf 90       	pop	r11
     5a0:	af 90       	pop	r10
     5a2:	9f 90       	pop	r9
     5a4:	8f 90       	pop	r8
     5a6:	08 95       	ret

000005a8 <TwoWire::onRequestService()>:
onRequestService():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:366
  // !!! this will kill any pending pre-master sendTo() activity
  txBufferIndex = 0;
  txBufferLength = 0;
  // alert user program
  user_onRequest();
}
     5a8:	08 95       	ret

000005aa <TwoWire::onReceiveService(unsigned char*, int)>:
onReceiveService():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:351
  // set rx iterator vars
  rxBufferIndex = 0;
  rxBufferLength = numBytes;
  // alert user program
  user_onReceive(numBytes);
}
     5aa:	08 95       	ret

000005ac <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:35

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
     5ac:	af 92       	push	r10
     5ae:	bf 92       	push	r11
     5b0:	cf 92       	push	r12
     5b2:	df 92       	push	r13
     5b4:	ef 92       	push	r14
     5b6:	ff 92       	push	r15
     5b8:	0f 93       	push	r16
     5ba:	1f 93       	push	r17
     5bc:	cf 93       	push	r28
     5be:	df 93       	push	r29
     5c0:	6c 01       	movw	r12, r24
     5c2:	7b 01       	movw	r14, r22
     5c4:	8b 01       	movw	r16, r22
     5c6:	04 0f       	add	r16, r20
     5c8:	15 1f       	adc	r17, r21
     5ca:	eb 01       	movw	r28, r22
     5cc:	5e 01       	movw	r10, r28
     5ce:	ae 18       	sub	r10, r14
     5d0:	bf 08       	sbc	r11, r15
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:37
  size_t n = 0;
  while (size--) {
     5d2:	c0 17       	cp	r28, r16
     5d4:	d1 07       	cpc	r29, r17
     5d6:	59 f0       	breq	.+22     	; 0x5ee <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:38
    if (write(*buffer++)) n++;
     5d8:	69 91       	ld	r22, Y+
     5da:	d6 01       	movw	r26, r12
     5dc:	ed 91       	ld	r30, X+
     5de:	fc 91       	ld	r31, X
     5e0:	01 90       	ld	r0, Z+
     5e2:	f0 81       	ld	r31, Z
     5e4:	e0 2d       	mov	r30, r0
     5e6:	c6 01       	movw	r24, r12
     5e8:	09 95       	icall
     5ea:	89 2b       	or	r24, r25
     5ec:	79 f7       	brne	.-34     	; 0x5cc <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:42
    else break;
  }
  return n;
}
     5ee:	c5 01       	movw	r24, r10
     5f0:	df 91       	pop	r29
     5f2:	cf 91       	pop	r28
     5f4:	1f 91       	pop	r17
     5f6:	0f 91       	pop	r16
     5f8:	ff 90       	pop	r15
     5fa:	ef 90       	pop	r14
     5fc:	df 90       	pop	r13
     5fe:	cf 90       	pop	r12
     600:	bf 90       	pop	r11
     602:	af 90       	pop	r10
     604:	08 95       	ret

00000606 <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:195
{
  tx_buffer_index_t head;
  tx_buffer_index_t tail;

  TX_BUFFER_ATOMIC {
    head = _tx_buffer_head;
     606:	fc 01       	movw	r30, r24
     608:	53 8d       	ldd	r21, Z+27	; 0x1b
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:196
    tail = _tx_buffer_tail;
     60a:	44 8d       	ldd	r20, Z+28	; 0x1c
     60c:	25 2f       	mov	r18, r21
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	84 2f       	mov	r24, r20
     612:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:198
  }
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     614:	82 1b       	sub	r24, r18
     616:	93 0b       	sbc	r25, r19
     618:	54 17       	cp	r21, r20
     61a:	10 f0       	brcs	.+4      	; 0x620 <HardwareSerial::availableForWrite()+0x1a>
     61c:	cf 96       	adiw	r24, 0x3f	; 63
     61e:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:199
  return tail - head - 1;
     620:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:200
}
     622:	08 95       	ret

00000624 <HardwareSerial::read()>:
read():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:178
    return _rx_buffer[_rx_buffer_tail];
  }
}

int HardwareSerial::read(void)
{
     624:	fc 01       	movw	r30, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:180
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
     626:	91 8d       	ldd	r25, Z+25	; 0x19
     628:	82 8d       	ldd	r24, Z+26	; 0x1a
     62a:	98 17       	cp	r25, r24
     62c:	61 f0       	breq	.+24     	; 0x646 <HardwareSerial::read()+0x22>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:183
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
     62e:	a2 8d       	ldd	r26, Z+26	; 0x1a
     630:	ae 0f       	add	r26, r30
     632:	bf 2f       	mov	r27, r31
     634:	b1 1d       	adc	r27, r1
     636:	5d 96       	adiw	r26, 0x1d	; 29
     638:	8c 91       	ld	r24, X
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:184
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
     63a:	92 8d       	ldd	r25, Z+26	; 0x1a
     63c:	9f 5f       	subi	r25, 0xFF	; 255
     63e:	9f 73       	andi	r25, 0x3F	; 63
     640:	92 8f       	std	Z+26, r25	; 0x1a
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:185
    return c;
     642:	90 e0       	ldi	r25, 0x00	; 0
     644:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:181

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     646:	8f ef       	ldi	r24, 0xFF	; 255
     648:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:187
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
     64a:	08 95       	ret

0000064c <HardwareSerial::peek()>:
peek():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:169
{
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
}

int HardwareSerial::peek(void)
{
     64c:	fc 01       	movw	r30, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:170
  if (_rx_buffer_head == _rx_buffer_tail) {
     64e:	91 8d       	ldd	r25, Z+25	; 0x19
     650:	82 8d       	ldd	r24, Z+26	; 0x1a
     652:	98 17       	cp	r25, r24
     654:	31 f0       	breq	.+12     	; 0x662 <HardwareSerial::peek()+0x16>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:173
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
     656:	82 8d       	ldd	r24, Z+26	; 0x1a
     658:	e8 0f       	add	r30, r24
     65a:	f1 1d       	adc	r31, r1
     65c:	85 8d       	ldd	r24, Z+29	; 0x1d
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:171
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
     662:	8f ef       	ldi	r24, 0xFF	; 255
     664:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:175
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
     666:	08 95       	ret

00000668 <HardwareSerial::available()>:
available():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:164
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
     668:	fc 01       	movw	r30, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:165
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
     66a:	91 8d       	ldd	r25, Z+25	; 0x19
     66c:	22 8d       	ldd	r18, Z+26	; 0x1a
     66e:	89 2f       	mov	r24, r25
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	80 5c       	subi	r24, 0xC0	; 192
     674:	9f 4f       	sbci	r25, 0xFF	; 255
     676:	82 1b       	sub	r24, r18
     678:	91 09       	sbc	r25, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:166
}
     67a:	8f 73       	andi	r24, 0x3F	; 63
     67c:	99 27       	eor	r25, r25
     67e:	08 95       	ret

00000680 <Serial0_available()>:
Serial0_available():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:76
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
     680:	83 ea       	ldi	r24, 0xA3	; 163
     682:	92 e0       	ldi	r25, 0x02	; 2
     684:	0e 94 34 03 	call	0x668	; 0x668 <HardwareSerial::available()>
     688:	21 e0       	ldi	r18, 0x01	; 1
     68a:	89 2b       	or	r24, r25
     68c:	09 f4       	brne	.+2      	; 0x690 <Serial0_available()+0x10>
     68e:	20 e0       	ldi	r18, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:77
}
     690:	82 2f       	mov	r24, r18
     692:	08 95       	ret

00000694 <serialEventRun()>:
serialEventRun():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	90 e0       	ldi	r25, 0x00	; 0
     698:	89 2b       	or	r24, r25
     69a:	29 f0       	breq	.+10     	; 0x6a6 <serialEventRun()+0x12>
     69c:	0e 94 40 03 	call	0x680	; 0x680 <Serial0_available()>
     6a0:	81 11       	cpse	r24, r1
     6a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:78
  if (Serial2_available && serialEvent2 && Serial2_available()) serialEvent2();
#endif
#if defined(HAVE_HWSERIAL3)
  if (Serial3_available && serialEvent3 && Serial3_available()) serialEvent3();
#endif
}
     6a6:	08 95       	ret

000006a8 <HardwareSerial::_tx_udr_empty_irq()>:
_tx_udr_empty_irq():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:90
#endif

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
     6a8:	fc 01       	movw	r30, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:93
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
     6aa:	a4 8d       	ldd	r26, Z+28	; 0x1c
     6ac:	a8 0f       	add	r26, r24
     6ae:	b9 2f       	mov	r27, r25
     6b0:	b1 1d       	adc	r27, r1
     6b2:	a3 5a       	subi	r26, 0xA3	; 163
     6b4:	bf 4f       	sbci	r27, 0xFF	; 255
     6b6:	2c 91       	ld	r18, X
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:94
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
     6b8:	84 8d       	ldd	r24, Z+28	; 0x1c
     6ba:	90 e0       	ldi	r25, 0x00	; 0
     6bc:	01 96       	adiw	r24, 0x01	; 1
     6be:	8f 73       	andi	r24, 0x3F	; 63
     6c0:	99 27       	eor	r25, r25
     6c2:	84 8f       	std	Z+28, r24	; 0x1c
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:96

  *_udr = c;
     6c4:	a6 89       	ldd	r26, Z+22	; 0x16
     6c6:	b7 89       	ldd	r27, Z+23	; 0x17
     6c8:	2c 93       	st	X, r18
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:104
  // location". This makes sure flush() won't return until the bytes
  // actually got written. Other r/w bits are preserved, and zeroes
  // written to the rest.

  #ifdef MPCM0
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     6ca:	a0 89       	ldd	r26, Z+16	; 0x10
     6cc:	b1 89       	ldd	r27, Z+17	; 0x11
     6ce:	8c 91       	ld	r24, X
     6d0:	83 70       	andi	r24, 0x03	; 3
     6d2:	80 64       	ori	r24, 0x40	; 64
     6d4:	8c 93       	st	X, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:109
  #else
    *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
  #endif

  if (_tx_buffer_head == _tx_buffer_tail) {
     6d6:	93 8d       	ldd	r25, Z+27	; 0x1b
     6d8:	84 8d       	ldd	r24, Z+28	; 0x1c
     6da:	98 13       	cpse	r25, r24
     6dc:	06 c0       	rjmp	.+12     	; 0x6ea <HardwareSerial::_tx_udr_empty_irq()+0x42>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:111
    // Buffer empty, so disable interrupts
    *_ucsrb &= ~_BV(UDRIE0);
     6de:	02 88       	ldd	r0, Z+18	; 0x12
     6e0:	f3 89       	ldd	r31, Z+19	; 0x13
     6e2:	e0 2d       	mov	r30, r0
     6e4:	80 81       	ld	r24, Z
     6e6:	8f 7d       	andi	r24, 0xDF	; 223
     6e8:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:113
  }
}
     6ea:	08 95       	ret

000006ec <HardwareSerial::write(unsigned char)>:
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:223
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}

size_t HardwareSerial::write(uint8_t c)
{
     6ec:	ef 92       	push	r14
     6ee:	ff 92       	push	r15
     6f0:	0f 93       	push	r16
     6f2:	1f 93       	push	r17
     6f4:	cf 93       	push	r28
     6f6:	df 93       	push	r29
     6f8:	ec 01       	movw	r28, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:224
  _written = true;
     6fa:	81 e0       	ldi	r24, 0x01	; 1
     6fc:	88 8f       	std	Y+24, r24	; 0x18
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:229
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
     6fe:	9b 8d       	ldd	r25, Y+27	; 0x1b
     700:	8c 8d       	ldd	r24, Y+28	; 0x1c
     702:	98 13       	cpse	r25, r24
     704:	1a c0       	rjmp	.+52     	; 0x73a <HardwareSerial::write(unsigned char)+0x4e>
     706:	e8 89       	ldd	r30, Y+16	; 0x10
     708:	f9 89       	ldd	r31, Y+17	; 0x11
     70a:	80 81       	ld	r24, Z
     70c:	85 ff       	sbrs	r24, 5
     70e:	15 c0       	rjmp	.+42     	; 0x73a <HardwareSerial::write(unsigned char)+0x4e>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:238
    // So writing UDR must happen first.
    // Writing UDR and clearing TC must be done atomically, otherwise
    // interrupts might delay the TXC clear so the byte written to UDR
    // is transmitted (setting TXC) before clearing TXC. Then TXC will
    // be cleared when no bytes are left, causing flush() to hang
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     710:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\eroshandel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     712:	f8 94       	cli
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:239
      *_udr = c;
     714:	ee 89       	ldd	r30, Y+22	; 0x16
     716:	ff 89       	ldd	r31, Y+23	; 0x17
     718:	60 83       	st	Z, r22
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:241
      #ifdef MPCM0
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << MPCM0))) | (1 << TXC0);
     71a:	e8 89       	ldd	r30, Y+16	; 0x10
     71c:	f9 89       	ldd	r31, Y+17	; 0x11
     71e:	80 81       	ld	r24, Z
     720:	83 70       	andi	r24, 0x03	; 3
     722:	80 64       	ori	r24, 0x40	; 64
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:271
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    _tx_buffer_head = i;
    *_ucsrb |= _BV(UDRIE0);
     724:	80 83       	st	Z, r24
__iRestore():
c:\users\eroshandel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:70
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     726:	9f bf       	out	0x3f, r25	; 63
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:275
  }
  
  return 1;
}
     728:	81 e0       	ldi	r24, 0x01	; 1
     72a:	90 e0       	ldi	r25, 0x00	; 0
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	1f 91       	pop	r17
     732:	0f 91       	pop	r16
     734:	ff 90       	pop	r15
     736:	ef 90       	pop	r14
     738:	08 95       	ret
     73a:	f6 2e       	mov	r15, r22
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:248
        *_ucsra = ((*_ucsra) & ((1 << U2X0) | (1 << TXC0)));
      #endif
    }
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
     73c:	0b 8d       	ldd	r16, Y+27	; 0x1b
     73e:	10 e0       	ldi	r17, 0x00	; 0
     740:	0f 5f       	subi	r16, 0xFF	; 255
     742:	1f 4f       	sbci	r17, 0xFF	; 255
     744:	0f 73       	andi	r16, 0x3F	; 63
     746:	11 27       	eor	r17, r17
     748:	e0 2e       	mov	r14, r16
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:252

  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
     74a:	8c 8d       	ldd	r24, Y+28	; 0x1c
     74c:	8e 11       	cpse	r24, r14
     74e:	0c c0       	rjmp	.+24     	; 0x768 <HardwareSerial::write(unsigned char)+0x7c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:253
    if (bit_is_clear(SREG, SREG_I)) {
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	07 fc       	sbrc	r0, 7
     754:	fa cf       	rjmp	.-12     	; 0x74a <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:258
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
     756:	e8 89       	ldd	r30, Y+16	; 0x10
     758:	f9 89       	ldd	r31, Y+17	; 0x11
     75a:	80 81       	ld	r24, Z
     75c:	85 ff       	sbrs	r24, 5
     75e:	f5 cf       	rjmp	.-22     	; 0x74a <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:259
        _tx_udr_empty_irq();
     760:	ce 01       	movw	r24, r28
     762:	0e 94 54 03 	call	0x6a8	; 0x6a8 <HardwareSerial::_tx_udr_empty_irq()>
     766:	f1 cf       	rjmp	.-30     	; 0x74a <HardwareSerial::write(unsigned char)+0x5e>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:265
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
     768:	eb 8d       	ldd	r30, Y+27	; 0x1b
     76a:	ec 0f       	add	r30, r28
     76c:	fd 2f       	mov	r31, r29
     76e:	f1 1d       	adc	r31, r1
     770:	e3 5a       	subi	r30, 0xA3	; 163
     772:	ff 4f       	sbci	r31, 0xFF	; 255
     774:	f0 82       	st	Z, r15
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:269
  // make atomic to prevent execution of ISR between setting the
  // head pointer and setting the interrupt flag resulting in buffer
  // retransmission
  ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     776:	9f b7       	in	r25, 0x3f	; 63
__iCliRetVal():
c:\users\eroshandel\appdata\local\arduino15\packages\arduino\tools\avr-gcc\7.3.0-atmel3.6.1-arduino7\avr\include\util/atomic.h:50
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     778:	f8 94       	cli
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:270
    _tx_buffer_head = i;
     77a:	0b 8f       	std	Y+27, r16	; 0x1b
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:271
    *_ucsrb |= _BV(UDRIE0);
     77c:	ea 89       	ldd	r30, Y+18	; 0x12
     77e:	fb 89       	ldd	r31, Y+19	; 0x13
     780:	80 81       	ld	r24, Z
     782:	80 62       	ori	r24, 0x20	; 32
     784:	cf cf       	rjmp	.-98     	; 0x724 <HardwareSerial::write(unsigned char)+0x38>

00000786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>:
print():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:44

size_t Print::print(const __FlashStringHelper *ifsh)
     786:	0f 93       	push	r16
     788:	1f 93       	push	r17
     78a:	cf 93       	push	r28
     78c:	df 93       	push	r29
     78e:	8c 01       	movw	r16, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:47
{
  PGM_P p = reinterpret_cast<PGM_P>(ifsh);
  size_t n = 0;
     790:	d0 e0       	ldi	r29, 0x00	; 0
     792:	c0 e0       	ldi	r28, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:49
  while (1) {
    unsigned char c = pgm_read_byte(p++);
     794:	f8 01       	movw	r30, r16
     796:	ec 0f       	add	r30, r28
     798:	fd 1f       	adc	r31, r29
     79a:	64 91       	lpm	r22, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:50
    if (c == 0) break;
     79c:	66 23       	and	r22, r22
     79e:	41 f0       	breq	.+16     	; 0x7b0 <Print::print(__FlashStringHelper const*) [clone .constprop.46]+0x2a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:51
    if (write(c)) n++;
     7a0:	83 ea       	ldi	r24, 0xA3	; 163
     7a2:	92 e0       	ldi	r25, 0x02	; 2
     7a4:	0e 94 76 03 	call	0x6ec	; 0x6ec <HardwareSerial::write(unsigned char)>
     7a8:	89 2b       	or	r24, r25
     7aa:	11 f0       	breq	.+4      	; 0x7b0 <Print::print(__FlashStringHelper const*) [clone .constprop.46]+0x2a>
     7ac:	21 96       	adiw	r28, 0x01	; 1
     7ae:	f2 cf       	rjmp	.-28     	; 0x794 <Print::print(__FlashStringHelper const*) [clone .constprop.46]+0xe>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.cpp:55
    else break;
  }
  return n;
}
     7b0:	ce 01       	movw	r24, r28
     7b2:	df 91       	pop	r29
     7b4:	cf 91       	pop	r28
     7b6:	1f 91       	pop	r17
     7b8:	0f 91       	pop	r16
     7ba:	08 95       	ret

000007bc <HardwareSerial::flush()>:
flush():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:203
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
     7bc:	cf 93       	push	r28
     7be:	df 93       	push	r29
     7c0:	ec 01       	movw	r28, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:207
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
     7c2:	88 8d       	ldd	r24, Y+24	; 0x18
     7c4:	88 23       	and	r24, r24
     7c6:	b9 f0       	breq	.+46     	; 0x7f6 <HardwareSerial::flush()+0x3a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:210
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
     7c8:	aa 89       	ldd	r26, Y+18	; 0x12
     7ca:	bb 89       	ldd	r27, Y+19	; 0x13
     7cc:	e8 89       	ldd	r30, Y+16	; 0x10
     7ce:	f9 89       	ldd	r31, Y+17	; 0x11
     7d0:	8c 91       	ld	r24, X
     7d2:	85 fd       	sbrc	r24, 5
     7d4:	03 c0       	rjmp	.+6      	; 0x7dc <HardwareSerial::flush()+0x20>
     7d6:	80 81       	ld	r24, Z
     7d8:	86 fd       	sbrc	r24, 6
     7da:	0d c0       	rjmp	.+26     	; 0x7f6 <HardwareSerial::flush()+0x3a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:211
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
     7dc:	0f b6       	in	r0, 0x3f	; 63
     7de:	07 fc       	sbrc	r0, 7
     7e0:	f7 cf       	rjmp	.-18     	; 0x7d0 <HardwareSerial::flush()+0x14>
     7e2:	8c 91       	ld	r24, X
     7e4:	85 ff       	sbrs	r24, 5
     7e6:	f2 cf       	rjmp	.-28     	; 0x7cc <HardwareSerial::flush()+0x10>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:215
      // Interrupts are globally disabled, but the DR empty
      // interrupt should be enabled, so poll the DR empty flag to
      // prevent deadlock
      if (bit_is_set(*_ucsra, UDRE0))
     7e8:	80 81       	ld	r24, Z
     7ea:	85 ff       	sbrs	r24, 5
     7ec:	ed cf       	rjmp	.-38     	; 0x7c8 <HardwareSerial::flush()+0xc>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:216
        _tx_udr_empty_irq();
     7ee:	ce 01       	movw	r24, r28
     7f0:	0e 94 54 03 	call	0x6a8	; 0x6a8 <HardwareSerial::_tx_udr_empty_irq()>
     7f4:	e9 cf       	rjmp	.-46     	; 0x7c8 <HardwareSerial::flush()+0xc>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:220
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <twi_stop>:
twi_stop():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:436
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
     7fc:	85 ed       	ldi	r24, 0xD5	; 213
     7fe:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:456
          return;
        }
      }
    }
  #else
    while(TWCR & _BV(TWSTO)){
     802:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
     806:	84 fd       	sbrc	r24, 4
     808:	fc cf       	rjmp	.-8      	; 0x802 <twi_stop+0x6>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:462
      continue;
    }
  #endif

  // update twi state
  twi_state = TWI_READY;
     80a:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:463
}
     80e:	08 95       	ret

00000810 <twi_transmit>:
twi_transmit():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:371
uint8_t twi_transmit(const uint8_t* data, uint8_t length)
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
     810:	20 91 02 02 	lds	r18, 0x0202	; 0x800202 <twi_txBufferLength>
     814:	26 0f       	add	r18, r22
     816:	33 27       	eor	r19, r19
     818:	33 1f       	adc	r19, r19
     81a:	21 32       	cpi	r18, 0x21	; 33
     81c:	31 05       	cpc	r19, r1
     81e:	ec f4       	brge	.+58     	; 0x85a <twi_transmit+0x4a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:376
    return 1;
  }

  // ensure we are currently a slave transmitter
  if(TWI_STX != twi_state){
     820:	20 91 7e 02 	lds	r18, 0x027E	; 0x80027e <twi_state>
     824:	fc 01       	movw	r30, r24
     826:	90 e0       	ldi	r25, 0x00	; 0
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	24 30       	cpi	r18, 0x04	; 4
     82c:	69 f0       	breq	.+26     	; 0x848 <twi_transmit+0x38>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:377
    return 2;
     82e:	82 e0       	ldi	r24, 0x02	; 2
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:387
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;

  return 0;
}
     830:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:382
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
    twi_txBuffer[twi_txBufferLength+i] = data[i];
     832:	a0 91 02 02 	lds	r26, 0x0202	; 0x800202 <twi_txBufferLength>
     836:	21 91       	ld	r18, Z+
     838:	ac 01       	movw	r20, r24
     83a:	4e 51       	subi	r20, 0x1E	; 30
     83c:	5e 4f       	sbci	r21, 0xFE	; 254
     83e:	a4 0f       	add	r26, r20
     840:	b5 2f       	mov	r27, r21
     842:	b1 1d       	adc	r27, r1
     844:	2c 93       	st	X, r18
     846:	01 96       	adiw	r24, 0x01	; 1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:381
  if(TWI_STX != twi_state){
    return 2;
  }

  // set length and copy data into tx buffer
  for(i = 0; i < length; ++i){
     848:	86 17       	cp	r24, r22
     84a:	98 f3       	brcs	.-26     	; 0x832 <twi_transmit+0x22>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:384
    twi_txBuffer[twi_txBufferLength+i] = data[i];
  }
  twi_txBufferLength += length;
     84c:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <twi_txBufferLength>
     850:	68 0f       	add	r22, r24
     852:	60 93 02 02 	sts	0x0202, r22	; 0x800202 <twi_txBufferLength>
     856:	80 e0       	ldi	r24, 0x00	; 0
     858:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:372
{
  uint8_t i;

  // ensure data will fit into buffer
  if(TWI_BUFFER_SIZE < (twi_txBufferLength+length)){
    return 1;
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	08 95       	ret

0000085e <TwoWire::flush()>:
flush():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:326
}

void TwoWire::flush(void)
{
  // XXX: to be implemented.
}
     85e:	08 95       	ret

00000860 <TwoWire::peek()>:
peek():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:316
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;

  if(rxBufferIndex < rxBufferLength){
     860:	e0 91 55 02 	lds	r30, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
     864:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
     868:	e8 17       	cp	r30, r24
     86a:	30 f4       	brcc	.+12     	; 0x878 <TwoWire::peek()+0x18>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:317
    value = rxBuffer[rxBufferIndex];
     86c:	f0 e0       	ldi	r31, 0x00	; 0
     86e:	ea 5a       	subi	r30, 0xAA	; 170
     870:	fd 4f       	sbci	r31, 0xFD	; 253
     872:	80 81       	ld	r24, Z
     874:	90 e0       	ldi	r25, 0x00	; 0
     876:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:314
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  int value = -1;
     878:	8f ef       	ldi	r24, 0xFF	; 255
     87a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:321
  if(rxBufferIndex < rxBufferLength){
    value = rxBuffer[rxBufferIndex];
  }

  return value;
}
     87c:	08 95       	ret

0000087e <TwoWire::read()>:
read():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:301
int TwoWire::read(void)
{
  int value = -1;

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     87e:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
     882:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:298
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  int value = -1;
     886:	2f ef       	ldi	r18, 0xFF	; 255
     888:	3f ef       	ldi	r19, 0xFF	; 255
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:301

  // get each successive byte on each call
  if(rxBufferIndex < rxBufferLength){
     88a:	98 17       	cp	r25, r24
     88c:	48 f4       	brcc	.+18     	; 0x8a0 <TwoWire::read()+0x22>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:302
    value = rxBuffer[rxBufferIndex];
     88e:	e9 2f       	mov	r30, r25
     890:	f0 e0       	ldi	r31, 0x00	; 0
     892:	ea 5a       	subi	r30, 0xAA	; 170
     894:	fd 4f       	sbci	r31, 0xFD	; 253
     896:	20 81       	ld	r18, Z
     898:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:303
    ++rxBufferIndex;
     89a:	9f 5f       	subi	r25, 0xFF	; 255
     89c:	90 93 55 02 	sts	0x0255, r25	; 0x800255 <TwoWire::rxBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:307
  }

  return value;
}
     8a0:	c9 01       	movw	r24, r18
     8a2:	08 95       	ret

000008a4 <TwoWire::write(unsigned char const*, unsigned int)>:
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:271

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
     8a4:	cf 92       	push	r12
     8a6:	df 92       	push	r13
     8a8:	ef 92       	push	r14
     8aa:	ff 92       	push	r15
     8ac:	0f 93       	push	r16
     8ae:	1f 93       	push	r17
     8b0:	cf 93       	push	r28
     8b2:	df 93       	push	r29
     8b4:	7c 01       	movw	r14, r24
     8b6:	cb 01       	movw	r24, r22
     8b8:	8a 01       	movw	r16, r20
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:272
  if(transmitting){
     8ba:	20 91 7f 02 	lds	r18, 0x027F	; 0x80027f <TwoWire::transmitting>
     8be:	22 23       	and	r18, r18
     8c0:	89 f0       	breq	.+34     	; 0x8e4 <TwoWire::write(unsigned char const*, unsigned int)+0x40>
     8c2:	eb 01       	movw	r28, r22
     8c4:	6b 01       	movw	r12, r22
     8c6:	c4 0e       	add	r12, r20
     8c8:	d5 1e       	adc	r13, r21
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:274
  // in master transmitter mode
    for(size_t i = 0; i < quantity; ++i){
     8ca:	cc 15       	cp	r28, r12
     8cc:	dd 05       	cpc	r29, r13
     8ce:	69 f0       	breq	.+26     	; 0x8ea <TwoWire::write(unsigned char const*, unsigned int)+0x46>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:275
      write(data[i]);
     8d0:	69 91       	ld	r22, Y+
     8d2:	d7 01       	movw	r26, r14
     8d4:	ed 91       	ld	r30, X+
     8d6:	fc 91       	ld	r31, X
     8d8:	01 90       	ld	r0, Z+
     8da:	f0 81       	ld	r31, Z
     8dc:	e0 2d       	mov	r30, r0
     8de:	c7 01       	movw	r24, r14
     8e0:	09 95       	icall
     8e2:	f3 cf       	rjmp	.-26     	; 0x8ca <TwoWire::write(unsigned char const*, unsigned int)+0x26>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:280
    }
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(data, quantity);
     8e4:	64 2f       	mov	r22, r20
     8e6:	0e 94 08 04 	call	0x810	; 0x810 <twi_transmit>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:283
  }
  return quantity;
}
     8ea:	c8 01       	movw	r24, r16
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	ff 90       	pop	r15
     8f6:	ef 90       	pop	r14
     8f8:	df 90       	pop	r13
     8fa:	cf 90       	pop	r12
     8fc:	08 95       	ret

000008fe <TwoWire::write(unsigned char)>:
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:246

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	1f 92       	push	r1
     904:	cd b7       	in	r28, 0x3d	; 61
     906:	de b7       	in	r29, 0x3e	; 62
     908:	69 83       	std	Y+1, r22	; 0x01
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:247
  if(transmitting){
     90a:	20 91 7f 02 	lds	r18, 0x027F	; 0x80027f <TwoWire::transmitting>
     90e:	22 23       	and	r18, r18
     910:	f9 f0       	breq	.+62     	; 0x950 <__stack+0x51>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:250
  // in master transmitter mode
    // don't bother if buffer is full
    if(txBufferLength >= TWI_BUFFER_SIZE){
     912:	20 91 a2 02 	lds	r18, 0x02A2	; 0x8002a2 <TwoWire::txBufferLength>
     916:	20 32       	cpi	r18, 0x20	; 32
     918:	58 f0       	brcs	.+22     	; 0x930 <__stack+0x31>
_ZN5Print13setWriteErrorEi():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:44
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
     91a:	21 e0       	ldi	r18, 0x01	; 1
     91c:	30 e0       	ldi	r19, 0x00	; 0
     91e:	fc 01       	movw	r30, r24
     920:	33 83       	std	Z+3, r19	; 0x03
     922:	22 83       	std	Z+2, r18	; 0x02
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:252
      setWriteError();
      return 0;
     924:	90 e0       	ldi	r25, 0x00	; 0
     926:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:265
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
}
     928:	0f 90       	pop	r0
     92a:	df 91       	pop	r29
     92c:	cf 91       	pop	r28
     92e:	08 95       	ret
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:255
    if(txBufferLength >= TWI_BUFFER_SIZE){
      setWriteError();
      return 0;
    }
    // put byte in tx buffer
    txBuffer[txBufferIndex] = data;
     930:	80 91 80 02 	lds	r24, 0x0280	; 0x800280 <TwoWire::txBufferIndex>
     934:	e8 2f       	mov	r30, r24
     936:	f0 e0       	ldi	r31, 0x00	; 0
     938:	ef 57       	subi	r30, 0x7F	; 127
     93a:	fd 4f       	sbci	r31, 0xFD	; 253
     93c:	99 81       	ldd	r25, Y+1	; 0x01
     93e:	90 83       	st	Z, r25
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:256
    ++txBufferIndex;
     940:	8f 5f       	subi	r24, 0xFF	; 255
     942:	80 93 80 02 	sts	0x0280, r24	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:258
    // update amount in buffer
    txBufferLength = txBufferIndex;
     946:	80 93 a2 02 	sts	0x02A2, r24	; 0x8002a2 <TwoWire::txBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:264
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
  }
  return 1;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	90 e0       	ldi	r25, 0x00	; 0
     94e:	ec cf       	rjmp	.-40     	; 0x928 <__stack+0x29>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:262
    // update amount in buffer
    txBufferLength = txBufferIndex;
  }else{
  // in slave send mode
    // reply to master
    twi_transmit(&data, 1);
     950:	61 e0       	ldi	r22, 0x01	; 1
     952:	ce 01       	movw	r24, r28
     954:	01 96       	adiw	r24, 0x01	; 1
     956:	0e 94 08 04 	call	0x810	; 0x810 <twi_transmit>
     95a:	f7 cf       	rjmp	.-18     	; 0x94a <__stack+0x4b>

0000095c <Print::availableForWrite()>:
availableForWrite():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:63
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overriden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     95c:	90 e0       	ldi	r25, 0x00	; 0
     95e:	80 e0       	ldi	r24, 0x00	; 0
     960:	08 95       	ret

00000962 <SPIClass::endTransaction()>:
endTransaction():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:287
      #endif
      {
        SREG = interruptSave;
      }
    }
  }
     962:	08 95       	ret

00000964 <SPIClass::transfer(unsigned char)>:
transfer():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:212
    SPSR = settings.spsr;
  }

  // Write to the SPI bus (MOSI pin) and also receive (MISO pin)
  inline static uint8_t transfer(uint8_t data) {
    SPDR = data;
     964:	8e bd       	out	0x2e, r24	; 46
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:219
     * The following NOP introduces a small delay that can prevent the wait
     * loop form iterating when running at the maximum speed. This gives
     * about 10% more speed, even if it seems counter-intuitive. At lower
     * speeds it is unnoticed.
     */
    asm volatile("nop");
     966:	00 00       	nop
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:220
    while (!(SPSR & _BV(SPIF))) ; // wait
     968:	0d b4       	in	r0, 0x2d	; 45
     96a:	07 fe       	sbrs	r0, 7
     96c:	fd cf       	rjmp	.-6      	; 0x968 <SPIClass::transfer(unsigned char)+0x4>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:221
    return SPDR;
     96e:	8e b5       	in	r24, 0x2e	; 46
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\SPI\src/SPI.h:222
  }
     970:	08 95       	ret

00000972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>:
putData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:306
      }  // of  if-then-else we are using hardware SPI
    }    // of if-then-else we are using I2C
    return (structSize);
  }  // of method getData()
  template <typename T>
  uint8_t &putData(const uint8_t addr, const T &value) const {
     972:	af 92       	push	r10
     974:	bf 92       	push	r11
     976:	df 92       	push	r13
     978:	ef 92       	push	r14
     97a:	ff 92       	push	r15
     97c:	0f 93       	push	r16
     97e:	1f 93       	push	r17
     980:	cf 93       	push	r28
     982:	df 93       	push	r29
     984:	d8 2e       	mov	r13, r24
     986:	eb 01       	movw	r28, r22
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:316
      @param[in] value Data Type "T" to write
      @return    Size of data written in bytes
    */
    const uint8_t *bytePtr    = (const uint8_t *)&value;  // Pointer to structure beginning
    static uint8_t structSize = sizeof(T);                // Number of bytes in structure
    if (_I2CAddress)                                      // Using I2C if address is non-zero
     988:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
     98c:	88 23       	and	r24, r24
     98e:	09 f1       	breq	.+66     	; 0x9d2 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x60>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
     990:	91 e0       	ldi	r25, 0x01	; 1
     992:	90 93 7f 02 	sts	0x027F, r25	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
     996:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     99a:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
     99e:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
putData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:319
    {                                                     //
      Wire.beginTransmission(_I2CAddress);                // Address the I2C device
      Wire.write(addr);                                   // Send register address to write
     9a2:	6d 2d       	mov	r22, r13
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	93 e0       	ldi	r25, 0x03	; 3
     9a8:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:321
      for (uint8_t i = 0; i < sizeof(T); i++)
        Wire.write(*bytePtr++);  // loop for each byte to be written
     9ac:	68 81       	ld	r22, Y
     9ae:	80 e4       	ldi	r24, 0x40	; 64
     9b0:	93 e0       	ldi	r25, 0x03	; 3
     9b2:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:322
      Wire.endTransmission();    // Close transmission
     9b6:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:362
          bytePtr++;                                   // go to next byte to write
        }                                              // of for-next each byte to be read
      }                                                // of  if-then-else we are using hardware SPI
    }                                                  // of if-then-else we are using I2C
    return (structSize);
  }  // of method putData()
     9ba:	84 e0       	ldi	r24, 0x04	; 4
     9bc:	91 e0       	ldi	r25, 0x01	; 1
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	df 90       	pop	r13
     9cc:	bf 90       	pop	r11
     9ce:	af 90       	pop	r10
     9d0:	08 95       	ret
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:324
      Wire.write(addr);                                   // Send register address to write
      for (uint8_t i = 0; i < sizeof(T); i++)
        Wire.write(*bytePtr++);  // loop for each byte to be written
      Wire.endTransmission();    // Close transmission
    } else {
      if (_sck == 0)  // if sck is zero then hardware SPI
     9d2:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:314
      @details   As a template it can support compile-time data type definitions
      @param[in] addr Memory address
      @param[in] value Data Type "T" to write
      @return    Size of data written in bytes
    */
    const uint8_t *bytePtr    = (const uint8_t *)&value;  // Pointer to structure beginning
     9d6:	8b 01       	movw	r16, r22
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:346
          reply = 0;                // reset our return byte
          digitalWrite(_cs, LOW);   // Tell BME680 to listen up
          for (j = 7; j >= 0; j--)  // First send the address byte
          {
            digitalWrite(_sck, LOW);                         // set the clock signal
            digitalWrite(_mosi, (addr & ~0x80) & (1 << j));  // set the MOSI pin state
     9d8:	aa 24       	eor	r10, r10
     9da:	a3 94       	inc	r10
     9dc:	b1 2c       	mov	r11, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:324
      Wire.write(addr);                                   // Send register address to write
      for (uint8_t i = 0; i < sizeof(T); i++)
        Wire.write(*bytePtr++);  // loop for each byte to be written
      Wire.endTransmission();    // Close transmission
    } else {
      if (_sck == 0)  // if sck is zero then hardware SPI
     9de:	81 11       	cpse	r24, r1
     9e0:	20 c0       	rjmp	.+64     	; 0xa22 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xb0>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:326
      {
        SPI.beginTransaction(
     9e2:	81 e5       	ldi	r24, 0x51	; 81
     9e4:	90 e0       	ldi	r25, 0x00	; 0
     9e6:	0e 94 9b 01 	call	0x336	; 0x336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:328
            SPISettings(SPI_HERZ, MSBFIRST, SPI_MODE0));  // start the SPI transaction
        digitalWrite(_cs, LOW);                           // Tell BME680 to listen up
     9ea:	60 e0       	ldi	r22, 0x00	; 0
     9ec:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     9f0:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:329
        SPI.transfer(addr & ~0x80);                       // bit 7 is low, so write a byte
     9f4:	8d 2d       	mov	r24, r13
     9f6:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
     9fa:	fc 2e       	mov	r15, r28
     9fc:	1d 2f       	mov	r17, r29
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:330
        for (uint8_t i = 0; i < structSize; i++) {
     9fe:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const::structSize>
     a02:	80 2f       	mov	r24, r16
     a04:	8f 19       	sub	r24, r15
     a06:	89 17       	cp	r24, r25
     a08:	30 f4       	brcc	.+12     	; 0xa16 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xa4>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:331
          SPI.transfer(*bytePtr++);
     a0a:	f8 01       	movw	r30, r16
     a0c:	81 91       	ld	r24, Z+
     a0e:	8f 01       	movw	r16, r30
     a10:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
     a14:	f4 cf       	rjmp	.-24     	; 0x9fe <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x8c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:333
        }                         // loop for each byte to be written
        digitalWrite(_cs, HIGH);  // Tell BME680 to stop listening
     a16:	61 e0       	ldi	r22, 0x01	; 1
     a18:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     a1c:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     a20:	cc cf       	rjmp	.-104    	; 0x9ba <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x48>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:339
        SPI.endTransaction();     // End the transaction
      } else                      // Otherwise soft SPI is used
      {
        int8_t  i, j;                     // Loop variables
        uint8_t reply;                    // return byte for soft SPI transfer
        for (i = 0; i < structSize; i++)  // Loop for each byte to read
     a22:	80 2f       	mov	r24, r16
     a24:	8c 1b       	sub	r24, r28
     a26:	08 2e       	mov	r0, r24
     a28:	00 0c       	add	r0, r0
     a2a:	99 0b       	sbc	r25, r25
     a2c:	20 91 04 01 	lds	r18, 0x0104	; 0x800104 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const::structSize>
     a30:	28 17       	cp	r18, r24
     a32:	19 06       	cpc	r1, r25
     a34:	11 f2       	breq	.-124    	; 0x9ba <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x48>
     a36:	0c f2       	brlt	.-126    	; 0x9ba <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x48>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:342
        {
          reply = 0;                // reset our return byte
          digitalWrite(_cs, LOW);   // Tell BME680 to listen up
     a38:	60 e0       	ldi	r22, 0x00	; 0
     a3a:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     a3e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     a42:	97 e0       	ldi	r25, 0x07	; 7
     a44:	e9 2e       	mov	r14, r25
     a46:	f1 2c       	mov	r15, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:345
          for (j = 7; j >= 0; j--)  // First send the address byte
          {
            digitalWrite(_sck, LOW);                         // set the clock signal
     a48:	60 e0       	ldi	r22, 0x00	; 0
     a4a:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     a4e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:346
            digitalWrite(_mosi, (addr & ~0x80) & (1 << j));  // set the MOSI pin state
     a52:	b5 01       	movw	r22, r10
     a54:	0e 2c       	mov	r0, r14
     a56:	01 c0       	rjmp	.+2      	; 0xa5a <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xe8>
     a58:	66 0f       	add	r22, r22
     a5a:	0a 94       	dec	r0
     a5c:	ea f7       	brpl	.-6      	; 0xa58 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xe6>
     a5e:	6d 21       	and	r22, r13
     a60:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
     a64:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:347
            digitalWrite(_sck, HIGH);                        // reset the clock signal
     a68:	61 e0       	ldi	r22, 0x01	; 1
     a6a:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     a6e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     a72:	81 e0       	ldi	r24, 0x01	; 1
     a74:	e8 1a       	sub	r14, r24
     a76:	f1 08       	sbc	r15, r1
     a78:	38 f7       	brcc	.-50     	; 0xa48 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xd6>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:343
        uint8_t reply;                    // return byte for soft SPI transfer
        for (i = 0; i < structSize; i++)  // Loop for each byte to read
        {
          reply = 0;                // reset our return byte
          digitalWrite(_cs, LOW);   // Tell BME680 to listen up
          for (j = 7; j >= 0; j--)  // First send the address byte
     a7a:	87 e0       	ldi	r24, 0x07	; 7
     a7c:	e8 2e       	mov	r14, r24
     a7e:	f1 2c       	mov	r15, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:352
            digitalWrite(_sck, HIGH);                        // reset the clock signal
          }                                                  // of for-next each bit
          for (j = 7; j >= 0; j--)                           // Now read the data at that byte
          {
            reply <<= 1;                               // shift buffer one bit left
            digitalWrite(_sck, LOW);                   // set the clock signal
     a80:	60 e0       	ldi	r22, 0x00	; 0
     a82:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     a86:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:353
            digitalWrite(_mosi, *bytePtr & (1 << j));  // set the MOSI pin state
     a8a:	c5 01       	movw	r24, r10
     a8c:	0e 2c       	mov	r0, r14
     a8e:	01 c0       	rjmp	.+2      	; 0xa92 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x120>
     a90:	88 0f       	add	r24, r24
     a92:	0a 94       	dec	r0
     a94:	ea f7       	brpl	.-6      	; 0xa90 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x11e>
     a96:	f8 01       	movw	r30, r16
     a98:	60 81       	ld	r22, Z
     a9a:	68 23       	and	r22, r24
     a9c:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
     aa0:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:354
            digitalWrite(_sck, HIGH);                  // reset the clock signal
     aa4:	61 e0       	ldi	r22, 0x01	; 1
     aa6:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     aaa:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     aae:	f1 e0       	ldi	r31, 0x01	; 1
     ab0:	ef 1a       	sub	r14, r31
     ab2:	f1 08       	sbc	r15, r1
     ab4:	28 f7       	brcc	.-54     	; 0xa80 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0x10e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:356
          }                                            // of for-next each bit
          digitalWrite(_cs, HIGH);                     // Tell BME680 to stop listening
     ab6:	61 e0       	ldi	r22, 0x01	; 1
     ab8:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     abc:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:357
          bytePtr++;                                   // go to next byte to write
     ac0:	0f 5f       	subi	r16, 0xFF	; 255
     ac2:	1f 4f       	sbci	r17, 0xFF	; 255
     ac4:	ae cf       	rjmp	.-164    	; 0xa22 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]+0xb0>

00000ac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>:
twi_readFrom():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:177
        twi_handleTimeout(twi_do_reset_on_timeout);
        return 0;
      }
    }
  #else
    while(TWI_READY != twi_state){
     ac6:	90 91 7e 02 	lds	r25, 0x027E	; 0x80027e <twi_state>
     aca:	91 11       	cpse	r25, r1
     acc:	fc cf       	rjmp	.-8      	; 0xac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:181
      continue;
    }
  #endif
  twi_state = TWI_MRX;
     ace:	91 e0       	ldi	r25, 0x01	; 1
     ad0:	90 93 7e 02 	sts	0x027E, r25	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:182
  twi_sendStop = sendStop;
     ad4:	90 93 7d 02 	sts	0x027D, r25	; 0x80027d <twi_sendStop>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:184
  // reset error state (0xFF.. no error occurred)
  twi_error = 0xFF;
     ad8:	2f ef       	ldi	r18, 0xFF	; 255
     ada:	20 93 7c 02 	sts	0x027C, r18	; 0x80027c <twi_error>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:187

  // initialize buffer iteration vars
  twi_masterBuffer = data;
     ade:	26 e5       	ldi	r18, 0x56	; 86
     ae0:	32 e0       	ldi	r19, 0x02	; 2
     ae2:	30 93 7b 02 	sts	0x027B, r19	; 0x80027b <twi_masterBuffer+0x1>
     ae6:	20 93 7a 02 	sts	0x027A, r18	; 0x80027a <twi_masterBuffer>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:188
  twi_masterBufferIndex = 0;
     aea:	10 92 79 02 	sts	0x0279, r1	; 0x800279 <twi_masterBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:189
  twi_masterBufferLength = length-1;  // This is not intuitive, read on...
     aee:	2f ef       	ldi	r18, 0xFF	; 255
     af0:	26 0f       	add	r18, r22
     af2:	20 93 78 02 	sts	0x0278, r18	; 0x800278 <twi_masterBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:197
  // Therefore we must actually set NACK when the _next_ to last byte is
  // received, causing that NACK to be sent in response to receiving the last
  // expected byte of data.

  // build sla+w, slave device address + w bit
  twi_slarw = TW_READ;
     af6:	90 93 77 02 	sts	0x0277, r25	; 0x800277 <twi_slarw>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:198
  twi_slarw |= address << 1;
     afa:	90 91 77 02 	lds	r25, 0x0277	; 0x800277 <twi_slarw>
     afe:	88 0f       	add	r24, r24
     b00:	89 2b       	or	r24, r25
     b02:	80 93 77 02 	sts	0x0277, r24	; 0x800277 <twi_slarw>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:200

  if (true == twi_inRepStart) {
     b06:	80 91 76 02 	lds	r24, 0x0276	; 0x800276 <twi_inRepStart>
     b0a:	81 30       	cpi	r24, 0x01	; 1
     b0c:	e9 f4       	brne	.+58     	; 0xb48 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]+0x82>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:207
    // (@@@ we hope), and the TWI statemachine is just waiting for the address byte.
    // We need to remove ourselves from the repeated start state before we enable interrupts,
    // since the ISR is ASYNC, and we could get confused if we hit the ISR before cleaning
    // up. Also, don't enable the START interrupt. There may be one pending from the
    // repeated start that we sent ourselves, and that would really confuse things.
    twi_inRepStart = false; // Remember, we're dealing with an ASYNC ISR
     b0e:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <twi_inRepStart>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:219
          return 0;
        }
      } while(TWCR & _BV(TWWC));
    #else
      do {
        TWDR = twi_slarw;
     b12:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <twi_slarw>
     b16:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:220
      } while(TWCR & _BV(TWWC));
     b1a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
     b1e:	83 fd       	sbrc	r24, 3
     b20:	f8 cf       	rjmp	.-16     	; 0xb12 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:222
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
     b22:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:226
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
     b24:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:238
        twi_handleTimeout(twi_do_reset_on_timeout);
        return 0;
      }
    }
  #else
    while(TWI_MRX == twi_state){
     b28:	80 91 7e 02 	lds	r24, 0x027E	; 0x80027e <twi_state>
     b2c:	81 30       	cpi	r24, 0x01	; 1
     b2e:	e1 f3       	breq	.-8      	; 0xb28 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]+0x62>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:243
      continue;
    }
  #endif

  if (twi_masterBufferIndex < length)
     b30:	80 91 79 02 	lds	r24, 0x0279	; 0x800279 <twi_masterBufferIndex>
     b34:	86 17       	cp	r24, r22
     b36:	10 f4       	brcc	.+4      	; 0xb3c <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]+0x76>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:244
    length = twi_masterBufferIndex;
     b38:	60 91 79 02 	lds	r22, 0x0279	; 0x800279 <twi_masterBufferIndex>
requestFrom():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:120
    quantity = TWI_BUFFER_SIZE;
  }
  // perform blocking read into buffer
  uint8_t read = twi_readFrom(address, rxBuffer, quantity, sendStop);
  // set rx buffer iterator vars
  rxBufferIndex = 0;
     b3c:	10 92 55 02 	sts	0x0255, r1	; 0x800255 <TwoWire::rxBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:121
  rxBufferLength = read;
     b40:	60 93 54 02 	sts	0x0254, r22	; 0x800254 <TwoWire::rxBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:181
}

uint8_t TwoWire::requestFrom(uint8_t address, uint8_t quantity)
{
  return requestFrom((uint8_t)address, (uint8_t)quantity, (uint8_t)true);
}
     b44:	86 2f       	mov	r24, r22
     b46:	08 95       	ret
twi_readFrom():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:226
    #endif
    TWCR = _BV(TWINT) | _BV(TWEA) | _BV(TWEN) | _BV(TWIE);  // enable INTs, but not START
  }
  else
    // send start condition
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTA);
     b48:	85 ee       	ldi	r24, 0xE5	; 229
     b4a:	ec cf       	rjmp	.-40     	; 0xb24 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]+0x5e>

00000b4c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]>:
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:246
   this header file rather than in the c++ program library file. The "getData()" function is
   currently not used in the library directly, but the function "readByte()" is used which calls
   the getData().  The "putData()" is called directly in the code.
  */
  template <typename T>
  uint8_t &getData(const uint8_t addr, T &value) const {
     b4c:	cf 92       	push	r12
     b4e:	df 92       	push	r13
     b50:	ef 92       	push	r14
     b52:	ff 92       	push	r15
     b54:	0f 93       	push	r16
     b56:	1f 93       	push	r17
     b58:	cf 93       	push	r28
     b5a:	df 93       	push	r29
     b5c:	eb 01       	movw	r28, r22
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:256
      @param[in] value Data Type "T" to read
      @return    Size of data read in bytes
    */
    uint8_t *      bytePtr    = (uint8_t *)&value;  // Pointer to structure beginning
    static uint8_t structSize = sizeof(T);          // Number of bytes in structure
    if (_I2CAddress)                                // Using I2C if address is non-zero
     b5e:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <BME680+0x17>
     b62:	99 23       	and	r25, r25
     b64:	69 f1       	breq	.+90     	; 0xbc0 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x74>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
     b66:	21 e0       	ldi	r18, 0x01	; 1
     b68:	20 93 7f 02 	sts	0x027F, r18	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
     b6c:	90 93 a1 02 	sts	0x02A1, r25	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
     b70:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
     b74:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:259
    {                                               //
      Wire.beginTransmission(_I2CAddress);          // Address the I2C device
      Wire.write(addr);                             // Send register address to read
     b78:	68 2f       	mov	r22, r24
     b7a:	80 e4       	ldi	r24, 0x40	; 64
     b7c:	93 e0       	ldi	r25, 0x03	; 3
     b7e:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:260
      Wire.endTransmission();                       // Close transmission
     b82:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:261
      Wire.requestFrom(_I2CAddress, sizeof(T));     // Request 1 byte of data
     b86:	61 e0       	ldi	r22, 0x01	; 1
     b88:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
     b8c:	0e 94 63 05 	call	0xac6	; 0xac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:262
      structSize = Wire.available();                // Use the actual number of bytes
     b90:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
     b94:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
     b98:	89 1b       	sub	r24, r25
     b9a:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const::structSize>
     b9e:	fc 2e       	mov	r15, r28
     ba0:	8e 01       	movw	r16, r28
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:263
      for (uint8_t i = 0; i < structSize; i++)
     ba2:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const::structSize>
     ba6:	80 2f       	mov	r24, r16
     ba8:	8f 19       	sub	r24, r15
     baa:	89 17       	cp	r24, r25
     bac:	08 f0       	brcs	.+2      	; 0xbb0 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x64>
     bae:	7a c0       	rjmp	.+244    	; 0xca4 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x158>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:264
        *bytePtr++ = Wire.read();  // loop for each byte to be read
     bb0:	80 e4       	ldi	r24, 0x40	; 64
     bb2:	93 e0       	ldi	r25, 0x03	; 3
     bb4:	0e 94 3f 04 	call	0x87e	; 0x87e <TwoWire::read()>
     bb8:	f8 01       	movw	r30, r16
     bba:	81 93       	st	Z+, r24
     bbc:	8f 01       	movw	r16, r30
     bbe:	f1 cf       	rjmp	.-30     	; 0xba2 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x56>
     bc0:	18 2f       	mov	r17, r24
     bc2:	10 68       	ori	r17, 0x80	; 128
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:268
    }                              //
    else                           //
    {                              //
      if (_sck == 0)               // if sck is zero then hardware SPI
     bc4:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     bc8:	81 11       	cpse	r24, r1
     bca:	1c c0       	rjmp	.+56     	; 0xc04 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0xb8>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:270
      {                            //
        SPI.beginTransaction(
     bcc:	81 e5       	ldi	r24, 0x51	; 81
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	0e 94 9b 01 	call	0x336	; 0x336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:272
            SPISettings(SPI_HERZ, MSBFIRST, SPI_MODE0));  // Start the SPI transaction
        digitalWrite(_cs, LOW);                           // Tell BME680 to listen up
     bd4:	60 e0       	ldi	r22, 0x00	; 0
     bd6:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     bda:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:273
        SPI.transfer(addr | 0x80);                        // bit 7 is high, so read a byte
     bde:	81 2f       	mov	r24, r17
     be0:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
     be4:	fc 2e       	mov	r15, r28
     be6:	8e 01       	movw	r16, r28
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:274
        for (uint8_t i = 0; i < structSize; i++)
     be8:	90 91 03 01 	lds	r25, 0x0103	; 0x800103 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const::structSize>
     bec:	80 2f       	mov	r24, r16
     bee:	8f 19       	sub	r24, r15
     bf0:	89 17       	cp	r24, r25
     bf2:	08 f0       	brcs	.+2      	; 0xbf6 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0xaa>
     bf4:	52 c0       	rjmp	.+164    	; 0xc9a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x14e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:275
          *bytePtr++ = SPI.transfer(0);  // loop for each byte to be read
     bf6:	80 e0       	ldi	r24, 0x00	; 0
     bf8:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
     bfc:	f8 01       	movw	r30, r16
     bfe:	81 93       	st	Z+, r24
     c00:	8f 01       	movw	r16, r30
     c02:	f2 cf       	rjmp	.-28     	; 0xbe8 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x9c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:281
        digitalWrite(_cs, HIGH);         // Tell BME680 to stop listening
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
     c04:	60 e0       	ldi	r22, 0x00	; 0
     c06:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     c0a:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     c0e:	87 e0       	ldi	r24, 0x07	; 7
     c10:	e8 2e       	mov	r14, r24
     c12:	f1 2c       	mov	r15, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
     c14:	cc 24       	eor	r12, r12
     c16:	c3 94       	inc	r12
     c18:	d1 2c       	mov	r13, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:284
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
     c1a:	60 e0       	ldi	r22, 0x00	; 0
     c1c:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     c20:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
     c24:	b6 01       	movw	r22, r12
     c26:	0e 2c       	mov	r0, r14
     c28:	01 c0       	rjmp	.+2      	; 0xc2c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0xe0>
     c2a:	66 0f       	add	r22, r22
     c2c:	0a 94       	dec	r0
     c2e:	ea f7       	brpl	.-6      	; 0xc2a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0xde>
     c30:	61 23       	and	r22, r17
     c32:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
     c36:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:286
          digitalWrite(_sck, HIGH);                         // reset the clock signal
     c3a:	61 e0       	ldi	r22, 0x01	; 1
     c3c:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     c40:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
     c44:	f1 e0       	ldi	r31, 0x01	; 1
     c46:	ef 1a       	sub	r14, r31
     c48:	f1 08       	sbc	r15, r1
     c4a:	38 f7       	brcc	.-50     	; 0xc1a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0xce>
     c4c:	fc 2e       	mov	r15, r28
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:282
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
     c4e:	8e 01       	movw	r16, r28
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
     c50:	80 2f       	mov	r24, r16
     c52:	8f 19       	sub	r24, r15
     c54:	08 2e       	mov	r0, r24
     c56:	00 0c       	add	r0, r0
     c58:	99 0b       	sbc	r25, r25
     c5a:	20 91 03 01 	lds	r18, 0x0103	; 0x800103 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const::structSize>
     c5e:	28 17       	cp	r18, r24
     c60:	19 06       	cpc	r1, r25
     c62:	d9 f0       	breq	.+54     	; 0xc9a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x14e>
     c64:	d4 f0       	brlt	.+52     	; 0xc9a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x14e>
     c66:	d8 e0       	ldi	r29, 0x08	; 8
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:290
        {                                                   //
          reply = 0;                                        // reset our return byte
     c68:	c0 e0       	ldi	r28, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:293
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
          {                                                 //
            reply <<= 1;                                    // shift buffer one bit left
     c6a:	cc 0f       	add	r28, r28
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:294
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
     c6c:	60 e0       	ldi	r22, 0x00	; 0
     c6e:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     c72:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:295
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
     c76:	61 e0       	ldi	r22, 0x01	; 1
     c78:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
     c7c:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:296
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
     c80:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <BME680+0x1d>
     c84:	0e 94 26 02 	call	0x44c	; 0x44c <digitalRead>
     c88:	89 2b       	or	r24, r25
     c8a:	09 f0       	breq	.+2      	; 0xc8e <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x142>
     c8c:	c1 60       	ori	r28, 0x01	; 1
     c8e:	d1 50       	subi	r29, 0x01	; 1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:291
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
     c90:	61 f7       	brne	.-40     	; 0xc6a <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x11e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:298
            reply <<= 1;                                    // shift buffer one bit left
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
          }                                                 // of for-next each bit
          *bytePtr++ = reply;                               // Add byte just read to return data
     c92:	f8 01       	movw	r30, r16
     c94:	c1 93       	st	Z+, r28
     c96:	8f 01       	movw	r16, r30
     c98:	db cf       	rjmp	.-74     	; 0xc50 <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]+0x104>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:300
        }                                                   // of for-next each byte to be read
        digitalWrite(_cs, HIGH);                            // Tell BME680 to stop listening
     c9a:	61 e0       	ldi	r22, 0x01	; 1
     c9c:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
     ca0:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:304
      }  // of  if-then-else we are using hardware SPI
    }    // of if-then-else we are using I2C
    return (structSize);
  }  // of method getData()
     ca4:	83 e0       	ldi	r24, 0x03	; 3
     ca6:	91 e0       	ldi	r25, 0x01	; 1
     ca8:	df 91       	pop	r29
     caa:	cf 91       	pop	r28
     cac:	1f 91       	pop	r17
     cae:	0f 91       	pop	r16
     cb0:	ff 90       	pop	r15
     cb2:	ef 90       	pop	r14
     cb4:	df 90       	pop	r13
     cb6:	cf 90       	pop	r12
     cb8:	08 95       	ret

00000cba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>:
readByte():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:610
    return true;
  }  // of if-then device is really a BME680
  else
    return false;
}  // of method commonInitialization
uint8_t BME680_Class::readByte(const uint8_t addr) const {
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29
     cbe:	1f 92       	push	r1
     cc0:	cd b7       	in	r28, 0x3d	; 61
     cc2:	de b7       	in	r29, 0x3e	; 62
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:612
  uint8_t returnValue;         // Storage for returned value
  getData(addr, returnValue);  // Read just one byte
     cc4:	be 01       	movw	r22, r28
     cc6:	6f 5f       	subi	r22, 0xFF	; 255
     cc8:	7f 4f       	sbci	r23, 0xFF	; 255
     cca:	0e 94 a6 05 	call	0xb4c	; 0xb4c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:614
  return (returnValue);        // Return byte just read
}  // of method readByte()
     cce:	89 81       	ldd	r24, Y+1	; 0x01
     cd0:	0f 90       	pop	r0
     cd2:	df 91       	pop	r29
     cd4:	cf 91       	pop	r28
     cd6:	08 95       	ret

00000cd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>:
measuring():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:951
  /*!
   * @brief Returns whether the BME680 is currently measuring
   * return "true" if a measurement is active, otherwise "false"
   */
  bool result(false);
  if ((readByte(BME680_STATUS_REGISTER) & _BV(BME680_MEASURING_BIT_POSITION)) != 0) {
     cd8:	8d e1       	ldi	r24, 0x1D	; 29
     cda:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
     cde:	85 fd       	sbrc	r24, 5
     ce0:	fb cf       	rjmp	.-10     	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
waitForReadings():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:896
void BME680_Class::waitForReadings() const {
  /*!
   @brief   Only returns once a measurement on the BME680 has completed
   */
  while (measuring()) {}  // loop until any active measurment is complete
}  // of method waitForReadings
     ce2:	08 95       	ret

00000ce4 <Print::print(char const*) [clone .constprop.9]>:
write():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/Print.h:54
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
     ce4:	44 e4       	ldi	r20, 0x44	; 68
     ce6:	52 e0       	ldi	r21, 0x02	; 2
     ce8:	fa 01       	movw	r30, r20
     cea:	01 90       	ld	r0, Z+
     cec:	00 20       	and	r0, r0
     cee:	e9 f7       	brne	.-6      	; 0xcea <Print::print(char const*) [clone .constprop.9]+0x6>
     cf0:	af 01       	movw	r20, r30
     cf2:	45 54       	subi	r20, 0x45	; 69
     cf4:	52 40       	sbci	r21, 0x02	; 2
     cf6:	64 e4       	ldi	r22, 0x44	; 68
     cf8:	72 e0       	ldi	r23, 0x02	; 2
     cfa:	83 ea       	ldi	r24, 0xA3	; 163
     cfc:	92 e0       	ldi	r25, 0x02	; 2
     cfe:	0c 94 d6 02 	jmp	0x5ac	; 0x5ac <Print::write(unsigned char const*, unsigned int)>

00000d02 <__vector_16>:
__vector_16():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:159
#if defined(__AVR_ATtiny24__) || defined(__AVR_ATtiny44__) || defined(__AVR_ATtiny84__)
ISR(TIM0_OVF_vect)
#else
ISR(TIMER0_OVF_vect)
#endif
{
     d02:	1f 92       	push	r1
     d04:	0f 92       	push	r0
     d06:	0f b6       	in	r0, 0x3f	; 63
     d08:	0f 92       	push	r0
     d0a:	11 24       	eor	r1, r1
     d0c:	2f 93       	push	r18
     d0e:	3f 93       	push	r19
     d10:	8f 93       	push	r24
     d12:	9f 93       	push	r25
     d14:	af 93       	push	r26
     d16:	bf 93       	push	r27
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:167
  static unsigned char timer0_exact = 0;
#endif

  // copy these to local variables so they can be stored in registers
  // (volatile variables must be read from memory on every access, so this saves time)
  unsigned long m = timer0_millis;
     d18:	80 91 3c 02 	lds	r24, 0x023C	; 0x80023c <timer0_millis>
     d1c:	90 91 3d 02 	lds	r25, 0x023D	; 0x80023d <timer0_millis+0x1>
     d20:	a0 91 3e 02 	lds	r26, 0x023E	; 0x80023e <timer0_millis+0x2>
     d24:	b0 91 3f 02 	lds	r27, 0x023F	; 0x80023f <timer0_millis+0x3>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:168
  unsigned char f = timer0_fract;
     d28:	30 91 3b 02 	lds	r19, 0x023B	; 0x80023b <timer0_fract>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:170

  f += FRACT_INC FRACT_INC_PLUS;
     d2c:	26 e0       	ldi	r18, 0x06	; 6
     d2e:	23 0f       	add	r18, r19
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:200
    ++f;
  }
#endif
#endif // CORRECT_EXACT_MILLIS

  if (f >= FRACT_MAX) {
     d30:	2d 37       	cpi	r18, 0x7D	; 125
     d32:	68 f1       	brcs	.+90     	; 0xd8e <__vector_16+0x8c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:201
    f -= FRACT_MAX;
     d34:	29 e8       	ldi	r18, 0x89	; 137
     d36:	23 0f       	add	r18, r19
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:202
    m += MILLIS_INC + 1;
     d38:	03 96       	adiw	r24, 0x03	; 3
     d3a:	a1 1d       	adc	r26, r1
     d3c:	b1 1d       	adc	r27, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:208
  }
  else {
    m += MILLIS_INC;
  }

  timer0_fract = f;
     d3e:	20 93 3b 02 	sts	0x023B, r18	; 0x80023b <timer0_fract>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:209
  timer0_millis = m;
     d42:	80 93 3c 02 	sts	0x023C, r24	; 0x80023c <timer0_millis>
     d46:	90 93 3d 02 	sts	0x023D, r25	; 0x80023d <timer0_millis+0x1>
     d4a:	a0 93 3e 02 	sts	0x023E, r26	; 0x80023e <timer0_millis+0x2>
     d4e:	b0 93 3f 02 	sts	0x023F, r27	; 0x80023f <timer0_millis+0x3>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:211
#ifndef CORRECT_EXACT_MICROS
  timer0_overflow_count++;
     d52:	80 91 40 02 	lds	r24, 0x0240	; 0x800240 <timer0_overflow_count>
     d56:	90 91 41 02 	lds	r25, 0x0241	; 0x800241 <timer0_overflow_count+0x1>
     d5a:	a0 91 42 02 	lds	r26, 0x0242	; 0x800242 <timer0_overflow_count+0x2>
     d5e:	b0 91 43 02 	lds	r27, 0x0243	; 0x800243 <timer0_overflow_count+0x3>
     d62:	01 96       	adiw	r24, 0x01	; 1
     d64:	a1 1d       	adc	r26, r1
     d66:	b1 1d       	adc	r27, r1
     d68:	80 93 40 02 	sts	0x0240, r24	; 0x800240 <timer0_overflow_count>
     d6c:	90 93 41 02 	sts	0x0241, r25	; 0x800241 <timer0_overflow_count+0x1>
     d70:	a0 93 42 02 	sts	0x0242, r26	; 0x800242 <timer0_overflow_count+0x2>
     d74:	b0 93 43 02 	sts	0x0243, r27	; 0x800243 <timer0_overflow_count+0x3>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:213
#endif
}
     d78:	bf 91       	pop	r27
     d7a:	af 91       	pop	r26
     d7c:	9f 91       	pop	r25
     d7e:	8f 91       	pop	r24
     d80:	3f 91       	pop	r19
     d82:	2f 91       	pop	r18
     d84:	0f 90       	pop	r0
     d86:	0f be       	out	0x3f, r0	; 63
     d88:	0f 90       	pop	r0
     d8a:	1f 90       	pop	r1
     d8c:	18 95       	reti
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:205
  if (f >= FRACT_MAX) {
    f -= FRACT_MAX;
    m += MILLIS_INC + 1;
  }
  else {
    m += MILLIS_INC;
     d8e:	02 96       	adiw	r24, 0x02	; 2
     d90:	a1 1d       	adc	r26, r1
     d92:	b1 1d       	adc	r27, r1
     d94:	d4 cf       	rjmp	.-88     	; 0xd3e <__vector_16+0x3c>

00000d96 <__vector_19>:
__vector_19():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:63
#elif defined(USART0_UDRE_vect)
ISR(USART0_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
     d96:	1f 92       	push	r1
     d98:	0f 92       	push	r0
     d9a:	0f b6       	in	r0, 0x3f	; 63
     d9c:	0f 92       	push	r0
     d9e:	11 24       	eor	r1, r1
     da0:	2f 93       	push	r18
     da2:	3f 93       	push	r19
     da4:	4f 93       	push	r20
     da6:	5f 93       	push	r21
     da8:	6f 93       	push	r22
     daa:	7f 93       	push	r23
     dac:	8f 93       	push	r24
     dae:	9f 93       	push	r25
     db0:	af 93       	push	r26
     db2:	bf 93       	push	r27
     db4:	ef 93       	push	r30
     db6:	ff 93       	push	r31
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:64
  Serial._tx_udr_empty_irq();
     db8:	83 ea       	ldi	r24, 0xA3	; 163
     dba:	92 e0       	ldi	r25, 0x02	; 2
     dbc:	0e 94 54 03 	call	0x6a8	; 0x6a8 <HardwareSerial::_tx_udr_empty_irq()>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:65
}
     dc0:	ff 91       	pop	r31
     dc2:	ef 91       	pop	r30
     dc4:	bf 91       	pop	r27
     dc6:	af 91       	pop	r26
     dc8:	9f 91       	pop	r25
     dca:	8f 91       	pop	r24
     dcc:	7f 91       	pop	r23
     dce:	6f 91       	pop	r22
     dd0:	5f 91       	pop	r21
     dd2:	4f 91       	pop	r20
     dd4:	3f 91       	pop	r19
     dd6:	2f 91       	pop	r18
     dd8:	0f 90       	pop	r0
     dda:	0f be       	out	0x3f, r0	; 63
     ddc:	0f 90       	pop	r0
     dde:	1f 90       	pop	r1
     de0:	18 95       	reti

00000de2 <__vector_18>:
__vector_18():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:50
#elif defined(USART_RX_vect)
  ISR(USART_RX_vect)
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
     de2:	1f 92       	push	r1
     de4:	0f 92       	push	r0
     de6:	0f b6       	in	r0, 0x3f	; 63
     de8:	0f 92       	push	r0
     dea:	11 24       	eor	r1, r1
     dec:	2f 93       	push	r18
     dee:	8f 93       	push	r24
     df0:	9f 93       	push	r25
     df2:	ef 93       	push	r30
     df4:	ff 93       	push	r31
_rx_complete_irq():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:100

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
     df6:	e0 91 b3 02 	lds	r30, 0x02B3	; 0x8002b3 <Serial+0x10>
     dfa:	f0 91 b4 02 	lds	r31, 0x02B4	; 0x8002b4 <Serial+0x11>
     dfe:	80 81       	ld	r24, Z
     e00:	e0 91 b9 02 	lds	r30, 0x02B9	; 0x8002b9 <Serial+0x16>
     e04:	f0 91 ba 02 	lds	r31, 0x02BA	; 0x8002ba <Serial+0x17>
     e08:	82 fd       	sbrc	r24, 2
     e0a:	1b c0       	rjmp	.+54     	; 0xe42 <__vector_18+0x60>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:103
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
     e0c:	90 81       	ld	r25, Z
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:104
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
     e0e:	80 91 bc 02 	lds	r24, 0x02BC	; 0x8002bc <Serial+0x19>
     e12:	8f 5f       	subi	r24, 0xFF	; 255
     e14:	8f 73       	andi	r24, 0x3F	; 63
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:110

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
     e16:	20 91 bd 02 	lds	r18, 0x02BD	; 0x8002bd <Serial+0x1a>
     e1a:	82 17       	cp	r24, r18
     e1c:	41 f0       	breq	.+16     	; 0xe2e <__vector_18+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:111
      _rx_buffer[_rx_buffer_head] = c;
     e1e:	e0 91 bc 02 	lds	r30, 0x02BC	; 0x8002bc <Serial+0x19>
     e22:	f0 e0       	ldi	r31, 0x00	; 0
     e24:	ed 55       	subi	r30, 0x5D	; 93
     e26:	fd 4f       	sbci	r31, 0xFD	; 253
     e28:	95 8f       	std	Z+29, r25	; 0x1d
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:112
      _rx_buffer_head = i;
     e2a:	80 93 bc 02 	sts	0x02BC, r24	; 0x8002bc <Serial+0x19>
__vector_18():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial0.cpp:52
    Serial._rx_complete_irq();
  }
     e2e:	ff 91       	pop	r31
     e30:	ef 91       	pop	r30
     e32:	9f 91       	pop	r25
     e34:	8f 91       	pop	r24
     e36:	2f 91       	pop	r18
     e38:	0f 90       	pop	r0
     e3a:	0f be       	out	0x3f, r0	; 63
     e3c:	0f 90       	pop	r0
     e3e:	1f 90       	pop	r1
     e40:	18 95       	reti
_rx_complete_irq():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial_private.h:116
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
     e42:	80 81       	ld	r24, Z
     e44:	f4 cf       	rjmp	.-24     	; 0xe2e <__vector_18+0x4c>

00000e46 <__vector_24>:
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:534
  }
  return(flag);
}

ISR(TWI_vect)
{
     e46:	1f 92       	push	r1
     e48:	0f 92       	push	r0
     e4a:	0f b6       	in	r0, 0x3f	; 63
     e4c:	0f 92       	push	r0
     e4e:	11 24       	eor	r1, r1
     e50:	2f 93       	push	r18
     e52:	3f 93       	push	r19
     e54:	4f 93       	push	r20
     e56:	5f 93       	push	r21
     e58:	6f 93       	push	r22
     e5a:	7f 93       	push	r23
     e5c:	8f 93       	push	r24
     e5e:	9f 93       	push	r25
     e60:	af 93       	push	r26
     e62:	bf 93       	push	r27
     e64:	ef 93       	push	r30
     e66:	ff 93       	push	r31
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  switch(TW_STATUS){
     e68:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
     e6c:	88 7f       	andi	r24, 0xF8	; 248
     e6e:	80 36       	cpi	r24, 0x60	; 96
     e70:	09 f4       	brne	.+2      	; 0xe74 <__vector_24+0x2e>
     e72:	4a c0       	rjmp	.+148    	; 0xf08 <__vector_24+0xc2>
     e74:	f0 f5       	brcc	.+124    	; 0xef2 <__vector_24+0xac>
     e76:	88 32       	cpi	r24, 0x28	; 40
     e78:	09 f4       	brne	.+2      	; 0xe7c <__vector_24+0x36>
     e7a:	a7 c0       	rjmp	.+334    	; 0xfca <__vector_24+0x184>
     e7c:	18 f5       	brcc	.+70     	; 0xec4 <__vector_24+0x7e>
     e7e:	80 31       	cpi	r24, 0x10	; 16
     e80:	09 f4       	brne	.+2      	; 0xe84 <__vector_24+0x3e>
     e82:	9b c0       	rjmp	.+310    	; 0xfba <__vector_24+0x174>
     e84:	b8 f4       	brcc	.+46     	; 0xeb4 <__vector_24+0x6e>
     e86:	88 23       	and	r24, r24
     e88:	09 f4       	brne	.+2      	; 0xe8c <__vector_24+0x46>
     e8a:	05 c1       	rjmp	.+522    	; 0x1096 <__vector_24+0x250>
     e8c:	88 30       	cpi	r24, 0x08	; 8
     e8e:	09 f4       	brne	.+2      	; 0xe92 <__vector_24+0x4c>
     e90:	94 c0       	rjmp	.+296    	; 0xfba <__vector_24+0x174>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:696
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
      break;
  }
}
     e92:	ff 91       	pop	r31
     e94:	ef 91       	pop	r30
     e96:	bf 91       	pop	r27
     e98:	af 91       	pop	r26
     e9a:	9f 91       	pop	r25
     e9c:	8f 91       	pop	r24
     e9e:	7f 91       	pop	r23
     ea0:	6f 91       	pop	r22
     ea2:	5f 91       	pop	r21
     ea4:	4f 91       	pop	r20
     ea6:	3f 91       	pop	r19
     ea8:	2f 91       	pop	r18
     eaa:	0f 90       	pop	r0
     eac:	0f be       	out	0x3f, r0	; 63
     eae:	0f 90       	pop	r0
     eb0:	1f 90       	pop	r1
     eb2:	18 95       	reti
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     eb4:	88 31       	cpi	r24, 0x18	; 24
     eb6:	09 f4       	brne	.+2      	; 0xeba <__vector_24+0x74>
     eb8:	88 c0       	rjmp	.+272    	; 0xfca <__vector_24+0x184>
     eba:	80 32       	cpi	r24, 0x20	; 32
     ebc:	51 f7       	brne	.-44     	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:570
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
     ebe:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <twi_error>
     ec2:	14 c0       	rjmp	.+40     	; 0xeec <__vector_24+0xa6>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     ec4:	80 34       	cpi	r24, 0x40	; 64
     ec6:	09 f4       	brne	.+2      	; 0xeca <__vector_24+0x84>
     ec8:	a5 c0       	rjmp	.+330    	; 0x1014 <__vector_24+0x1ce>
     eca:	40 f4       	brcc	.+16     	; 0xedc <__vector_24+0x96>
     ecc:	80 33       	cpi	r24, 0x30	; 48
     ece:	b9 f3       	breq	.-18     	; 0xebe <__vector_24+0x78>
     ed0:	88 33       	cpi	r24, 0x38	; 56
     ed2:	f9 f6       	brne	.-66     	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:574
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
     ed4:	80 93 7c 02 	sts	0x027C, r24	; 0x80027c <twi_error>
twi_reply():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     ed8:	85 ec       	ldi	r24, 0xC5	; 197
     eda:	bc c0       	rjmp	.+376    	; 0x1054 <__vector_24+0x20e>
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     edc:	80 35       	cpi	r24, 0x50	; 80
     ede:	09 f4       	brne	.+2      	; 0xee2 <__vector_24+0x9c>
     ee0:	89 c0       	rjmp	.+274    	; 0xff4 <__vector_24+0x1ae>
     ee2:	88 35       	cpi	r24, 0x58	; 88
     ee4:	09 f4       	brne	.+2      	; 0xee8 <__vector_24+0xa2>
     ee6:	9e c0       	rjmp	.+316    	; 0x1024 <__vector_24+0x1de>
     ee8:	88 34       	cpi	r24, 0x48	; 72
     eea:	99 f6       	brne	.-90     	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:693
    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
      twi_stop();
     eec:	0e 94 fe 03 	call	0x7fc	; 0x7fc <twi_stop>
     ef0:	d0 cf       	rjmp	.-96     	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     ef2:	88 39       	cpi	r24, 0x98	; 152
     ef4:	09 f4       	brne	.+2      	; 0xef8 <__vector_24+0xb2>
     ef6:	94 c0       	rjmp	.+296    	; 0x1020 <__vector_24+0x1da>
     ef8:	38 f5       	brcc	.+78     	; 0xf48 <__vector_24+0x102>
     efa:	88 37       	cpi	r24, 0x78	; 120
     efc:	29 f0       	breq	.+10     	; 0xf08 <__vector_24+0xc2>
     efe:	50 f4       	brcc	.+20     	; 0xf14 <__vector_24+0xce>
     f00:	88 36       	cpi	r24, 0x68	; 104
     f02:	11 f0       	breq	.+4      	; 0xf08 <__vector_24+0xc2>
     f04:	80 37       	cpi	r24, 0x70	; 112
     f06:	29 f6       	brne	.-118    	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:616
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
     f08:	83 e0       	ldi	r24, 0x03	; 3
     f0a:	80 93 7e 02 	sts	0x027E, r24	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:618
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
     f0e:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <twi_rxBufferIndex>
     f12:	57 c0       	rjmp	.+174    	; 0xfc2 <__vector_24+0x17c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     f14:	88 38       	cpi	r24, 0x88	; 136
     f16:	09 f4       	brne	.+2      	; 0xf1a <__vector_24+0xd4>
     f18:	83 c0       	rjmp	.+262    	; 0x1020 <__vector_24+0x1da>
     f1a:	80 39       	cpi	r24, 0x90	; 144
     f1c:	19 f0       	breq	.+6      	; 0xf24 <__vector_24+0xde>
     f1e:	80 38       	cpi	r24, 0x80	; 128
     f20:	09 f0       	breq	.+2      	; 0xf24 <__vector_24+0xde>
     f22:	b7 cf       	rjmp	.-146    	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:624
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
     f24:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <twi_rxBufferIndex>
     f28:	80 32       	cpi	r24, 0x20	; 32
     f2a:	08 f0       	brcs	.+2      	; 0xf2e <__vector_24+0xe8>
     f2c:	79 c0       	rjmp	.+242    	; 0x1020 <__vector_24+0x1da>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:626
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
     f2e:	e0 91 24 02 	lds	r30, 0x0224	; 0x800224 <twi_rxBufferIndex>
     f32:	81 e0       	ldi	r24, 0x01	; 1
     f34:	8e 0f       	add	r24, r30
     f36:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <twi_rxBufferIndex>
     f3a:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
     f3e:	f0 e0       	ldi	r31, 0x00	; 0
     f40:	ec 5f       	subi	r30, 0xFC	; 252
     f42:	fd 4f       	sbci	r31, 0xFD	; 253
     f44:	80 83       	st	Z, r24
     f46:	3d c0       	rjmp	.+122    	; 0xfc2 <__vector_24+0x17c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     f48:	80 3b       	cpi	r24, 0xB0	; 176
     f4a:	39 f0       	breq	.+14     	; 0xf5a <__vector_24+0x114>
     f4c:	e0 f4       	brcc	.+56     	; 0xf86 <__vector_24+0x140>
     f4e:	80 3a       	cpi	r24, 0xA0	; 160
     f50:	09 f4       	brne	.+2      	; 0xf54 <__vector_24+0x10e>
     f52:	85 c0       	rjmp	.+266    	; 0x105e <__vector_24+0x218>
     f54:	88 3a       	cpi	r24, 0xA8	; 168
     f56:	09 f0       	breq	.+2      	; 0xf5a <__vector_24+0x114>
     f58:	9c cf       	rjmp	.-200    	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:655

    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
     f5a:	84 e0       	ldi	r24, 0x04	; 4
     f5c:	80 93 7e 02 	sts	0x027E, r24	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:657
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
     f60:	10 92 03 02 	sts	0x0203, r1	; 0x800203 <twi_txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:659
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
     f64:	10 92 02 02 	sts	0x0202, r1	; 0x800202 <twi_txBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:662
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
     f68:	e0 91 27 02 	lds	r30, 0x0227	; 0x800227 <twi_onSlaveTransmit>
     f6c:	f0 91 28 02 	lds	r31, 0x0228	; 0x800228 <twi_onSlaveTransmit+0x1>
     f70:	09 95       	icall
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:664
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
     f72:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <twi_txBufferLength>
     f76:	81 11       	cpse	r24, r1
     f78:	0f c0       	rjmp	.+30     	; 0xf98 <__vector_24+0x152>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:665
        twi_txBufferLength = 1;
     f7a:	81 e0       	ldi	r24, 0x01	; 1
     f7c:	80 93 02 02 	sts	0x0202, r24	; 0x800202 <twi_txBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:666
        twi_txBuffer[0] = 0x00;
     f80:	10 92 e2 01 	sts	0x01E2, r1	; 0x8001e2 <twi_txBuffer>
     f84:	09 c0       	rjmp	.+18     	; 0xf98 <__vector_24+0x152>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:535
  return(flag);
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
     f86:	80 3c       	cpi	r24, 0xC0	; 192
     f88:	09 f4       	brne	.+2      	; 0xf8c <__vector_24+0x146>
     f8a:	a6 cf       	rjmp	.-180    	; 0xed8 <__vector_24+0x92>
     f8c:	88 3c       	cpi	r24, 0xC8	; 200
     f8e:	09 f4       	brne	.+2      	; 0xf92 <__vector_24+0x14c>
     f90:	a3 cf       	rjmp	.-186    	; 0xed8 <__vector_24+0x92>
     f92:	88 3b       	cpi	r24, 0xB8	; 184
     f94:	09 f0       	breq	.+2      	; 0xf98 <__vector_24+0x152>
     f96:	7d cf       	rjmp	.-262    	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:672
      }
      // transmit first byte from buffer, fall
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
     f98:	e0 91 03 02 	lds	r30, 0x0203	; 0x800203 <twi_txBufferIndex>
     f9c:	81 e0       	ldi	r24, 0x01	; 1
     f9e:	8e 0f       	add	r24, r30
     fa0:	80 93 03 02 	sts	0x0203, r24	; 0x800203 <twi_txBufferIndex>
     fa4:	f0 e0       	ldi	r31, 0x00	; 0
     fa6:	ee 51       	subi	r30, 0x1E	; 30
     fa8:	fe 4f       	sbci	r31, 0xFE	; 254
     faa:	80 81       	ld	r24, Z
     fac:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:674
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
     fb0:	90 91 03 02 	lds	r25, 0x0203	; 0x800203 <twi_txBufferIndex>
     fb4:	80 91 02 02 	lds	r24, 0x0202	; 0x800202 <twi_txBufferLength>
     fb8:	31 c0       	rjmp	.+98     	; 0x101c <__vector_24+0x1d6>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:540
  switch(TW_STATUS){
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
     fba:	80 91 77 02 	lds	r24, 0x0277	; 0x800277 <twi_slarw>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:550
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     fbe:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
twi_reply():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
     fc2:	85 ec       	ldi	r24, 0xC5	; 197
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:423
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
     fc4:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
     fc8:	64 cf       	rjmp	.-312    	; 0xe92 <__vector_24+0x4c>
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:548

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop
      if(twi_masterBufferIndex < twi_masterBufferLength){
     fca:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <twi_masterBufferIndex>
     fce:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <twi_masterBufferLength>
     fd2:	98 17       	cp	r25, r24
     fd4:	b8 f5       	brcc	.+110    	; 0x1044 <__vector_24+0x1fe>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:550
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
     fd6:	80 91 7a 02 	lds	r24, 0x027A	; 0x80027a <twi_masterBuffer>
     fda:	90 91 7b 02 	lds	r25, 0x027B	; 0x80027b <twi_masterBuffer+0x1>
     fde:	e0 91 79 02 	lds	r30, 0x0279	; 0x800279 <twi_masterBufferIndex>
     fe2:	21 e0       	ldi	r18, 0x01	; 1
     fe4:	2e 0f       	add	r18, r30
     fe6:	20 93 79 02 	sts	0x0279, r18	; 0x800279 <twi_masterBufferIndex>
     fea:	e8 0f       	add	r30, r24
     fec:	f9 2f       	mov	r31, r25
     fee:	f1 1d       	adc	r31, r1
     ff0:	80 81       	ld	r24, Z
     ff2:	e5 cf       	rjmp	.-54     	; 0xfbe <__vector_24+0x178>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:581
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
     ff4:	20 91 7a 02 	lds	r18, 0x027A	; 0x80027a <twi_masterBuffer>
     ff8:	30 91 7b 02 	lds	r19, 0x027B	; 0x80027b <twi_masterBuffer+0x1>
     ffc:	e0 91 79 02 	lds	r30, 0x0279	; 0x800279 <twi_masterBufferIndex>
    1000:	81 e0       	ldi	r24, 0x01	; 1
    1002:	8e 0f       	add	r24, r30
    1004:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <twi_masterBufferIndex>
    1008:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
    100c:	e2 0f       	add	r30, r18
    100e:	f3 2f       	mov	r31, r19
    1010:	f1 1d       	adc	r31, r1
    1012:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:585
      /* fall through */
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
    1014:	90 91 79 02 	lds	r25, 0x0279	; 0x800279 <twi_masterBufferIndex>
    1018:	80 91 78 02 	lds	r24, 0x0278	; 0x800278 <twi_masterBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:674
      /* fall through */
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
    101c:	98 17       	cp	r25, r24
    101e:	88 f2       	brcs	.-94     	; 0xfc2 <__vector_24+0x17c>
twi_reply():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:423
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    1020:	85 e8       	ldi	r24, 0x85	; 133
    1022:	d0 cf       	rjmp	.-96     	; 0xfc4 <__vector_24+0x17e>
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:593
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
    1024:	20 91 7a 02 	lds	r18, 0x027A	; 0x80027a <twi_masterBuffer>
    1028:	30 91 7b 02 	lds	r19, 0x027B	; 0x80027b <twi_masterBuffer+0x1>
    102c:	e0 91 79 02 	lds	r30, 0x0279	; 0x800279 <twi_masterBufferIndex>
    1030:	81 e0       	ldi	r24, 0x01	; 1
    1032:	8e 0f       	add	r24, r30
    1034:	80 93 79 02 	sts	0x0279, r24	; 0x800279 <twi_masterBufferIndex>
    1038:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__DATA_REGION_ORIGIN__+0x5b>
    103c:	e2 0f       	add	r30, r18
    103e:	f3 2f       	mov	r31, r19
    1040:	f1 1d       	adc	r31, r1
    1042:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:594
  if (twi_sendStop)
    1044:	80 91 7d 02 	lds	r24, 0x027D	; 0x80027d <twi_sendStop>
    1048:	81 11       	cpse	r24, r1
    104a:	50 cf       	rjmp	.-352    	; 0xeec <__vector_24+0xa6>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:597
          twi_stop();
  else {
    twi_inRepStart = true;  // we're going to send the START
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	80 93 76 02 	sts	0x0276, r24	; 0x800276 <twi_inRepStart>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:601
    // don't enable the interrupt. We'll generate the start, but we
    // avoid handling the interrupt until we're in the next transaction,
    // at the point where we would normally issue the start.
    TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
    1052:	84 ea       	ldi	r24, 0xA4	; 164
twi_reply():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:421
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    1054:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:685
    case TW_ST_DATA_NACK: // received nack, we are done
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
    1058:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <twi_state>
    105c:	1a cf       	rjmp	.-460    	; 0xe92 <__vector_24+0x4c>
twi_releaseBus():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:474
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
    105e:	85 ec       	ldi	r24, 0xC5	; 197
    1060:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:477

  // update twi state
  twi_state = TWI_READY;
    1064:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <twi_state>
__vector_24():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:637
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_SIZE){
    1068:	80 91 24 02 	lds	r24, 0x0224	; 0x800224 <twi_rxBufferIndex>
    106c:	80 32       	cpi	r24, 0x20	; 32
    106e:	30 f4       	brcc	.+12     	; 0x107c <__vector_24+0x236>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:638
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
    1070:	e0 91 24 02 	lds	r30, 0x0224	; 0x800224 <twi_rxBufferIndex>
    1074:	f0 e0       	ldi	r31, 0x00	; 0
    1076:	ec 5f       	subi	r30, 0xFC	; 252
    1078:	fd 4f       	sbci	r31, 0xFD	; 253
    107a:	10 82       	st	Z, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:641
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
    107c:	60 91 24 02 	lds	r22, 0x0224	; 0x800224 <twi_rxBufferIndex>
    1080:	70 e0       	ldi	r23, 0x00	; 0
    1082:	e0 91 25 02 	lds	r30, 0x0225	; 0x800225 <twi_onSlaveReceive>
    1086:	f0 91 26 02 	lds	r31, 0x0226	; 0x800226 <twi_onSlaveReceive+0x1>
    108a:	84 e0       	ldi	r24, 0x04	; 4
    108c:	92 e0       	ldi	r25, 0x02	; 2
    108e:	09 95       	icall
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:643
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
    1090:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <twi_rxBufferIndex>
    1094:	fe ce       	rjmp	.-516    	; 0xe92 <__vector_24+0x4c>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:692

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
    1096:	10 92 7c 02 	sts	0x027C, r1	; 0x80027c <twi_error>
    109a:	28 cf       	rjmp	.-432    	; 0xeec <__vector_24+0xa6>

0000109c <global constructors keyed to 65535_0_BME680andIR.ino.cpp.o.2560>:
_GLOBAL__I_65535_0_BME680andIR.ino.cpp.o.2560():
    109c:	e3 ea       	ldi	r30, 0xA3	; 163
    109e:	f2 e0       	ldi	r31, 0x02	; 2
    10a0:	13 82       	std	Z+3, r1	; 0x03
    10a2:	12 82       	std	Z+2, r1	; 0x02
    10a4:	88 ee       	ldi	r24, 0xE8	; 232
    10a6:	93 e0       	ldi	r25, 0x03	; 3
    10a8:	a0 e0       	ldi	r26, 0x00	; 0
    10aa:	b0 e0       	ldi	r27, 0x00	; 0
    10ac:	84 83       	std	Z+4, r24	; 0x04
    10ae:	95 83       	std	Z+5, r25	; 0x05
    10b0:	a6 83       	std	Z+6, r26	; 0x06
    10b2:	b7 83       	std	Z+7, r27	; 0x07
    10b4:	29 e8       	ldi	r18, 0x89	; 137
    10b6:	31 e0       	ldi	r19, 0x01	; 1
    10b8:	31 83       	std	Z+1, r19	; 0x01
    10ba:	20 83       	st	Z, r18
    10bc:	25 ec       	ldi	r18, 0xC5	; 197
    10be:	30 e0       	ldi	r19, 0x00	; 0
    10c0:	35 87       	std	Z+13, r19	; 0x0d
    10c2:	24 87       	std	Z+12, r18	; 0x0c
    10c4:	24 ec       	ldi	r18, 0xC4	; 196
    10c6:	30 e0       	ldi	r19, 0x00	; 0
    10c8:	37 87       	std	Z+15, r19	; 0x0f
    10ca:	26 87       	std	Z+14, r18	; 0x0e
    10cc:	20 ec       	ldi	r18, 0xC0	; 192
    10ce:	30 e0       	ldi	r19, 0x00	; 0
    10d0:	31 8b       	std	Z+17, r19	; 0x11
    10d2:	20 8b       	std	Z+16, r18	; 0x10
    10d4:	21 ec       	ldi	r18, 0xC1	; 193
    10d6:	30 e0       	ldi	r19, 0x00	; 0
    10d8:	33 8b       	std	Z+19, r19	; 0x13
    10da:	22 8b       	std	Z+18, r18	; 0x12
    10dc:	22 ec       	ldi	r18, 0xC2	; 194
    10de:	30 e0       	ldi	r19, 0x00	; 0
    10e0:	35 8b       	std	Z+21, r19	; 0x15
    10e2:	24 8b       	std	Z+20, r18	; 0x14
    10e4:	26 ec       	ldi	r18, 0xC6	; 198
    10e6:	30 e0       	ldi	r19, 0x00	; 0
    10e8:	37 8b       	std	Z+23, r19	; 0x17
    10ea:	26 8b       	std	Z+22, r18	; 0x16
    10ec:	11 8e       	std	Z+25, r1	; 0x19
    10ee:	12 8e       	std	Z+26, r1	; 0x1a
    10f0:	13 8e       	std	Z+27, r1	; 0x1b
    10f2:	14 8e       	std	Z+28, r1	; 0x1c
    10f4:	e0 e4       	ldi	r30, 0x40	; 64
    10f6:	f3 e0       	ldi	r31, 0x03	; 3
    10f8:	13 82       	std	Z+3, r1	; 0x03
    10fa:	12 82       	std	Z+2, r1	; 0x02
    10fc:	84 83       	std	Z+4, r24	; 0x04
    10fe:	95 83       	std	Z+5, r25	; 0x05
    1100:	a6 83       	std	Z+6, r26	; 0x06
    1102:	b7 83       	std	Z+7, r27	; 0x07
    1104:	8b e9       	ldi	r24, 0x9B	; 155
    1106:	91 e0       	ldi	r25, 0x01	; 1
    1108:	91 83       	std	Z+1, r25	; 0x01
    110a:	80 83       	st	Z, r24
    110c:	e3 ea       	ldi	r30, 0xA3	; 163
    110e:	f3 e0       	ldi	r31, 0x03	; 3
    1110:	17 8a       	std	Z+23, r1	; 0x17
    1112:	11 8e       	std	Z+25, r1	; 0x19
    1114:	10 8e       	std	Z+24, r1	; 0x18
    1116:	ec e4       	ldi	r30, 0x4C	; 76
    1118:	f3 e0       	ldi	r31, 0x03	; 3
    111a:	17 8a       	std	Z+23, r1	; 0x17
    111c:	11 8e       	std	Z+25, r1	; 0x19
    111e:	10 8e       	std	Z+24, r1	; 0x18
    1120:	08 95       	ret

00001122 <main>:
main():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/main.cpp:34

//void setupUSB() __attribute__((weak));
//void setupUSB() { }

int main(void)
{
    1122:	cf 93       	push	r28
    1124:	df 93       	push	r29
    1126:	cd b7       	in	r28, 0x3d	; 61
    1128:	de b7       	in	r29, 0x3e	; 62
    112a:	c0 5c       	subi	r28, 0xC0	; 192
    112c:	d1 09       	sbc	r29, r1
    112e:	0f b6       	in	r0, 0x3f	; 63
    1130:	f8 94       	cli
    1132:	de bf       	out	0x3e, r29	; 62
    1134:	0f be       	out	0x3f, r0	; 63
    1136:	cd bf       	out	0x3d, r28	; 61
init():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:945

void init()
{
  // this needs to be called before setup() or some functions won't
  // work there
  sei();
    1138:	78 94       	sei
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:957

  // On the ATmega168, timer 0 is also used for fast hardware pwm
  // (using phase-correct PWM would mean that timer 0 overflowed half as often
  // resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
  TCCR0A |= _BV(WGM01) | _BV(WGM00);
    113a:	84 b5       	in	r24, 0x24	; 36
    113c:	83 60       	ori	r24, 0x03	; 3
    113e:	84 bd       	out	0x24, r24	; 36
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:972
  #if defined(WGM00) && defined(WGM01) // The ATmega8 doesn't have WGM00 and WGM01
    TCCR0 |= _BV(WGM01) | _BV(WGM00);
  #endif
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
  // This combination is for the standard 168/328/640/1280/1281/2560/2561
  TCCR0B |= _BV(CS01) | _BV(CS00);
    1140:	85 b5       	in	r24, 0x25	; 37
    1142:	83 60       	ori	r24, 0x03	; 3
    1144:	85 bd       	out	0x25, r24	; 37
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:984

// Enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
  TIMSK |= _BV(TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
  TIMSK0 |= _BV(TOIE0);
    1146:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    114a:	81 60       	ori	r24, 0x01	; 1
    114c:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:995
// this is better for motors as it ensures an even waveform
// note, however, that fast pwm mode can achieve a frequency of up
// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
  TCCR1B = _BV(CS11); // Set timer 1 prescale factor to 64
    1150:	92 e0       	ldi	r25, 0x02	; 2
    1152:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:997
#if F_CPU >= 8000000L
  TCCR1B |= _BV(CS10);
    1156:	80 91 81 00 	lds	r24, 0x0081	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    115a:	81 60       	ori	r24, 0x01	; 1
    115c:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1006
#if F_CPU >= 8000000L
  TCCR1 |= _BV(CS10);
#endif
#endif
#if defined(TCCR1A) && defined(WGM10)
  TCCR1A |= _BV(WGM10); // Put timer 1 in 8-bit phase correct pwm mode
    1160:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    1164:	81 60       	ori	r24, 0x01	; 1
    1166:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1013

// Set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
  TCCR2 |= _BV(CS22);
#elif defined(TCCR2B) && defined(CS22)
  TCCR2B |= _BV(CS22);
    116a:	80 91 b1 00 	lds	r24, 0x00B1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    116e:	84 60       	ori	r24, 0x04	; 4
    1170:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1022

// Configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
  TCCR2 |= _BV(WGM20);
#elif defined(TCCR2A) && defined(WGM20)
  TCCR2A |= _BV(WGM20);
    1174:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    1178:	81 60       	ori	r24, 0x01	; 1
    117a:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1052
#if defined(ADCSRA)
  // set a2d prescaler so we are inside the desired 50-200 KHz range.
  #if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADPS0) | _BV(ADEN);
  #elif F_CPU >= 8000000 // 8 MHz / 64 = 125 KHz
    ADCSRA = _BV(ADPS2) | _BV(ADPS1) | _BV(ADEN);
    117e:	86 e8       	ldi	r24, 0x86	; 134
    1180:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/wiring.c:1070
  // here so they can be used as normal digital i/o; they will be
  // reconnected in Serial.begin()
#if defined(UCSRB)
  UCSRB = 0;
#elif defined(UCSR0B)
  UCSR0B = 0;
    1184:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
begin():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:121

void HardwareSerial::begin(unsigned long baud, byte config)
{
  // Try u2x mode first
  uint16_t baud_setting = (F_CPU / 4 / baud - 1) / 2;
  *_ucsra = 1 << U2X0;
    1188:	e0 91 b3 02 	lds	r30, 0x02B3	; 0x8002b3 <Serial+0x10>
    118c:	f0 91 b4 02 	lds	r31, 0x02B4	; 0x8002b4 <Serial+0x11>
    1190:	90 83       	st	Z, r25
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:135
    *_ucsra = 0;
    baud_setting = (F_CPU / 8 / baud - 1) / 2;
  }

  // assign the baud_setting, a.k.a. ubrr (USART Baud Rate Register)
  *_ubrrh = baud_setting >> 8;
    1192:	e0 91 af 02 	lds	r30, 0x02AF	; 0x8002af <Serial+0xc>
    1196:	f0 91 b0 02 	lds	r31, 0x02B0	; 0x8002b0 <Serial+0xd>
    119a:	10 82       	st	Z, r1
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:136
  *_ubrrl = baud_setting;
    119c:	e0 91 b1 02 	lds	r30, 0x02B1	; 0x8002b1 <Serial+0xe>
    11a0:	f0 91 b2 02 	lds	r31, 0x02B2	; 0x8002b2 <Serial+0xf>
    11a4:	88 e0       	ldi	r24, 0x08	; 8
    11a6:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:138

  _written = false;
    11a8:	10 92 bb 02 	sts	0x02BB, r1	; 0x8002bb <Serial+0x18>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:146
#if defined(__AVR_ATmega8__) || defined(__AVR_ATmega8515__) || defined(__AVR_ATmega162__) \
|| defined(__AVR_ATmega8535__) || defined(__AVR_ATmega16__)|| defined(__AVR_ATmega32__)   \
|| defined(__AVR_ATmega162__)
  config |= 0x80; // select UCSRC register (shared with UBRRH)
#endif
  *_ucsrc = config;
    11ac:	e0 91 b7 02 	lds	r30, 0x02B7	; 0x8002b7 <Serial+0x14>
    11b0:	f0 91 b8 02 	lds	r31, 0x02B8	; 0x8002b8 <Serial+0x15>
    11b4:	86 e0       	ldi	r24, 0x06	; 6
    11b6:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:148
  
  *_ucsrb |= _BV(RXEN0) | _BV(TXEN0) | _BV(RXCIE0);
    11b8:	e0 91 b5 02 	lds	r30, 0x02B5	; 0x8002b5 <Serial+0x12>
    11bc:	f0 91 b6 02 	lds	r31, 0x02B6	; 0x8002b6 <Serial+0x13>
    11c0:	80 81       	ld	r24, Z
    11c2:	88 69       	ori	r24, 0x98	; 152
    11c4:	80 83       	st	Z, r24
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:149
  *_ucsrb &= ~_BV(UDRIE0);
    11c6:	e0 91 b5 02 	lds	r30, 0x02B5	; 0x8002b5 <Serial+0x12>
    11ca:	f0 91 b6 02 	lds	r31, 0x02B6	; 0x8002b6 <Serial+0x13>
    11ce:	80 81       	ld	r24, Z
    11d0:	8f 7d       	andi	r24, 0xDF	; 223
    11d2:	80 83       	st	Z, r24
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:29
  Serial.begin(SERIAL_SPEED);  // Start serial port at Baud rate

#ifdef __AVR_ATmega32U4__  // If this is a 32U4 processor, then wait 3 seconds to init USB port
  delay(3000);
#endif
  Serial.print(F("Starting I2CDemo example program for BME680\n"));
    11d4:	8c ef       	ldi	r24, 0xFC	; 252
    11d6:	91 e0       	ldi	r25, 0x01	; 1
    11d8:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:30
  Serial.print(F("- Initializing BME680 sensor\n"));
    11dc:	8e ed       	ldi	r24, 0xDE	; 222
    11de:	91 e0       	ldi	r25, 0x01	; 1
    11e0:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
twi_init():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:85
 */
void twi_init(void)
{
  // initialize state
  twi_state = TWI_READY;
  twi_sendStop = true; // default value
    11e4:	bb 24       	eor	r11, r11
    11e6:	b3 94       	inc	r11
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:95
  digitalWrite(SCL, 1);

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
  cbi(TWSR, TWPS1);
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
    11e8:	40 e2       	ldi	r20, 0x20	; 32
    11ea:	a4 2e       	mov	r10, r20
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:103
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
    11ec:	55 e4       	ldi	r21, 0x45	; 69
    11ee:	95 2e       	mov	r9, r21
twi_attachSlaveTxEvent():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:408
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
  twi_onSlaveTransmit = function;
    11f0:	04 ed       	ldi	r16, 0xD4	; 212
    11f2:	12 e0       	ldi	r17, 0x02	; 2
twi_attachSlaveRxEvent():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:397
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
  twi_onSlaveReceive = function;
    11f4:	65 ed       	ldi	r22, 0xD5	; 213
    11f6:	e6 2e       	mov	r14, r22
    11f8:	62 e0       	ldi	r22, 0x02	; 2
    11fa:	f6 2e       	mov	r15, r22
begin():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:530
  @param[in] i2cAddress I2C Address, use 0 to self-determine
  return "true" if successful otherwise false
  */
  Wire.begin();             // Start I2C as master
  Wire.setClock(i2cSpeed);  // and set bus speed
  _I2CSpeed = i2cSpeed;
    11fc:	70 ea       	ldi	r23, 0xA0	; 160
    11fe:	c7 2e       	mov	r12, r23
    1200:	76 e8       	ldi	r23, 0x86	; 134
    1202:	d7 2e       	mov	r13, r23
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:531
  for (_I2CAddress = BME680_I2C_MIN_ADDRESS; _I2CAddress <= BME680_I2C_MAX_ADDRESS;
    1204:	e6 e7       	ldi	r30, 0x76	; 118
    1206:	8e 2e       	mov	r8, r30
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:61

// Public Methods //////////////////////////////////////////////////////////////

void TwoWire::begin(void)
{
  rxBufferIndex = 0;
    1208:	10 92 55 02 	sts	0x0255, r1	; 0x800255 <TwoWire::rxBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:62
  rxBufferLength = 0;
    120c:	10 92 54 02 	sts	0x0254, r1	; 0x800254 <TwoWire::rxBufferLength>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:64

  txBufferIndex = 0;
    1210:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:65
  txBufferLength = 0;
    1214:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
twi_init():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:84
 * Output   none
 */
void twi_init(void)
{
  // initialize state
  twi_state = TWI_READY;
    1218:	10 92 7e 02 	sts	0x027E, r1	; 0x80027e <twi_state>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:85
  twi_sendStop = true; // default value
    121c:	b0 92 7d 02 	sts	0x027D, r11	; 0x80027d <twi_sendStop>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:86
  twi_inRepStart = false;
    1220:	10 92 76 02 	sts	0x0276, r1	; 0x800276 <twi_inRepStart>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:89

  // activate internal pullups for twi.
  digitalWrite(SDA, 1);
    1224:	61 e0       	ldi	r22, 0x01	; 1
    1226:	82 e1       	ldi	r24, 0x12	; 18
    1228:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:90
  digitalWrite(SCL, 1);
    122c:	61 e0       	ldi	r22, 0x01	; 1
    122e:	83 e1       	ldi	r24, 0x13	; 19
    1230:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:93

  // initialize twi prescaler and bit rate
  cbi(TWSR, TWPS0);
    1234:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
    1238:	8e 7f       	andi	r24, 0xFE	; 254
    123a:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:94
  cbi(TWSR, TWPS1);
    123e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
    1242:	8d 7f       	andi	r24, 0xFD	; 253
    1244:	80 93 b9 00 	sts	0x00B9, r24	; 0x8000b9 <__DATA_REGION_ORIGIN__+0x59>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:95
  TWBR = ((F_CPU / TWI_FREQ) - 16) / 2;
    1248:	a0 92 b8 00 	sts	0x00B8, r10	; 0x8000b8 <__DATA_REGION_ORIGIN__+0x58>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:103
  SCL Frequency = CPU Clock Frequency / (16 + (2 * TWBR))
  note: TWBR should be 10 or higher for master mode
  It is 72 for a 16mhz Wiring board with 100kHz TWI */

  // enable twi module, acks, and twi interrupt
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA);
    124c:	90 92 bc 00 	sts	0x00BC, r9	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
twi_attachSlaveTxEvent():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:408
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveTxEvent( void (*function)(void) )
{
  twi_onSlaveTransmit = function;
    1250:	10 93 28 02 	sts	0x0228, r17	; 0x800228 <twi_onSlaveTransmit+0x1>
    1254:	00 93 27 02 	sts	0x0227, r16	; 0x800227 <twi_onSlaveTransmit>
twi_attachSlaveRxEvent():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:397
 * Input    function: callback function to use
 * Output   none
 */
void twi_attachSlaveRxEvent( void (*function)(uint8_t*, int) )
{
  twi_onSlaveReceive = function;
    1258:	f0 92 26 02 	sts	0x0226, r15	; 0x800226 <twi_onSlaveReceive+0x1>
    125c:	e0 92 25 02 	sts	0x0225, r14	; 0x800225 <twi_onSlaveReceive>
twi_setFrequency():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src\utility/twi.c:142
 * Input    Clock frequency
 * Output   none
 */
void twi_setFrequency(uint32_t frequency)
{
  TWBR = ((F_CPU / frequency) - 16) / 2;
    1260:	a0 92 b8 00 	sts	0x00B8, r10	; 0x8000b8 <__DATA_REGION_ORIGIN__+0x58>
begin():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:530
  @param[in] i2cAddress I2C Address, use 0 to self-determine
  return "true" if successful otherwise false
  */
  Wire.begin();             // Start I2C as master
  Wire.setClock(i2cSpeed);  // and set bus speed
  _I2CSpeed = i2cSpeed;
    1264:	d0 92 bc 03 	sts	0x03BC, r13	; 0x8003bc <BME680+0x19>
    1268:	c0 92 bb 03 	sts	0x03BB, r12	; 0x8003bb <BME680+0x18>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:531
  for (_I2CAddress = BME680_I2C_MIN_ADDRESS; _I2CAddress <= BME680_I2C_MAX_ADDRESS;
    126c:	80 92 ba 03 	sts	0x03BA, r8	; 0x8003ba <BME680+0x17>
    1270:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    1274:	88 37       	cpi	r24, 0x78	; 120
    1276:	08 f0       	brcs	.+2      	; 0x127a <main+0x158>
    1278:	bd c3       	rjmp	.+1914   	; 0x19f4 <main+0x8d2>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:533
       _I2CAddress++) {                                  // Loop through all I2C addresses
    if (i2cAddress == 0 || _I2CAddress == i2cAddress) {  // Only check if relevant
    127a:	87 37       	cpi	r24, 0x77	; 119
    127c:	09 f0       	breq	.+2      	; 0x1280 <main+0x15e>
    127e:	b4 c3       	rjmp	.+1896   	; 0x19e8 <main+0x8c6>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
    1280:	b0 92 7f 02 	sts	0x027F, r11	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
    1284:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    1288:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
    128c:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
begin():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:535
      Wire.beginTransmission(_I2CAddress);               // Check for BME680 here
      if (Wire.endTransmission() == 0) {                 // We have found a device that could be
    1290:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
    1294:	81 11       	cpse	r24, r1
    1296:	a8 c3       	rjmp	.+1872   	; 0x19e8 <main+0x8c6>
commonInitialization():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:590
  /*!
  @brief   Common BME680 initialization function
  @details Called from all of the overloaded "begin()" functions once the communications protocol
           has been selected return "true" if successful otherwise false
  */
  uint8_t SPI_Register = readByte(BME680_SPI_REGISTER);  // Read SPI reg. byte
    1298:	83 e7       	ldi	r24, 0x73	; 115
    129a:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
    129e:	c0 57       	subi	r28, 0x70	; 112
    12a0:	df 4f       	sbci	r29, 0xFF	; 255
    12a2:	88 83       	st	Y, r24
    12a4:	c0 59       	subi	r28, 0x90	; 144
    12a6:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:591
  if (_I2CAddress == 0 &&
    12a8:	90 91 ba 03 	lds	r25, 0x03BA	; 0x8003ba <BME680+0x17>
    12ac:	91 11       	cpse	r25, r1
    12ae:	0e c0       	rjmp	.+28     	; 0x12cc <main+0x1aa>
    12b0:	84 ff       	sbrs	r24, 4
    12b2:	0c c0       	rjmp	.+24     	; 0x12cc <main+0x1aa>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:593
      bitRead(SPI_Register, BME680_SPI_MEM_PAGE_POSITION)) {    // Wrong mode for ID
    bitWrite(SPI_Register, BME680_SPI_MEM_PAGE_POSITION, 0);    // Turn off Page bit to go to Page 0
    12b4:	8f 7e       	andi	r24, 0xEF	; 239
    12b6:	c0 57       	subi	r28, 0x70	; 112
    12b8:	df 4f       	sbci	r29, 0xFF	; 255
    12ba:	88 83       	st	Y, r24
    12bc:	c0 59       	subi	r28, 0x90	; 144
    12be:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:594
    putData(BME680_SPI_REGISTER, SPI_Register);                 // Write value to register
    12c0:	be 01       	movw	r22, r28
    12c2:	60 57       	subi	r22, 0x70	; 112
    12c4:	7f 4f       	sbci	r23, 0xFF	; 255
    12c6:	83 e7       	ldi	r24, 0x73	; 115
    12c8:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:596
  }                                                             // of if-then we are in SPI mode
  if (readByte(BME680_CHIPID_REGISTER) == BME680_CHIPID) {      // check for correct chip id
    12cc:	80 ed       	ldi	r24, 0xD0	; 208
    12ce:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
    12d2:	81 36       	cpi	r24, 0x61	; 97
    12d4:	09 f0       	breq	.+2      	; 0x12d8 <main+0x1b6>
    12d6:	94 c3       	rjmp	.+1832   	; 0x1a00 <main+0x8de>
getCalibration():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:644
  return    single byte read
  */
  /*************************************
  ** Temperature related coefficients **
  *************************************/
  uint8_t coeff_arr1[BME680_COEFF_SIZE1] = {0};      // Define temp array 1 and initialize with 0x
    12d8:	8e 01       	movw	r16, r28
    12da:	0f 5f       	subi	r16, 0xFF	; 255
    12dc:	1f 4f       	sbci	r17, 0xFF	; 255
    12de:	78 01       	movw	r14, r16
    12e0:	89 e1       	ldi	r24, 0x19	; 25
    12e2:	d8 01       	movw	r26, r16
    12e4:	1d 92       	st	X+, r1
    12e6:	8a 95       	dec	r24
    12e8:	e9 f7       	brne	.-6      	; 0x12e4 <main+0x1c2>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:645
  uint8_t coeff_arr2[BME680_COEFF_SIZE2] = {0};      // Define temp array 2 and initialize with 0s
    12ea:	00 5c       	subi	r16, 0xC0	; 192
    12ec:	1f 4f       	sbci	r17, 0xFF	; 255
    12ee:	80 e1       	ldi	r24, 0x10	; 16
    12f0:	f8 01       	movw	r30, r16
    12f2:	11 92       	st	Z+, r1
    12f4:	8a 95       	dec	r24
    12f6:	e9 f7       	brne	.-6      	; 0x12f2 <main+0x1d0>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:256
      @param[in] value Data Type "T" to read
      @return    Size of data read in bytes
    */
    uint8_t *      bytePtr    = (uint8_t *)&value;  // Pointer to structure beginning
    static uint8_t structSize = sizeof(T);          // Number of bytes in structure
    if (_I2CAddress)                                // Using I2C if address is non-zero
    12f8:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    12fc:	88 23       	and	r24, r24
    12fe:	61 f1       	breq	.+88     	; 0x1358 <main+0x236>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
    1300:	91 e0       	ldi	r25, 0x01	; 1
    1302:	90 93 7f 02 	sts	0x027F, r25	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
    1306:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    130a:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
    130e:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:259
    {                                               //
      Wire.beginTransmission(_I2CAddress);          // Address the I2C device
      Wire.write(addr);                             // Send register address to read
    1312:	69 e8       	ldi	r22, 0x89	; 137
    1314:	80 e4       	ldi	r24, 0x40	; 64
    1316:	93 e0       	ldi	r25, 0x03	; 3
    1318:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:260
      Wire.endTransmission();                       // Close transmission
    131c:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:261
      Wire.requestFrom(_I2CAddress, sizeof(T));     // Request 1 byte of data
    1320:	69 e1       	ldi	r22, 0x19	; 25
    1322:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    1326:	0e 94 63 05 	call	0xac6	; 0xac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:262
      structSize = Wire.available();                // Use the actual number of bytes
    132a:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
    132e:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
    1332:	89 1b       	sub	r24, r25
    1334:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <unsigned char& BME680_Class::getData<unsigned char [25]>(unsigned char, unsigned char (&) [25]) const::structSize>
    1338:	67 01       	movw	r12, r14
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:263
      for (uint8_t i = 0; i < structSize; i++)
    133a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <unsigned char& BME680_Class::getData<unsigned char [25]>(unsigned char, unsigned char (&) [25]) const::structSize>
    133e:	8c 2d       	mov	r24, r12
    1340:	8e 19       	sub	r24, r14
    1342:	89 17       	cp	r24, r25
    1344:	08 f0       	brcs	.+2      	; 0x1348 <main+0x226>
    1346:	79 c0       	rjmp	.+242    	; 0x143a <main+0x318>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:264
        *bytePtr++ = Wire.read();  // loop for each byte to be read
    1348:	80 e4       	ldi	r24, 0x40	; 64
    134a:	93 e0       	ldi	r25, 0x03	; 3
    134c:	0e 94 3f 04 	call	0x87e	; 0x87e <TwoWire::read()>
    1350:	d6 01       	movw	r26, r12
    1352:	8d 93       	st	X+, r24
    1354:	6d 01       	movw	r12, r26
    1356:	f1 cf       	rjmp	.-30     	; 0x133a <main+0x218>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:268
    }                              //
    else                           //
    {                              //
      if (_sck == 0)               // if sck is zero then hardware SPI
    1358:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    135c:	81 11       	cpse	r24, r1
    135e:	1b c0       	rjmp	.+54     	; 0x1396 <main+0x274>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:270
      {                            //
        SPI.beginTransaction(
    1360:	81 e5       	ldi	r24, 0x51	; 81
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	0e 94 9b 01 	call	0x336	; 0x336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:272
            SPISettings(SPI_HERZ, MSBFIRST, SPI_MODE0));  // Start the SPI transaction
        digitalWrite(_cs, LOW);                           // Tell BME680 to listen up
    1368:	60 e0       	ldi	r22, 0x00	; 0
    136a:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    136e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:273
        SPI.transfer(addr | 0x80);                        // bit 7 is high, so read a byte
    1372:	89 e8       	ldi	r24, 0x89	; 137
    1374:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    1378:	67 01       	movw	r12, r14
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:274
        for (uint8_t i = 0; i < structSize; i++)
    137a:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <unsigned char& BME680_Class::getData<unsigned char [25]>(unsigned char, unsigned char (&) [25]) const::structSize>
    137e:	8c 2d       	mov	r24, r12
    1380:	8e 19       	sub	r24, r14
    1382:	89 17       	cp	r24, r25
    1384:	08 f0       	brcs	.+2      	; 0x1388 <main+0x266>
    1386:	54 c0       	rjmp	.+168    	; 0x1430 <main+0x30e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:275
          *bytePtr++ = SPI.transfer(0);  // loop for each byte to be read
    1388:	80 e0       	ldi	r24, 0x00	; 0
    138a:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    138e:	f6 01       	movw	r30, r12
    1390:	81 93       	st	Z+, r24
    1392:	6f 01       	movw	r12, r30
    1394:	f2 cf       	rjmp	.-28     	; 0x137a <main+0x258>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:281
        digitalWrite(_cs, HIGH);         // Tell BME680 to stop listening
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
    1396:	60 e0       	ldi	r22, 0x00	; 0
    1398:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    139c:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    13a0:	27 e0       	ldi	r18, 0x07	; 7
    13a2:	c2 2e       	mov	r12, r18
    13a4:	d1 2c       	mov	r13, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
    13a6:	aa 24       	eor	r10, r10
    13a8:	a3 94       	inc	r10
    13aa:	b1 2c       	mov	r11, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:284
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
    13ac:	60 e0       	ldi	r22, 0x00	; 0
    13ae:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    13b2:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
    13b6:	b5 01       	movw	r22, r10
    13b8:	0c 2c       	mov	r0, r12
    13ba:	01 c0       	rjmp	.+2      	; 0x13be <main+0x29c>
    13bc:	66 0f       	add	r22, r22
    13be:	0a 94       	dec	r0
    13c0:	ea f7       	brpl	.-6      	; 0x13bc <main+0x29a>
    13c2:	69 78       	andi	r22, 0x89	; 137
    13c4:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
    13c8:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:286
          digitalWrite(_sck, HIGH);                         // reset the clock signal
    13cc:	61 e0       	ldi	r22, 0x01	; 1
    13ce:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    13d2:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    13d6:	b1 e0       	ldi	r27, 0x01	; 1
    13d8:	cb 1a       	sub	r12, r27
    13da:	d1 08       	sbc	r13, r1
    13dc:	38 f7       	brcc	.-50     	; 0x13ac <main+0x28a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:282
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
    13de:	57 01       	movw	r10, r14
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    13e0:	8a 2d       	mov	r24, r10
    13e2:	8e 19       	sub	r24, r14
    13e4:	08 2e       	mov	r0, r24
    13e6:	00 0c       	add	r0, r0
    13e8:	99 0b       	sbc	r25, r25
    13ea:	20 91 01 01 	lds	r18, 0x0101	; 0x800101 <unsigned char& BME680_Class::getData<unsigned char [25]>(unsigned char, unsigned char (&) [25]) const::structSize>
    13ee:	28 17       	cp	r18, r24
    13f0:	19 06       	cpc	r1, r25
    13f2:	f1 f0       	breq	.+60     	; 0x1430 <main+0x30e>
    13f4:	ec f0       	brlt	.+58     	; 0x1430 <main+0x30e>
main():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:290
        {                                                   //
          reply = 0;                                        // reset our return byte
    13f6:	d1 2c       	mov	r13, r1
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    13f8:	98 e0       	ldi	r25, 0x08	; 8
    13fa:	c9 2e       	mov	r12, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:293
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
          {                                                 //
            reply <<= 1;                                    // shift buffer one bit left
    13fc:	dd 0c       	add	r13, r13
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:294
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
    13fe:	60 e0       	ldi	r22, 0x00	; 0
    1400:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1404:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:295
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
    1408:	61 e0       	ldi	r22, 0x01	; 1
    140a:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    140e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:296
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
    1412:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <BME680+0x1d>
    1416:	0e 94 26 02 	call	0x44c	; 0x44c <digitalRead>
    141a:	89 2b       	or	r24, r25
    141c:	11 f0       	breq	.+4      	; 0x1422 <main+0x300>
    141e:	68 94       	set
    1420:	d0 f8       	bld	r13, 0
    1422:	ca 94       	dec	r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:291
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
    1424:	c1 10       	cpse	r12, r1
    1426:	ea cf       	rjmp	.-44     	; 0x13fc <main+0x2da>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:298
            reply <<= 1;                                    // shift buffer one bit left
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
          }                                                 // of for-next each bit
          *bytePtr++ = reply;                               // Add byte just read to return data
    1428:	d5 01       	movw	r26, r10
    142a:	dd 92       	st	X+, r13
    142c:	5d 01       	movw	r10, r26
    142e:	d8 cf       	rjmp	.-80     	; 0x13e0 <main+0x2be>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:300
        }                                                   // of for-next each byte to be read
        digitalWrite(_cs, HIGH);                            // Tell BME680 to stop listening
    1430:	61 e0       	ldi	r22, 0x01	; 1
    1432:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    1436:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:256
      @param[in] value Data Type "T" to read
      @return    Size of data read in bytes
    */
    uint8_t *      bytePtr    = (uint8_t *)&value;  // Pointer to structure beginning
    static uint8_t structSize = sizeof(T);          // Number of bytes in structure
    if (_I2CAddress)                                // Using I2C if address is non-zero
    143a:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    143e:	88 23       	and	r24, r24
    1440:	61 f1       	breq	.+88     	; 0x149a <main+0x378>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
    1442:	91 e0       	ldi	r25, 0x01	; 1
    1444:	90 93 7f 02 	sts	0x027F, r25	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
    1448:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    144c:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
    1450:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:259
    {                                               //
      Wire.beginTransmission(_I2CAddress);          // Address the I2C device
      Wire.write(addr);                             // Send register address to read
    1454:	61 ee       	ldi	r22, 0xE1	; 225
    1456:	80 e4       	ldi	r24, 0x40	; 64
    1458:	93 e0       	ldi	r25, 0x03	; 3
    145a:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:260
      Wire.endTransmission();                       // Close transmission
    145e:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:261
      Wire.requestFrom(_I2CAddress, sizeof(T));     // Request 1 byte of data
    1462:	60 e1       	ldi	r22, 0x10	; 16
    1464:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    1468:	0e 94 63 05 	call	0xac6	; 0xac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:262
      structSize = Wire.available();                // Use the actual number of bytes
    146c:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
    1470:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
    1474:	89 1b       	sub	r24, r25
    1476:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    147a:	68 01       	movw	r12, r16
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:263
      for (uint8_t i = 0; i < structSize; i++)
    147c:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
    1480:	8c 2d       	mov	r24, r12
    1482:	80 1b       	sub	r24, r16
    1484:	89 17       	cp	r24, r25
    1486:	08 f0       	brcs	.+2      	; 0x148a <main+0x368>
    1488:	79 c0       	rjmp	.+242    	; 0x157c <main+0x45a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:264
        *bytePtr++ = Wire.read();  // loop for each byte to be read
    148a:	80 e4       	ldi	r24, 0x40	; 64
    148c:	93 e0       	ldi	r25, 0x03	; 3
    148e:	0e 94 3f 04 	call	0x87e	; 0x87e <TwoWire::read()>
    1492:	d6 01       	movw	r26, r12
    1494:	8d 93       	st	X+, r24
    1496:	6d 01       	movw	r12, r26
    1498:	f1 cf       	rjmp	.-30     	; 0x147c <main+0x35a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:268
    }                              //
    else                           //
    {                              //
      if (_sck == 0)               // if sck is zero then hardware SPI
    149a:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    149e:	81 11       	cpse	r24, r1
    14a0:	1b c0       	rjmp	.+54     	; 0x14d8 <main+0x3b6>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:270
      {                            //
        SPI.beginTransaction(
    14a2:	81 e5       	ldi	r24, 0x51	; 81
    14a4:	90 e0       	ldi	r25, 0x00	; 0
    14a6:	0e 94 9b 01 	call	0x336	; 0x336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:272
            SPISettings(SPI_HERZ, MSBFIRST, SPI_MODE0));  // Start the SPI transaction
        digitalWrite(_cs, LOW);                           // Tell BME680 to listen up
    14aa:	60 e0       	ldi	r22, 0x00	; 0
    14ac:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    14b0:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:273
        SPI.transfer(addr | 0x80);                        // bit 7 is high, so read a byte
    14b4:	81 ee       	ldi	r24, 0xE1	; 225
    14b6:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    14ba:	68 01       	movw	r12, r16
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:274
        for (uint8_t i = 0; i < structSize; i++)
    14bc:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
    14c0:	8c 2d       	mov	r24, r12
    14c2:	80 1b       	sub	r24, r16
    14c4:	89 17       	cp	r24, r25
    14c6:	08 f0       	brcs	.+2      	; 0x14ca <main+0x3a8>
    14c8:	54 c0       	rjmp	.+168    	; 0x1572 <main+0x450>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:275
          *bytePtr++ = SPI.transfer(0);  // loop for each byte to be read
    14ca:	80 e0       	ldi	r24, 0x00	; 0
    14cc:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    14d0:	f6 01       	movw	r30, r12
    14d2:	81 93       	st	Z+, r24
    14d4:	6f 01       	movw	r12, r30
    14d6:	f2 cf       	rjmp	.-28     	; 0x14bc <main+0x39a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:281
        digitalWrite(_cs, HIGH);         // Tell BME680 to stop listening
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
    14d8:	60 e0       	ldi	r22, 0x00	; 0
    14da:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    14de:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    14e2:	b7 e0       	ldi	r27, 0x07	; 7
    14e4:	cb 2e       	mov	r12, r27
    14e6:	d1 2c       	mov	r13, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
    14e8:	aa 24       	eor	r10, r10
    14ea:	a3 94       	inc	r10
    14ec:	b1 2c       	mov	r11, r1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:284
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
    14ee:	60 e0       	ldi	r22, 0x00	; 0
    14f0:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    14f4:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
    14f8:	b5 01       	movw	r22, r10
    14fa:	0c 2c       	mov	r0, r12
    14fc:	01 c0       	rjmp	.+2      	; 0x1500 <main+0x3de>
    14fe:	66 0f       	add	r22, r22
    1500:	0a 94       	dec	r0
    1502:	ea f7       	brpl	.-6      	; 0x14fe <main+0x3dc>
    1504:	61 7e       	andi	r22, 0xE1	; 225
    1506:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
    150a:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:286
          digitalWrite(_sck, HIGH);                         // reset the clock signal
    150e:	61 e0       	ldi	r22, 0x01	; 1
    1510:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1514:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    1518:	b1 e0       	ldi	r27, 0x01	; 1
    151a:	cb 1a       	sub	r12, r27
    151c:	d1 08       	sbc	r13, r1
    151e:	38 f7       	brcc	.-50     	; 0x14ee <main+0x3cc>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:282
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
    1520:	58 01       	movw	r10, r16
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    1522:	8a 2d       	mov	r24, r10
    1524:	80 1b       	sub	r24, r16
    1526:	08 2e       	mov	r0, r24
    1528:	00 0c       	add	r0, r0
    152a:	99 0b       	sbc	r25, r25
    152c:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__data_start>
    1530:	28 17       	cp	r18, r24
    1532:	19 06       	cpc	r1, r25
    1534:	f1 f0       	breq	.+60     	; 0x1572 <main+0x450>
    1536:	ec f0       	brlt	.+58     	; 0x1572 <main+0x450>
main():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:290
        {                                                   //
          reply = 0;                                        // reset our return byte
    1538:	d1 2c       	mov	r13, r1
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    153a:	a8 e0       	ldi	r26, 0x08	; 8
    153c:	ca 2e       	mov	r12, r26
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:293
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
          {                                                 //
            reply <<= 1;                                    // shift buffer one bit left
    153e:	dd 0c       	add	r13, r13
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:294
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
    1540:	60 e0       	ldi	r22, 0x00	; 0
    1542:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1546:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:295
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
    154a:	61 e0       	ldi	r22, 0x01	; 1
    154c:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1550:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:296
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
    1554:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <BME680+0x1d>
    1558:	0e 94 26 02 	call	0x44c	; 0x44c <digitalRead>
    155c:	89 2b       	or	r24, r25
    155e:	11 f0       	breq	.+4      	; 0x1564 <main+0x442>
    1560:	68 94       	set
    1562:	d0 f8       	bld	r13, 0
    1564:	ca 94       	dec	r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:291
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
    1566:	c1 10       	cpse	r12, r1
    1568:	ea cf       	rjmp	.-44     	; 0x153e <main+0x41c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:298
            reply <<= 1;                                    // shift buffer one bit left
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
          }                                                 // of for-next each bit
          *bytePtr++ = reply;                               // Add byte just read to return data
    156a:	d5 01       	movw	r26, r10
    156c:	dd 92       	st	X+, r13
    156e:	5d 01       	movw	r10, r26
    1570:	d8 cf       	rjmp	.-80     	; 0x1522 <main+0x400>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:300
        }                                                   // of for-next each byte to be read
        digitalWrite(_cs, HIGH);                            // Tell BME680 to stop listening
    1572:	61 e0       	ldi	r22, 0x01	; 1
    1574:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    1578:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
getCalibration():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:648
  getData(BME680_COEFF_START_ADDRESS1, coeff_arr1);  // Split reading registers into 2
  getData(BME680_COEFF_START_ADDRESS2, coeff_arr2);  // one 25 bytes and the other 16
  _T1 = (uint16_t)(CONCAT_BYTES(coeff_arr2[BME680_T1_MSB_REG], coeff_arr2[BME680_T1_LSB_REG]));
    157c:	d8 01       	movw	r26, r16
    157e:	18 96       	adiw	r26, 0x08	; 8
    1580:	8d 91       	ld	r24, X+
    1582:	9c 91       	ld	r25, X
    1584:	19 97       	sbiw	r26, 0x09	; 9
    1586:	90 93 d5 03 	sts	0x03D5, r25	; 0x8003d5 <BME680+0x32>
    158a:	80 93 d4 03 	sts	0x03D4, r24	; 0x8003d4 <BME680+0x31>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:649
  _T2 = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_T2_MSB_REG], coeff_arr1[BME680_T2_LSB_REG]));
    158e:	8a 81       	ldd	r24, Y+2	; 0x02
    1590:	9b 81       	ldd	r25, Y+3	; 0x03
    1592:	90 93 db 03 	sts	0x03DB, r25	; 0x8003db <BME680+0x38>
    1596:	80 93 da 03 	sts	0x03DA, r24	; 0x8003da <BME680+0x37>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:650
  _T3 = (int8_t)(coeff_arr1[BME680_T3_REG]);
    159a:	8c 81       	ldd	r24, Y+4	; 0x04
    159c:	80 93 ca 03 	sts	0x03CA, r24	; 0x8003ca <BME680+0x27>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:654
  /*************************************
  ** Pressure related coefficients    **
  *************************************/
  _P1  = (uint16_t)(CONCAT_BYTES(coeff_arr1[BME680_P1_MSB_REG], coeff_arr1[BME680_P1_LSB_REG]));
    15a0:	8e 81       	ldd	r24, Y+6	; 0x06
    15a2:	9f 81       	ldd	r25, Y+7	; 0x07
    15a4:	90 93 d7 03 	sts	0x03D7, r25	; 0x8003d7 <BME680+0x34>
    15a8:	80 93 d6 03 	sts	0x03D6, r24	; 0x8003d6 <BME680+0x33>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:655
  _P2  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P2_MSB_REG], coeff_arr1[BME680_P2_LSB_REG]));
    15ac:	88 85       	ldd	r24, Y+8	; 0x08
    15ae:	99 85       	ldd	r25, Y+9	; 0x09
    15b0:	90 93 dd 03 	sts	0x03DD, r25	; 0x8003dd <BME680+0x3a>
    15b4:	80 93 dc 03 	sts	0x03DC, r24	; 0x8003dc <BME680+0x39>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:656
  _P3  = (int8_t)coeff_arr1[BME680_P3_REG];
    15b8:	8a 85       	ldd	r24, Y+10	; 0x0a
    15ba:	80 93 cb 03 	sts	0x03CB, r24	; 0x8003cb <BME680+0x28>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:657
  _P4  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P4_MSB_REG], coeff_arr1[BME680_P4_LSB_REG]));
    15be:	8c 85       	ldd	r24, Y+12	; 0x0c
    15c0:	9d 85       	ldd	r25, Y+13	; 0x0d
    15c2:	90 93 df 03 	sts	0x03DF, r25	; 0x8003df <BME680+0x3c>
    15c6:	80 93 de 03 	sts	0x03DE, r24	; 0x8003de <BME680+0x3b>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:658
  _P5  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P5_MSB_REG], coeff_arr1[BME680_P5_LSB_REG]));
    15ca:	8e 85       	ldd	r24, Y+14	; 0x0e
    15cc:	9f 85       	ldd	r25, Y+15	; 0x0f
    15ce:	90 93 e1 03 	sts	0x03E1, r25	; 0x8003e1 <BME680+0x3e>
    15d2:	80 93 e0 03 	sts	0x03E0, r24	; 0x8003e0 <BME680+0x3d>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:659
  _P6  = (int8_t)(coeff_arr1[BME680_P6_REG]);
    15d6:	89 89       	ldd	r24, Y+17	; 0x11
    15d8:	80 93 cc 03 	sts	0x03CC, r24	; 0x8003cc <BME680+0x29>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:660
  _P7  = (int8_t)(coeff_arr1[BME680_P7_REG]);
    15dc:	88 89       	ldd	r24, Y+16	; 0x10
    15de:	80 93 cd 03 	sts	0x03CD, r24	; 0x8003cd <BME680+0x2a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:661
  _P8  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P8_MSB_REG], coeff_arr1[BME680_P8_LSB_REG]));
    15e2:	8c 89       	ldd	r24, Y+20	; 0x14
    15e4:	9d 89       	ldd	r25, Y+21	; 0x15
    15e6:	90 93 e3 03 	sts	0x03E3, r25	; 0x8003e3 <BME680+0x40>
    15ea:	80 93 e2 03 	sts	0x03E2, r24	; 0x8003e2 <BME680+0x3f>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:662
  _P9  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P9_MSB_REG], coeff_arr1[BME680_P9_LSB_REG]));
    15ee:	8e 89       	ldd	r24, Y+22	; 0x16
    15f0:	9f 89       	ldd	r25, Y+23	; 0x17
    15f2:	90 93 e5 03 	sts	0x03E5, r25	; 0x8003e5 <BME680+0x42>
    15f6:	80 93 e4 03 	sts	0x03E4, r24	; 0x8003e4 <BME680+0x41>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:663
  _P10 = (uint8_t)(coeff_arr1[BME680_P10_REG]);
    15fa:	88 8d       	ldd	r24, Y+24	; 0x18
    15fc:	80 93 c2 03 	sts	0x03C2, r24	; 0x8003c2 <BME680+0x1f>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:669
  /**********************************
  ** Humidity related coefficients **
  **********************************/
  _H1 = (uint16_t)(
      ((uint16_t)coeff_arr2[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
      ((coeff_arr2[BME680_H1_LSB_REG] >> BME680_HUM_REG_SHIFT_VAL) & BME680_BIT_H1_DATA_MSK));
    1600:	11 96       	adiw	r26, 0x01	; 1
    1602:	8c 91       	ld	r24, X
    1604:	11 97       	sbiw	r26, 0x01	; 1
    1606:	82 95       	swap	r24
    1608:	8f 70       	andi	r24, 0x0F	; 15
    160a:	90 e0       	ldi	r25, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:668
  _P10 = (uint8_t)(coeff_arr1[BME680_P10_REG]);
  /**********************************
  ** Humidity related coefficients **
  **********************************/
  _H1 = (uint16_t)(
      ((uint16_t)coeff_arr2[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
    160c:	12 96       	adiw	r26, 0x02	; 2
    160e:	2c 91       	ld	r18, X
    1610:	b0 e1       	ldi	r27, 0x10	; 16
    1612:	2b 9f       	mul	r18, r27
    1614:	90 01       	movw	r18, r0
    1616:	11 24       	eor	r1, r1
    1618:	28 2b       	or	r18, r24
    161a:	39 2b       	or	r19, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:667
  _P9  = (int16_t)(CONCAT_BYTES(coeff_arr1[BME680_P9_MSB_REG], coeff_arr1[BME680_P9_LSB_REG]));
  _P10 = (uint8_t)(coeff_arr1[BME680_P10_REG]);
  /**********************************
  ** Humidity related coefficients **
  **********************************/
  _H1 = (uint16_t)(
    161c:	30 93 d1 03 	sts	0x03D1, r19	; 0x8003d1 <BME680+0x2e>
    1620:	20 93 d0 03 	sts	0x03D0, r18	; 0x8003d0 <BME680+0x2d>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:671
      ((uint16_t)coeff_arr2[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
      ((coeff_arr2[BME680_H1_LSB_REG] >> BME680_HUM_REG_SHIFT_VAL) & BME680_BIT_H1_DATA_MSK));
  _H2 = (uint16_t)(
      ((uint16_t)coeff_arr2[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
    1624:	f8 01       	movw	r30, r16
    1626:	20 81       	ld	r18, Z
    1628:	f0 e1       	ldi	r31, 0x10	; 16
    162a:	2f 9f       	mul	r18, r31
    162c:	90 01       	movw	r18, r0
    162e:	11 24       	eor	r1, r1
    1630:	82 2b       	or	r24, r18
    1632:	93 2b       	or	r25, r19
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:670
  ** Humidity related coefficients **
  **********************************/
  _H1 = (uint16_t)(
      ((uint16_t)coeff_arr2[BME680_H1_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
      ((coeff_arr2[BME680_H1_LSB_REG] >> BME680_HUM_REG_SHIFT_VAL) & BME680_BIT_H1_DATA_MSK));
  _H2 = (uint16_t)(
    1634:	90 93 d3 03 	sts	0x03D3, r25	; 0x8003d3 <BME680+0x30>
    1638:	80 93 d2 03 	sts	0x03D2, r24	; 0x8003d2 <BME680+0x2f>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:673
      ((uint16_t)coeff_arr2[BME680_H2_MSB_REG] << BME680_HUM_REG_SHIFT_VAL) |
      ((coeff_arr2[BME680_H2_LSB_REG] >> BME680_HUM_REG_SHIFT_VAL) & BME680_BIT_H1_DATA_MSK));
  _H3 = (int8_t)coeff_arr2[BME680_H3_REG];
    163c:	d8 01       	movw	r26, r16
    163e:	13 96       	adiw	r26, 0x03	; 3
    1640:	8c 91       	ld	r24, X
    1642:	13 97       	sbiw	r26, 0x03	; 3
    1644:	80 93 c4 03 	sts	0x03C4, r24	; 0x8003c4 <BME680+0x21>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:674
  _H4 = (int8_t)coeff_arr2[BME680_H4_REG];
    1648:	14 96       	adiw	r26, 0x04	; 4
    164a:	8c 91       	ld	r24, X
    164c:	14 97       	sbiw	r26, 0x04	; 4
    164e:	80 93 c5 03 	sts	0x03C5, r24	; 0x8003c5 <BME680+0x22>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:675
  _H5 = (int8_t)coeff_arr2[BME680_H5_REG];
    1652:	15 96       	adiw	r26, 0x05	; 5
    1654:	8c 91       	ld	r24, X
    1656:	15 97       	sbiw	r26, 0x05	; 5
    1658:	80 93 c6 03 	sts	0x03C6, r24	; 0x8003c6 <BME680+0x23>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:676
  _H6 = (uint8_t)coeff_arr2[BME680_H6_REG];
    165c:	16 96       	adiw	r26, 0x06	; 6
    165e:	8c 91       	ld	r24, X
    1660:	16 97       	sbiw	r26, 0x06	; 6
    1662:	80 93 c1 03 	sts	0x03C1, r24	; 0x8003c1 <BME680+0x1e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:677
  _H7 = (int8_t)coeff_arr2[BME680_H7_REG];
    1666:	17 96       	adiw	r26, 0x07	; 7
    1668:	8c 91       	ld	r24, X
    166a:	17 97       	sbiw	r26, 0x07	; 7
    166c:	80 93 c7 03 	sts	0x03C7, r24	; 0x8003c7 <BME680+0x24>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:681
  /************************************
  ** Gas heater related coefficients **
  ************************************/
  _G1 = (int8_t)coeff_arr2[BME680_GH1_REG];
    1670:	1c 96       	adiw	r26, 0x0c	; 12
    1672:	8c 91       	ld	r24, X
    1674:	1c 97       	sbiw	r26, 0x0c	; 12
    1676:	80 93 c8 03 	sts	0x03C8, r24	; 0x8003c8 <BME680+0x25>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:682
  _G2 = (int16_t)(CONCAT_BYTES(coeff_arr2[BME680_GH2_MSB_REG], coeff_arr2[BME680_GH2_LSB_REG]));
    167a:	1a 96       	adiw	r26, 0x0a	; 10
    167c:	8d 91       	ld	r24, X+
    167e:	9c 91       	ld	r25, X
    1680:	1b 97       	sbiw	r26, 0x0b	; 11
    1682:	90 93 d9 03 	sts	0x03D9, r25	; 0x8003d9 <BME680+0x36>
    1686:	80 93 d8 03 	sts	0x03D8, r24	; 0x8003d8 <BME680+0x35>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:683
  _G3 = (int8_t)coeff_arr2[BME680_GH3_REG];
    168a:	1d 96       	adiw	r26, 0x0d	; 13
    168c:	8c 91       	ld	r24, X
    168e:	80 93 c9 03 	sts	0x03C9, r24	; 0x8003c9 <BME680+0x26>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:684
  uint8_t temp_var = 0;
    1692:	cf 57       	subi	r28, 0x7F	; 127
    1694:	df 4f       	sbci	r29, 0xFF	; 255
    1696:	18 82       	st	Y, r1
    1698:	c1 58       	subi	r28, 0x81	; 129
    169a:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:685
  getData(BME680_ADDR_RES_HEAT_RANGE_ADDR, temp_var);
    169c:	be 01       	movw	r22, r28
    169e:	6f 57       	subi	r22, 0x7F	; 127
    16a0:	7f 4f       	sbci	r23, 0xFF	; 255
    16a2:	82 e0       	ldi	r24, 0x02	; 2
    16a4:	0e 94 a6 05 	call	0xb4c	; 0xb4c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:686
  _res_heat_range = ((temp_var & BME680_RHRANGE_MSK) / 16);
    16a8:	cf 57       	subi	r28, 0x7F	; 127
    16aa:	df 4f       	sbci	r29, 0xFF	; 255
    16ac:	88 81       	ld	r24, Y
    16ae:	c1 58       	subi	r28, 0x81	; 129
    16b0:	d0 40       	sbci	r29, 0x00	; 0
    16b2:	82 95       	swap	r24
    16b4:	83 70       	andi	r24, 0x03	; 3
    16b6:	80 93 c3 03 	sts	0x03C3, r24	; 0x8003c3 <BME680+0x20>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:687
  getData(BME680_ADDR_RES_HEAT_VAL_ADDR, temp_var);
    16ba:	be 01       	movw	r22, r28
    16bc:	6f 57       	subi	r22, 0x7F	; 127
    16be:	7f 4f       	sbci	r23, 0xFF	; 255
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	0e 94 a6 05 	call	0xb4c	; 0xb4c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:688
  _res_heat = (int8_t)temp_var;
    16c6:	cf 57       	subi	r28, 0x7F	; 127
    16c8:	df 4f       	sbci	r29, 0xFF	; 255
    16ca:	88 81       	ld	r24, Y
    16cc:	c1 58       	subi	r28, 0x81	; 129
    16ce:	d0 40       	sbci	r29, 0x00	; 0
    16d0:	80 93 ce 03 	sts	0x03CE, r24	; 0x8003ce <BME680+0x2b>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:689
  getData(BME680_ADDR_RANGE_SW_ERR_ADDR, temp_var);
    16d4:	be 01       	movw	r22, r28
    16d6:	6f 57       	subi	r22, 0x7F	; 127
    16d8:	7f 4f       	sbci	r23, 0xFF	; 255
    16da:	84 e0       	ldi	r24, 0x04	; 4
    16dc:	0e 94 a6 05 	call	0xb4c	; 0xb4c <unsigned char& BME680_Class::getData<unsigned char>(unsigned char, unsigned char&) const [clone .constprop.32]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:690
  _rng_sw_err = ((int8_t)temp_var & (int8_t)BME680_RSERROR_MSK) / 16;
    16e0:	cf 57       	subi	r28, 0x7F	; 127
    16e2:	df 4f       	sbci	r29, 0xFF	; 255
    16e4:	88 81       	ld	r24, Y
    16e6:	c1 58       	subi	r28, 0x81	; 129
    16e8:	d0 40       	sbci	r29, 0x00	; 0
    16ea:	85 95       	asr	r24
    16ec:	85 95       	asr	r24
    16ee:	85 95       	asr	r24
    16f0:	85 95       	asr	r24
    16f2:	80 93 cf 03 	sts	0x03CF, r24	; 0x8003cf <BME680+0x2c>
commonInitialization():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:598
    bitWrite(SPI_Register, BME680_SPI_MEM_PAGE_POSITION, 0);    // Turn off Page bit to go to Page 0
    putData(BME680_SPI_REGISTER, SPI_Register);                 // Write value to register
  }                                                             // of if-then we are in SPI mode
  if (readByte(BME680_CHIPID_REGISTER) == BME680_CHIPID) {      // check for correct chip id
    getCalibration();                                           // get the calibration values
    if (_I2CAddress == 0) {                                     // If using SPI, switch to correct
    16f6:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    16fa:	81 11       	cpse	r24, r1
    16fc:	11 c0       	rjmp	.+34     	; 0x1720 <main+0x5fe>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:599
      bitWrite(SPI_Register, BME680_SPI_MEM_PAGE_POSITION, 1);  // Page "1" again
    16fe:	c0 57       	subi	r28, 0x70	; 112
    1700:	df 4f       	sbci	r29, 0xFF	; 255
    1702:	88 81       	ld	r24, Y
    1704:	c0 59       	subi	r28, 0x90	; 144
    1706:	d0 40       	sbci	r29, 0x00	; 0
    1708:	80 61       	ori	r24, 0x10	; 16
    170a:	c0 57       	subi	r28, 0x70	; 112
    170c:	df 4f       	sbci	r29, 0xFF	; 255
    170e:	88 83       	st	Y, r24
    1710:	c0 59       	subi	r28, 0x90	; 144
    1712:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:600
      putData(BME680_SPI_REGISTER, SPI_Register);               // Update register value
    1714:	be 01       	movw	r22, r28
    1716:	60 57       	subi	r22, 0x70	; 112
    1718:	7f 4f       	sbci	r23, 0xFF	; 255
    171a:	83 e7       	ldi	r24, 0x73	; 115
    171c:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:602
    }                                                           // of if-then SPI mode
    uint8_t workRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the control measure
    1720:	84 e7       	ldi	r24, 0x74	; 116
    1722:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:604
    putData(BME680_CONTROL_MEASURE_REGISTER,
            (uint8_t)(workRegister | 1));  // Trigger 1st measurement
    1726:	81 60       	ori	r24, 0x01	; 1
    1728:	89 83       	std	Y+1, r24	; 0x01
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:603
    if (_I2CAddress == 0) {                                     // If using SPI, switch to correct
      bitWrite(SPI_Register, BME680_SPI_MEM_PAGE_POSITION, 1);  // Page "1" again
      putData(BME680_SPI_REGISTER, SPI_Register);               // Update register value
    }                                                           // of if-then SPI mode
    uint8_t workRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the control measure
    putData(BME680_CONTROL_MEASURE_REGISTER,
    172a:	b7 01       	movw	r22, r14
    172c:	84 e7       	ldi	r24, 0x74	; 116
    172e:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:35
  while (!BME680.begin(I2C_STANDARD_MODE, 0x77)) {  // Start BME680 using I2C, use first device found
    Serial.print(F("-  Unable to find BME680. Trying again in 5 seconds.\n"));
    delay(5000);
  }  // of loop until device is located
  Serial.print(F("- Setting 16x oversampling for all sensors\n"));
    1732:	8c e7       	ldi	r24, 0x7C	; 124
    1734:	91 e0       	ldi	r25, 0x01	; 1
    1736:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
setOversampling():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:709
       sampling >= UnknownOversample)) {  // return an error if sensor or oversample is out of range
    return (UINT8_MAX);
  }
  uint8_t tempRegister;            // Temporary register variable
  uint8_t returnValue = sampling;  // Return sampling value
  waitForReadings();               // Ensure any active reading is finished
    173a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:739
      }  // if-then return current value or set new value
      break;
    }                        // of PressureSensor
    case TemperatureSensor:  // Set the temperature oversampling
    {
      tempRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the register contents
    173e:	84 e7       	ldi	r24, 0x74	; 116
    1740:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:743
      if (sampling == UINT8_MAX) {  // If we just want to read the values
        returnValue = (tempRegister & ~BME680_TEMPERATURE_MASK) >> 5;  // Set return value
      } else {
        tempRegister &= BME680_TEMPERATURE_MASK;  // Mask bits to 0
    1744:	8f 71       	andi	r24, 0x1F	; 31
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:744
        tempRegister |= (sampling << 5);          // Add in the sampling bits at offset
    1746:	80 6a       	ori	r24, 0xA0	; 160
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:746
        putData(BME680_CONTROL_MEASURE_REGISTER,
                (uint8_t)tempRegister);  // Update humidity bits 5:7
    1748:	89 83       	std	Y+1, r24	; 0x01
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:745
      if (sampling == UINT8_MAX) {  // If we just want to read the values
        returnValue = (tempRegister & ~BME680_TEMPERATURE_MASK) >> 5;  // Set return value
      } else {
        tempRegister &= BME680_TEMPERATURE_MASK;  // Mask bits to 0
        tempRegister |= (sampling << 5);          // Add in the sampling bits at offset
        putData(BME680_CONTROL_MEASURE_REGISTER,
    174a:	b7 01       	movw	r22, r14
    174c:	84 e7       	ldi	r24, 0x74	; 116
    174e:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:709
       sampling >= UnknownOversample)) {  // return an error if sensor or oversample is out of range
    return (UINT8_MAX);
  }
  uint8_t tempRegister;            // Temporary register variable
  uint8_t returnValue = sampling;  // Return sampling value
  waitForReadings();               // Ensure any active reading is finished
    1752:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:713
  switch (sensor) {                // Depending upon which sensor is chosen
    case HumiditySensor:           // Set the humidity oversampling
    {
      tempRegister = readByte(BME680_CONTROL_HUMIDITY_REGISTER);  // Read the register contents
    1756:	82 e7       	ldi	r24, 0x72	; 114
    1758:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:718
      if (sampling == UINT8_MAX) {                                // If we just want to read values

        returnValue = tempRegister & ~BME680_HUMIDITY_MASK;  // Set return value
      } else {
        tempRegister &= BME680_HUMIDITY_MASK;  // Mask bits to 0
    175c:	88 7f       	andi	r24, 0xF8	; 248
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:719
        tempRegister |= sampling;              // Add in the sampling bits
    175e:	85 60       	ori	r24, 0x05	; 5
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:721
        putData(BME680_CONTROL_HUMIDITY_REGISTER,
                (uint8_t)tempRegister);  // Update humidity bits 0:2
    1760:	89 83       	std	Y+1, r24	; 0x01
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:720

        returnValue = tempRegister & ~BME680_HUMIDITY_MASK;  // Set return value
      } else {
        tempRegister &= BME680_HUMIDITY_MASK;  // Mask bits to 0
        tempRegister |= sampling;              // Add in the sampling bits
        putData(BME680_CONTROL_HUMIDITY_REGISTER,
    1762:	b7 01       	movw	r22, r14
    1764:	82 e7       	ldi	r24, 0x72	; 114
    1766:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:709
       sampling >= UnknownOversample)) {  // return an error if sensor or oversample is out of range
    return (UINT8_MAX);
  }
  uint8_t tempRegister;            // Temporary register variable
  uint8_t returnValue = sampling;  // Return sampling value
  waitForReadings();               // Ensure any active reading is finished
    176a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:727
      }                                  // if-then return current value or set new value
      break;
    }                     // of HumiditySensor
    case PressureSensor:  // Set the pressure oversampling
    {
      tempRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the register contents
    176e:	84 e7       	ldi	r24, 0x74	; 116
    1770:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:731
      if (sampling == UINT8_MAX) {  // If we just want to read the values
        returnValue = (tempRegister & ~BME680_PRESSURE_MASK) >> 2;  // Set return value
      } else {
        tempRegister &= BME680_PRESSURE_MASK;  // Mask bits to 0
    1774:	83 7e       	andi	r24, 0xE3	; 227
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:732
        tempRegister |= (sampling << 2);       // Add in sampling bits at offset
    1776:	84 61       	ori	r24, 0x14	; 20
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:733
        putData(BME680_CONTROL_MEASURE_REGISTER, (uint8_t)tempRegister);  // Update register
    1778:	89 83       	std	Y+1, r24	; 0x01
    177a:	b7 01       	movw	r22, r14
    177c:	84 e7       	ldi	r24, 0x74	; 116
    177e:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:39
  BME680.setOversampling(TemperatureSensor, Oversample16);  // Use enumerated type values
  BME680.setOversampling(HumiditySensor, Oversample16);     // Use enumerated type values
  BME680.setOversampling(PressureSensor, Oversample16);     // Use enumerated type values
  Serial.print(F("- Setting IIR filter to a value of 4 samples\n"));
    1782:	8e e4       	ldi	r24, 0x4E	; 78
    1784:	91 e0       	ldi	r25, 0x01	; 1
    1786:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
setIIRFilter():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:762
   @details When called with no parameters returns the current IIR Filter setting, otherwise
   when called with one parameter will set the IIR filter value and return the new setting
   param[in] iirFilterSetting New setting
   return   IIR Filter setting
   */
  waitForReadings();                                       // Ensure any active reading is finished
    178a:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:763
  uint8_t returnValue = readByte(BME680_CONFIG_REGISTER);  // Get control register byte contents
    178e:	85 e7       	ldi	r24, 0x75	; 117
    1790:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:766
  if (iirFilterSetting != UINT8_MAX)                       // If the value is to be changed
  {                                                        //
    returnValue = returnValue & B11100011;                 // mask IIR bits
    1794:	83 7e       	andi	r24, 0xE3	; 227
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:767
    returnValue |= (iirFilterSetting & B00000111) << 2;    // use 3 bits of iirFilterSetting
    1796:	88 60       	ori	r24, 0x08	; 8
    1798:	89 83       	std	Y+1, r24	; 0x01
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:768
    putData(BME680_CONFIG_REGISTER, returnValue);          // Write new control register value
    179a:	b7 01       	movw	r22, r14
    179c:	85 e7       	ldi	r24, 0x75	; 117
    179e:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:41
  BME680.setIIRFilter(IIR4);                                                    // Use enumerated type values
  Serial.print(F("- Setting gas measurement to 320\xC2\xB0\x43 for 150ms\n"));  // "�C" symbols
    17a2:	8f e1       	ldi	r24, 0x1F	; 31
    17a4:	91 e0       	ldi	r25, 0x01	; 1
    17a6:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
setGas():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:904
   * @brief    sets the gas measurement target temperature and heating time
   * param[in] GasTemp  Target temperature in Celsius
   * param[in] GasMillis Milliseconds to turn on heater
   * return Always returns "true"
   */
  waitForReadings();  // Ensure any active reading is finished
    17aa:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:905
  uint8_t gasRegister = readByte(BME680_CONTROL_GAS_REGISTER2);  // Read current register values
    17ae:	81 e7       	ldi	r24, 0x71	; 113
    17b0:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
    17b4:	d8 2e       	mov	r13, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:912
    // If either input variable is zero //
    putData(BME680_CONTROL_GAS_REGISTER1, (uint8_t)B00001000);  // Turn off gas heater
    putData(BME680_CONTROL_GAS_REGISTER2,
            (uint8_t)(gasRegister & B11101111));  // Turn off gas measurements
  } else {
    putData(BME680_CONTROL_GAS_REGISTER1, (uint8_t)0);  // Turn off heater bit to turn on
    17b6:	19 82       	std	Y+1, r1	; 0x01
    17b8:	b7 01       	movw	r22, r14
    17ba:	80 e7       	ldi	r24, 0x70	; 112
    17bc:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:921
      GasTemp = 200;
    else if (GasTemp > 400)
      GasTemp = 400;  // Clamp temperature to min/max

    var1 = (((int32_t)(_Temperature / 100) * _H3) / 1000) << 8;
    var2 = (_G1 + 784) * (((((_G2 + 154009) * GasTemp * 5) / 100) + 3276800) / 10);  // Issue #26
    17c0:	20 91 d8 03 	lds	r18, 0x03D8	; 0x8003d8 <BME680+0x35>
    17c4:	30 91 d9 03 	lds	r19, 0x03D9	; 0x8003d9 <BME680+0x36>
    17c8:	03 2e       	mov	r0, r19
    17ca:	00 0c       	add	r0, r0
    17cc:	44 0b       	sbc	r20, r20
    17ce:	55 0b       	sbc	r21, r21
    17d0:	27 56       	subi	r18, 0x67	; 103
    17d2:	36 4a       	sbci	r19, 0xA6	; 166
    17d4:	4d 4f       	sbci	r20, 0xFD	; 253
    17d6:	5f 4f       	sbci	r21, 0xFF	; 255
    17d8:	a0 e4       	ldi	r26, 0x40	; 64
    17da:	b1 e0       	ldi	r27, 0x01	; 1
    17dc:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
    17e0:	24 e1       	ldi	r18, 0x14	; 20
    17e2:	30 e0       	ldi	r19, 0x00	; 0
    17e4:	40 e0       	ldi	r20, 0x00	; 0
    17e6:	50 e0       	ldi	r21, 0x00	; 0
    17e8:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    17ec:	ca 01       	movw	r24, r20
    17ee:	b9 01       	movw	r22, r18
    17f0:	c2 96       	adiw	r24, 0x32	; 50
    17f2:	2a e0       	ldi	r18, 0x0A	; 10
    17f4:	30 e0       	ldi	r19, 0x00	; 0
    17f6:	40 e0       	ldi	r20, 0x00	; 0
    17f8:	50 e0       	ldi	r21, 0x00	; 0
    17fa:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    17fe:	a0 91 c8 03 	lds	r26, 0x03C8	; 0x8003c8 <BME680+0x25>
    1802:	0a 2e       	mov	r0, r26
    1804:	00 0c       	add	r0, r0
    1806:	bb 0b       	sbc	r27, r27
    1808:	a0 5f       	subi	r26, 0xF0	; 240
    180a:	bc 4f       	sbci	r27, 0xFC	; 252
    180c:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <__mulshisi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:922
    var3 = var1 + (var2 / 2);
    1810:	4b 01       	movw	r8, r22
    1812:	5c 01       	movw	r10, r24
    1814:	b5 94       	asr	r11
    1816:	a7 94       	ror	r10
    1818:	97 94       	ror	r9
    181a:	87 94       	ror	r8
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:920
    if (GasTemp < 200)
      GasTemp = 200;
    else if (GasTemp > 400)
      GasTemp = 400;  // Clamp temperature to min/max

    var1 = (((int32_t)(_Temperature / 100) * _H3) / 1000) << 8;
    181c:	60 91 ea 03 	lds	r22, 0x03EA	; 0x8003ea <BME680+0x47>
    1820:	70 91 eb 03 	lds	r23, 0x03EB	; 0x8003eb <BME680+0x48>
    1824:	80 91 ec 03 	lds	r24, 0x03EC	; 0x8003ec <BME680+0x49>
    1828:	90 91 ed 03 	lds	r25, 0x03ED	; 0x8003ed <BME680+0x4a>
    182c:	e4 e6       	ldi	r30, 0x64	; 100
    182e:	4e 2e       	mov	r4, r30
    1830:	51 2c       	mov	r5, r1
    1832:	61 2c       	mov	r6, r1
    1834:	71 2c       	mov	r7, r1
    1836:	a3 01       	movw	r20, r6
    1838:	92 01       	movw	r18, r4
    183a:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    183e:	a0 91 c4 03 	lds	r26, 0x03C4	; 0x8003c4 <BME680+0x21>
    1842:	0a 2e       	mov	r0, r26
    1844:	00 0c       	add	r0, r0
    1846:	bb 0b       	sbc	r27, r27
    1848:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <__mulshisi3>
    184c:	28 ee       	ldi	r18, 0xE8	; 232
    184e:	33 e0       	ldi	r19, 0x03	; 3
    1850:	40 e0       	ldi	r20, 0x00	; 0
    1852:	50 e0       	ldi	r21, 0x00	; 0
    1854:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    1858:	54 2f       	mov	r21, r20
    185a:	43 2f       	mov	r20, r19
    185c:	32 2f       	mov	r19, r18
    185e:	22 27       	eor	r18, r18
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:922
    var2 = (_G1 + 784) * (((((_G2 + 154009) * GasTemp * 5) / 100) + 3276800) / 10);  // Issue #26
    var3 = var1 + (var2 / 2);
    1860:	c5 01       	movw	r24, r10
    1862:	b4 01       	movw	r22, r8
    1864:	62 0f       	add	r22, r18
    1866:	73 1f       	adc	r23, r19
    1868:	84 1f       	adc	r24, r20
    186a:	95 1f       	adc	r25, r21
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:923
    var4 = (var3 / (_res_heat_range + 4));
    186c:	20 91 c3 03 	lds	r18, 0x03C3	; 0x8003c3 <BME680+0x20>
    1870:	30 e0       	ldi	r19, 0x00	; 0
    1872:	2c 5f       	subi	r18, 0xFC	; 252
    1874:	3f 4f       	sbci	r19, 0xFF	; 255
    1876:	03 2e       	mov	r0, r19
    1878:	00 0c       	add	r0, r0
    187a:	44 0b       	sbc	r20, r20
    187c:	55 0b       	sbc	r21, r21
    187e:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    1882:	ca 01       	movw	r24, r20
    1884:	b9 01       	movw	r22, r18
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:924
    var5 = (131 * _res_heat) + 65536;
    1886:	30 91 ce 03 	lds	r19, 0x03CE	; 0x8003ce <BME680+0x2b>
    188a:	23 e8       	ldi	r18, 0x83	; 131
    188c:	32 03       	mulsu	r19, r18
    188e:	40 01       	movw	r8, r0
    1890:	11 24       	eor	r1, r1
    1892:	09 2c       	mov	r0, r9
    1894:	00 0c       	add	r0, r0
    1896:	aa 08       	sbc	r10, r10
    1898:	bb 08       	sbc	r11, r11
    189a:	a5 01       	movw	r20, r10
    189c:	94 01       	movw	r18, r8
    189e:	4f 5f       	subi	r20, 0xFF	; 255
    18a0:	5f 4f       	sbci	r21, 0xFF	; 255
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:925
    heatr_res_x100 = (int32_t)(((var4 / var5) - 250) * 34);
    18a2:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    18a6:	2a 5f       	subi	r18, 0xFA	; 250
    18a8:	31 09       	sbc	r19, r1
    18aa:	41 09       	sbc	r20, r1
    18ac:	51 09       	sbc	r21, r1
    18ae:	a2 e2       	ldi	r26, 0x22	; 34
    18b0:	b0 e0       	ldi	r27, 0x00	; 0
    18b2:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:926
    heatr_res      = (uint8_t)((heatr_res_x100 + 50) / 100);
    18b6:	6e 5c       	subi	r22, 0xCE	; 206
    18b8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ba:	8f 4f       	sbci	r24, 0xFF	; 255
    18bc:	9f 4f       	sbci	r25, 0xFF	; 255
    18be:	a3 01       	movw	r20, r6
    18c0:	92 01       	movw	r18, r4
    18c2:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    18c6:	cf 57       	subi	r28, 0x7F	; 127
    18c8:	df 4f       	sbci	r29, 0xFF	; 255
    18ca:	28 83       	st	Y, r18
    18cc:	c1 58       	subi	r28, 0x81	; 129
    18ce:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:927
    putData(BME680_GAS_HEATER_REGISTER0, heatr_res);
    18d0:	be 01       	movw	r22, r28
    18d2:	6f 57       	subi	r22, 0x7F	; 127
    18d4:	7f 4f       	sbci	r23, 0xFF	; 255
    18d6:	8a e5       	ldi	r24, 0x5A	; 90
    18d8:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:937
    else {
      while (GasMillis > 0x3F) {
        GasMillis = GasMillis >> 2;
        factor += 1;
      }  // of while loop
      durval = (uint8_t)(GasMillis + (factor * 64));
    18dc:	85 e6       	ldi	r24, 0x65	; 101
    18de:	d8 01       	movw	r26, r16
    18e0:	8c 93       	st	X, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:939
    }                                                   // of if-then-else duration exceeds max
    putData(BME680_CONTROL_GAS_REGISTER1, (uint8_t)0);  // then turn off gas heater
    18e2:	19 82       	std	Y+1, r1	; 0x01
    18e4:	b7 01       	movw	r22, r14
    18e6:	80 e7       	ldi	r24, 0x70	; 112
    18e8:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:940
    putData(BME680_GAS_DURATION_REGISTER0, durval);
    18ec:	b8 01       	movw	r22, r16
    18ee:	84 e6       	ldi	r24, 0x64	; 100
    18f0:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:941
    putData(BME680_CONTROL_GAS_REGISTER2, (uint8_t)(gasRegister | B00010000));
    18f4:	8d 2d       	mov	r24, r13
    18f6:	80 61       	ori	r24, 0x10	; 16
    18f8:	89 83       	std	Y+1, r24	; 0x01
    18fa:	b7 01       	movw	r22, r14
    18fc:	81 e7       	ldi	r24, 0x71	; 113
    18fe:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:44
  BME680.setGas(320, 150);         
                                               // 320�c for 150 milliseconds
  Serial.print(F("\n- Initializing BME680 sensor 2 at address MLX90614\n"));
    1902:	8a ee       	ldi	r24, 0xEA	; 234
    1904:	90 e0       	ldi	r25, 0x00	; 0
    1906:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
    190a:	fe 01       	movw	r30, r28
    190c:	ef 57       	subi	r30, 0x7F	; 127
    190e:	ff 4f       	sbci	r31, 0xFF	; 255
    1910:	cf 56       	subi	r28, 0x6F	; 111
    1912:	df 4f       	sbci	r29, 0xFF	; 255
    1914:	f9 83       	std	Y+1, r31	; 0x01
    1916:	e8 83       	st	Y, r30
    1918:	c1 59       	subi	r28, 0x91	; 145
    191a:	d0 40       	sbci	r29, 0x00	; 0
loop():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:60
  //serachAddress();
  static int32_t temp, humidity, pressure, gas;  // BME readings
  static char buf[16];                           // sprintf text buffer
  static float alt;                              // Temporary variable
  static uint16_t loopCounter = 0;               // Display iterations
  if (loopCounter % 25 == 0) {                   // Show header @25 loops
    191c:	a0 90 39 02 	lds	r10, 0x0239	; 0x800239 <loop::loopCounter>
    1920:	b0 90 3a 02 	lds	r11, 0x023A	; 0x80023a <loop::loopCounter+0x1>
    1924:	c2 55       	subi	r28, 0x52	; 82
    1926:	df 4f       	sbci	r29, 0xFF	; 255
    1928:	b9 82       	std	Y+1, r11	; 0x01
    192a:	a8 82       	st	Y, r10
    192c:	ce 5a       	subi	r28, 0xAE	; 174
    192e:	d0 40       	sbci	r29, 0x00	; 0
    1930:	c5 01       	movw	r24, r10
    1932:	69 e1       	ldi	r22, 0x19	; 25
    1934:	70 e0       	ldi	r23, 0x00	; 0
    1936:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <__udivmodhi4>
    193a:	89 2b       	or	r24, r25
    193c:	41 f4       	brne	.+16     	; 0x194e <main+0x82c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:61
    Serial.print(F("\nLoop Temp\xC2\xB0\x43 Humid% Press hPa   Alt m Air m"));
    193e:	8a e5       	ldi	r24, 0x5A	; 90
    1940:	92 e0       	ldi	r25, 0x02	; 2
    1942:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:62
    Serial.print(F("\xE2\x84\xA6\n==== ====== ====== ========= ======= ======\n"));  // "�C" symbol
    1946:	89 e2       	ldi	r24, 0x29	; 41
    1948:	92 e0       	ldi	r25, 0x02	; 2
    194a:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
readSensors():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:799
   */
  return (_I2CAddress);
}  // of method getI2CAddress()
uint8_t BME680_Class::readSensors(const bool waitSwitch) {
  /*! Lookup table for the possible gas range values */
  const uint32_t lookupTable1[16] = {
    194e:	80 e4       	ldi	r24, 0x40	; 64
    1950:	e5 e0       	ldi	r30, 0x05	; 5
    1952:	f1 e0       	ldi	r31, 0x01	; 1
    1954:	de 01       	movw	r26, r28
    1956:	af 5b       	subi	r26, 0xBF	; 191
    1958:	bf 4f       	sbci	r27, 0xFF	; 255
    195a:	01 90       	ld	r0, Z+
    195c:	0d 92       	st	X+, r0
    195e:	8a 95       	dec	r24
    1960:	e1 f7       	brne	.-8      	; 0x195a <main+0x838>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:804
      UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2147483647),
      UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2130303777),
      UINT32_C(2147483647), UINT32_C(2147483647), UINT32_C(2143188679), UINT32_C(2136746228),
      UINT32_C(2147483647), UINT32_C(2126008810), UINT32_C(2147483647), UINT32_C(2147483647)};
  const uint32_t lookupTable2[16] = {
    1962:	80 e4       	ldi	r24, 0x40	; 64
    1964:	e5 e4       	ldi	r30, 0x45	; 69
    1966:	f1 e0       	ldi	r31, 0x01	; 1
    1968:	de 01       	movw	r26, r28
    196a:	11 96       	adiw	r26, 0x01	; 1
    196c:	01 90       	ld	r0, Z+
    196e:	0d 92       	st	X+, r0
    1970:	8a 95       	dec	r24
    1972:	e1 f7       	brne	.-8      	; 0x196c <main+0x84a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:814

  uint8_t  buff[15], gas_range = 0;                          // declare array for registers
  int64_t  var1, var2, var3, var4, var5, var6, temp_scaled;  // Work variables
  uint32_t adc_temp, adc_pres;                               // Raw ADC temperature and pressure
  uint16_t adc_hum, adc_gas_res;                             // Raw ADC humidity and gas
  if (waitSwitch) waitForReadings();      // Doesn't return until the readings are finished
    1974:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <BME680_Class::waitForReadings() const [clone .constprop.29]>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:256
      @param[in] value Data Type "T" to read
      @return    Size of data read in bytes
    */
    uint8_t *      bytePtr    = (uint8_t *)&value;  // Pointer to structure beginning
    static uint8_t structSize = sizeof(T);          // Number of bytes in structure
    if (_I2CAddress)                                // Using I2C if address is non-zero
    1978:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    197c:	88 23       	and	r24, r24
    197e:	09 f4       	brne	.+2      	; 0x1982 <main+0x860>
    1980:	4a c0       	rjmp	.+148    	; 0x1a16 <main+0x8f4>
beginTransmission():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:196
}

void TwoWire::beginTransmission(uint8_t address)
{
  // indicate that we are transmitting
  transmitting = 1;
    1982:	91 e0       	ldi	r25, 0x01	; 1
    1984:	90 93 7f 02 	sts	0x027F, r25	; 0x80027f <TwoWire::transmitting>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:198
  // set address of targeted slave
  txAddress = address;
    1988:	80 93 a1 02 	sts	0x02A1, r24	; 0x8002a1 <TwoWire::txAddress>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:200
  // reset tx buffer iterator vars
  txBufferIndex = 0;
    198c:	10 92 80 02 	sts	0x0280, r1	; 0x800280 <TwoWire::txBufferIndex>
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\libraries\Wire\src/Wire.cpp:201
  txBufferLength = 0;
    1990:	10 92 a2 02 	sts	0x02A2, r1	; 0x8002a2 <TwoWire::txBufferLength>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:259
    {                                               //
      Wire.beginTransmission(_I2CAddress);          // Address the I2C device
      Wire.write(addr);                             // Send register address to read
    1994:	6d e1       	ldi	r22, 0x1D	; 29
    1996:	80 e4       	ldi	r24, 0x40	; 64
    1998:	93 e0       	ldi	r25, 0x03	; 3
    199a:	0e 94 7f 04 	call	0x8fe	; 0x8fe <TwoWire::write(unsigned char)>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:260
      Wire.endTransmission();                       // Close transmission
    199e:	0e 94 9e 01 	call	0x33c	; 0x33c <TwoWire::endTransmission() [clone .constprop.41]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:261
      Wire.requestFrom(_I2CAddress, sizeof(T));     // Request 1 byte of data
    19a2:	6f e0       	ldi	r22, 0x0F	; 15
    19a4:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    19a8:	0e 94 63 05 	call	0xac6	; 0xac6 <TwoWire::requestFrom(unsigned char, unsigned char) [clone .constprop.33]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:262
      structSize = Wire.available();                // Use the actual number of bytes
    19ac:	80 91 54 02 	lds	r24, 0x0254	; 0x800254 <TwoWire::rxBufferLength>
    19b0:	90 91 55 02 	lds	r25, 0x0255	; 0x800255 <TwoWire::rxBufferIndex>
    19b4:	89 1b       	sub	r24, r25
    19b6:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <unsigned char& BME680_Class::getData<unsigned char [15]>(unsigned char, unsigned char (&) [15]) const::structSize>
    19ba:	8e 01       	movw	r16, r28
    19bc:	0f 57       	subi	r16, 0x7F	; 127
    19be:	1f 4f       	sbci	r17, 0xFF	; 255
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:263
      for (uint8_t i = 0; i < structSize; i++)
    19c0:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <unsigned char& BME680_Class::getData<unsigned char [15]>(unsigned char, unsigned char (&) [15]) const::structSize>
    19c4:	80 2f       	mov	r24, r16
    19c6:	cf 56       	subi	r28, 0x6F	; 111
    19c8:	df 4f       	sbci	r29, 0xFF	; 255
    19ca:	b8 80       	ld	r11, Y
    19cc:	c1 59       	subi	r28, 0x91	; 145
    19ce:	d0 40       	sbci	r29, 0x00	; 0
    19d0:	8b 19       	sub	r24, r11
    19d2:	89 17       	cp	r24, r25
    19d4:	08 f0       	brcs	.+2      	; 0x19d8 <main+0x8b6>
    19d6:	98 c0       	rjmp	.+304    	; 0x1b08 <main+0x9e6>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:264
        *bytePtr++ = Wire.read();  // loop for each byte to be read
    19d8:	80 e4       	ldi	r24, 0x40	; 64
    19da:	93 e0       	ldi	r25, 0x03	; 3
    19dc:	0e 94 3f 04 	call	0x87e	; 0x87e <TwoWire::read()>
    19e0:	d8 01       	movw	r26, r16
    19e2:	8d 93       	st	X+, r24
    19e4:	8d 01       	movw	r16, r26
    19e6:	ec cf       	rjmp	.-40     	; 0x19c0 <main+0x89e>
begin():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:531
  return "true" if successful otherwise false
  */
  Wire.begin();             // Start I2C as master
  Wire.setClock(i2cSpeed);  // and set bus speed
  _I2CSpeed = i2cSpeed;
  for (_I2CAddress = BME680_I2C_MIN_ADDRESS; _I2CAddress <= BME680_I2C_MAX_ADDRESS;
    19e8:	80 91 ba 03 	lds	r24, 0x03BA	; 0x8003ba <BME680+0x17>
    19ec:	8f 5f       	subi	r24, 0xFF	; 255
    19ee:	80 93 ba 03 	sts	0x03BA, r24	; 0x8003ba <BME680+0x17>
    19f2:	3e cc       	rjmp	.-1924   	; 0x1270 <main+0x14e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:540
      if (Wire.endTransmission() == 0) {                 // We have found a device that could be
        return commonInitialization();                   // a BME680, so perform common init
      }                                                  // of if-then we have found a device
    }               // of if-then check all or a specific address
  }                 // of for-next each I2C address loop
  _I2CAddress = 0;  // Set to denote no device found
    19f4:	10 92 ba 03 	sts	0x03BA, r1	; 0x8003ba <BME680+0x17>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:541
  _I2CSpeed   = 0;  // Set to denote no device found
    19f8:	10 92 bc 03 	sts	0x03BC, r1	; 0x8003bc <BME680+0x19>
    19fc:	10 92 bb 03 	sts	0x03BB, r1	; 0x8003bb <BME680+0x18>
setup():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:32
  delay(3000);
#endif
  Serial.print(F("Starting I2CDemo example program for BME680\n"));
  Serial.print(F("- Initializing BME680 sensor\n"));
  while (!BME680.begin(I2C_STANDARD_MODE, 0x77)) {  // Start BME680 using I2C, use first device found
    Serial.print(F("-  Unable to find BME680. Trying again in 5 seconds.\n"));
    1a00:	88 ea       	ldi	r24, 0xA8	; 168
    1a02:	91 e0       	ldi	r25, 0x01	; 1
    1a04:	0e 94 c3 03 	call	0x786	; 0x786 <Print::print(__FlashStringHelper const*) [clone .constprop.46]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:33
    delay(5000);
    1a08:	68 e8       	ldi	r22, 0x88	; 136
    1a0a:	73 e1       	ldi	r23, 0x13	; 19
    1a0c:	80 e0       	ldi	r24, 0x00	; 0
    1a0e:	90 e0       	ldi	r25, 0x00	; 0
    1a10:	0e 94 a2 02 	call	0x544	; 0x544 <delay>
    1a14:	f9 cb       	rjmp	.-2062   	; 0x1208 <main+0xe6>
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:268
    }                              //
    else                           //
    {                              //
      if (_sck == 0)               // if sck is zero then hardware SPI
    1a16:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1a1a:	81 11       	cpse	r24, r1
    1a1c:	22 c0       	rjmp	.+68     	; 0x1a62 <main+0x940>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:270
      {                            //
        SPI.beginTransaction(
    1a1e:	81 e5       	ldi	r24, 0x51	; 81
    1a20:	90 e0       	ldi	r25, 0x00	; 0
    1a22:	0e 94 9b 01 	call	0x336	; 0x336 <SPIClass::beginTransaction(SPISettings) [clone .constprop.45]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:272
            SPISettings(SPI_HERZ, MSBFIRST, SPI_MODE0));  // Start the SPI transaction
        digitalWrite(_cs, LOW);                           // Tell BME680 to listen up
    1a26:	60 e0       	ldi	r22, 0x00	; 0
    1a28:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    1a2c:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:273
        SPI.transfer(addr | 0x80);                        // bit 7 is high, so read a byte
    1a30:	8d e9       	ldi	r24, 0x9D	; 157
    1a32:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    1a36:	8e 01       	movw	r16, r28
    1a38:	0f 57       	subi	r16, 0x7F	; 127
    1a3a:	1f 4f       	sbci	r17, 0xFF	; 255
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:274
        for (uint8_t i = 0; i < structSize; i++)
    1a3c:	90 91 02 01 	lds	r25, 0x0102	; 0x800102 <unsigned char& BME680_Class::getData<unsigned char [15]>(unsigned char, unsigned char (&) [15]) const::structSize>
    1a40:	80 2f       	mov	r24, r16
    1a42:	cf 56       	subi	r28, 0x6F	; 111
    1a44:	df 4f       	sbci	r29, 0xFF	; 255
    1a46:	b8 81       	ld	r27, Y
    1a48:	c1 59       	subi	r28, 0x91	; 145
    1a4a:	d0 40       	sbci	r29, 0x00	; 0
    1a4c:	8b 1b       	sub	r24, r27
    1a4e:	89 17       	cp	r24, r25
    1a50:	08 f0       	brcs	.+2      	; 0x1a54 <main+0x932>
    1a52:	55 c0       	rjmp	.+170    	; 0x1afe <main+0x9dc>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:275
          *bytePtr++ = SPI.transfer(0);  // loop for each byte to be read
    1a54:	80 e0       	ldi	r24, 0x00	; 0
    1a56:	0e 94 b2 04 	call	0x964	; 0x964 <SPIClass::transfer(unsigned char)>
    1a5a:	f8 01       	movw	r30, r16
    1a5c:	81 93       	st	Z+, r24
    1a5e:	8f 01       	movw	r16, r30
    1a60:	ed cf       	rjmp	.-38     	; 0x1a3c <main+0x91a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:281
        digitalWrite(_cs, HIGH);         // Tell BME680 to stop listening
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
    1a62:	60 e0       	ldi	r22, 0x00	; 0
    1a64:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    1a68:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    1a6c:	07 e0       	ldi	r16, 0x07	; 7
    1a6e:	10 e0       	ldi	r17, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:284
        for (j = 7; j >= 0; j--)         // First send the address byte
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
    1a70:	60 e0       	ldi	r22, 0x00	; 0
    1a72:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1a76:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:285
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
    1a7a:	61 e0       	ldi	r22, 0x01	; 1
    1a7c:	70 e0       	ldi	r23, 0x00	; 0
    1a7e:	00 2e       	mov	r0, r16
    1a80:	01 c0       	rjmp	.+2      	; 0x1a84 <main+0x962>
    1a82:	66 0f       	add	r22, r22
    1a84:	0a 94       	dec	r0
    1a86:	ea f7       	brpl	.-6      	; 0x1a82 <main+0x960>
    1a88:	6d 79       	andi	r22, 0x9D	; 157
    1a8a:	80 91 bf 03 	lds	r24, 0x03BF	; 0x8003bf <BME680+0x1c>
    1a8e:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:286
          digitalWrite(_sck, HIGH);                         // reset the clock signal
    1a92:	61 e0       	ldi	r22, 0x01	; 1
    1a94:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1a98:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
    1a9c:	01 50       	subi	r16, 0x01	; 1
    1a9e:	11 09       	sbc	r17, r1
    1aa0:	38 f7       	brcc	.-50     	; 0x1a70 <main+0x94e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:282
        SPI.endTransaction();            // End the transaction
      } else {                           // otherwise we are using soft SPI
        int8_t  i, j;                    // Loop variables
        uint8_t reply;                   // return byte for soft SPI transfer
        digitalWrite(_cs, LOW);          // Tell BME680 to listen up
        for (j = 7; j >= 0; j--)         // First send the address byte
    1aa2:	fe 01       	movw	r30, r28
    1aa4:	ef 57       	subi	r30, 0x7F	; 127
    1aa6:	ff 4f       	sbci	r31, 0xFF	; 255
    1aa8:	7f 01       	movw	r14, r30
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    1aaa:	8e 2d       	mov	r24, r14
    1aac:	cf 56       	subi	r28, 0x6F	; 111
    1aae:	df 4f       	sbci	r29, 0xFF	; 255
    1ab0:	f8 81       	ld	r31, Y
    1ab2:	c1 59       	subi	r28, 0x91	; 145
    1ab4:	d0 40       	sbci	r29, 0x00	; 0
    1ab6:	8f 1b       	sub	r24, r31
    1ab8:	08 2e       	mov	r0, r24
    1aba:	00 0c       	add	r0, r0
    1abc:	99 0b       	sbc	r25, r25
    1abe:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <unsigned char& BME680_Class::getData<unsigned char [15]>(unsigned char, unsigned char (&) [15]) const::structSize>
    1ac2:	28 17       	cp	r18, r24
    1ac4:	19 06       	cpc	r1, r25
    1ac6:	d9 f0       	breq	.+54     	; 0x1afe <main+0x9dc>
    1ac8:	d4 f0       	brlt	.+52     	; 0x1afe <main+0x9dc>
main():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:290
        {                                                   //
          reply = 0;                                        // reset our return byte
    1aca:	10 e0       	ldi	r17, 0x00	; 0
getData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:288
        {
          digitalWrite(_sck, LOW);                          // set the clock signal
          digitalWrite(_mosi, ((addr) | 0x80) & (1 << j));  // set the MOSI pin state
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
    1acc:	08 e0       	ldi	r16, 0x08	; 8
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:293
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
          {                                                 //
            reply <<= 1;                                    // shift buffer one bit left
    1ace:	11 0f       	add	r17, r17
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:294
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
    1ad0:	60 e0       	ldi	r22, 0x00	; 0
    1ad2:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1ad6:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:295
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
    1ada:	61 e0       	ldi	r22, 0x01	; 1
    1adc:	80 91 be 03 	lds	r24, 0x03BE	; 0x8003be <BME680+0x1b>
    1ae0:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:296
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
    1ae4:	80 91 c0 03 	lds	r24, 0x03C0	; 0x8003c0 <BME680+0x1d>
    1ae8:	0e 94 26 02 	call	0x44c	; 0x44c <digitalRead>
    1aec:	89 2b       	or	r24, r25
    1aee:	09 f0       	breq	.+2      	; 0x1af2 <main+0x9d0>
    1af0:	11 60       	ori	r17, 0x01	; 1
    1af2:	01 50       	subi	r16, 0x01	; 1
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:291
          digitalWrite(_sck, HIGH);                         // reset the clock signal
        }                                                   // of for-next each bit
        for (i = 0; i < structSize; i++)                    // Loop for each byte to read
        {                                                   //
          reply = 0;                                        // reset our return byte
          for (j = 7; j >= 0; j--)                          // Now read the data at that byte
    1af4:	61 f7       	brne	.-40     	; 0x1ace <main+0x9ac>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:298
            reply <<= 1;                                    // shift buffer one bit left
            digitalWrite(_sck, LOW);                        // set and reset the clock signal
            digitalWrite(_sck, HIGH);                       // pin to get the next MISO bit
            if (digitalRead(_miso)) reply |= 1;             // read the MISO bit, add to reply
          }                                                 // of for-next each bit
          *bytePtr++ = reply;                               // Add byte just read to return data
    1af6:	d7 01       	movw	r26, r14
    1af8:	1d 93       	st	X+, r17
    1afa:	7d 01       	movw	r14, r26
    1afc:	d6 cf       	rjmp	.-84     	; 0x1aaa <main+0x988>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.h:300
        }                                                   // of for-next each byte to be read
        digitalWrite(_cs, HIGH);                            // Tell BME680 to stop listening
    1afe:	61 e0       	ldi	r22, 0x01	; 1
    1b00:	80 91 bd 03 	lds	r24, 0x03BD	; 0x8003bd <BME680+0x1a>
    1b04:	0e 94 4f 02 	call	0x49e	; 0x49e <digitalWrite>
readSensors():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:816
  int64_t  var1, var2, var3, var4, var5, var6, temp_scaled;  // Work variables
  uint32_t adc_temp, adc_pres;                               // Raw ADC temperature and pressure
  uint16_t adc_hum, adc_gas_res;                             // Raw ADC humidity and gas
  if (waitSwitch) waitForReadings();      // Doesn't return until the readings are finished
  getData(BME680_STATUS_REGISTER, buff);  // read all 15 bytes in one go
  adc_pres = (uint32_t)(((uint32_t)buff[2] << 12) | ((uint32_t)buff[3] << 4) |
    1b08:	cd 57       	subi	r28, 0x7D	; 125
    1b0a:	df 4f       	sbci	r29, 0xFF	; 255
    1b0c:	88 81       	ld	r24, Y
    1b0e:	c3 58       	subi	r28, 0x83	; 131
    1b10:	d0 40       	sbci	r29, 0x00	; 0
    1b12:	90 e0       	ldi	r25, 0x00	; 0
    1b14:	b0 e0       	ldi	r27, 0x00	; 0
    1b16:	a0 e0       	ldi	r26, 0x00	; 0
    1b18:	1c e0       	ldi	r17, 0x0C	; 12
    1b1a:	88 0f       	add	r24, r24
    1b1c:	99 1f       	adc	r25, r25
    1b1e:	aa 1f       	adc	r26, r26
    1b20:	bb 1f       	adc	r27, r27
    1b22:	1a 95       	dec	r17
    1b24:	d1 f7       	brne	.-12     	; 0x1b1a <main+0x9f8>
    1b26:	cc 57       	subi	r28, 0x7C	; 124
    1b28:	df 4f       	sbci	r29, 0xFF	; 255
    1b2a:	48 81       	ld	r20, Y
    1b2c:	c4 58       	subi	r28, 0x84	; 132
    1b2e:	d0 40       	sbci	r29, 0x00	; 0
    1b30:	50 e0       	ldi	r21, 0x00	; 0
    1b32:	70 e0       	ldi	r23, 0x00	; 0
    1b34:	60 e0       	ldi	r22, 0x00	; 0
    1b36:	04 e0       	ldi	r16, 0x04	; 4
    1b38:	44 0f       	add	r20, r20
    1b3a:	55 1f       	adc	r21, r21
    1b3c:	66 1f       	adc	r22, r22
    1b3e:	77 1f       	adc	r23, r23
    1b40:	0a 95       	dec	r16
    1b42:	d1 f7       	brne	.-12     	; 0x1b38 <main+0xa16>
    1b44:	84 2b       	or	r24, r20
    1b46:	95 2b       	or	r25, r21
    1b48:	a6 2b       	or	r26, r22
    1b4a:	b7 2b       	or	r27, r23
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:817
                        ((uint32_t)buff[4] >> 4));  // put the 3 bytes of Pressure
    1b4c:	cb 57       	subi	r28, 0x7B	; 123
    1b4e:	df 4f       	sbci	r29, 0xFF	; 255
    1b50:	48 81       	ld	r20, Y
    1b52:	c5 58       	subi	r28, 0x85	; 133
    1b54:	d0 40       	sbci	r29, 0x00	; 0
    1b56:	50 e0       	ldi	r21, 0x00	; 0
    1b58:	70 e0       	ldi	r23, 0x00	; 0
    1b5a:	60 e0       	ldi	r22, 0x00	; 0
    1b5c:	24 e0       	ldi	r18, 0x04	; 4
    1b5e:	76 95       	lsr	r23
    1b60:	67 95       	ror	r22
    1b62:	57 95       	ror	r21
    1b64:	47 95       	ror	r20
    1b66:	2a 95       	dec	r18
    1b68:	d1 f7       	brne	.-12     	; 0x1b5e <main+0xa3c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:816
  int64_t  var1, var2, var3, var4, var5, var6, temp_scaled;  // Work variables
  uint32_t adc_temp, adc_pres;                               // Raw ADC temperature and pressure
  uint16_t adc_hum, adc_gas_res;                             // Raw ADC humidity and gas
  if (waitSwitch) waitForReadings();      // Doesn't return until the readings are finished
  getData(BME680_STATUS_REGISTER, buff);  // read all 15 bytes in one go
  adc_pres = (uint32_t)(((uint32_t)buff[2] << 12) | ((uint32_t)buff[3] << 4) |
    1b6a:	5c 01       	movw	r10, r24
    1b6c:	6d 01       	movw	r12, r26
    1b6e:	a4 2a       	or	r10, r20
    1b70:	b5 2a       	or	r11, r21
    1b72:	c6 2a       	or	r12, r22
    1b74:	d7 2a       	or	r13, r23
    1b76:	c0 55       	subi	r28, 0x50	; 80
    1b78:	df 4f       	sbci	r29, 0xFF	; 255
    1b7a:	a8 82       	st	Y, r10
    1b7c:	b9 82       	std	Y+1, r11	; 0x01
    1b7e:	ca 82       	std	Y+2, r12	; 0x02
    1b80:	db 82       	std	Y+3, r13	; 0x03
    1b82:	c0 5b       	subi	r28, 0xB0	; 176
    1b84:	d0 40       	sbci	r29, 0x00	; 0
    1b86:	c7 57       	subi	r28, 0x77	; 119
    1b88:	df 4f       	sbci	r29, 0xFF	; 255
    1b8a:	48 80       	ld	r4, Y
    1b8c:	59 80       	ldd	r5, Y+1	; 0x01
    1b8e:	c9 58       	subi	r28, 0x89	; 137
    1b90:	d0 40       	sbci	r29, 0x00	; 0
    1b92:	d4 2c       	mov	r13, r4
    1b94:	c5 2c       	mov	r12, r5
    1b96:	cc 54       	subi	r28, 0x4C	; 76
    1b98:	df 4f       	sbci	r29, 0xFF	; 255
    1b9a:	d9 82       	std	Y+1, r13	; 0x01
    1b9c:	c8 82       	st	Y, r12
    1b9e:	c4 5b       	subi	r28, 0xB4	; 180
    1ba0:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:823
  adc_temp = (uint32_t)(((uint32_t)buff[5] << 12) | ((uint32_t)buff[6] << 4) |
                        ((uint32_t)buff[7] >> 4));  // put the 3 bytes of Temperature
  adc_hum =
      (uint16_t)(((uint32_t)buff[8] << 8) | (uint32_t)buff[9]);  // put the 2 bytes of Humidity
  adc_gas_res =
      (uint16_t)((uint32_t)buff[13] << 2 | (((uint32_t)buff[14]) >> 6));  // put the 2 bytes of Gas
    1ba2:	c1 57       	subi	r28, 0x71	; 113
    1ba4:	df 4f       	sbci	r29, 0xFF	; 255
    1ba6:	48 81       	ld	r20, Y
    1ba8:	cf 58       	subi	r28, 0x8F	; 143
    1baa:	d0 40       	sbci	r29, 0x00	; 0
    1bac:	c2 57       	subi	r28, 0x72	; 114
    1bae:	df 4f       	sbci	r29, 0xFF	; 255
    1bb0:	28 81       	ld	r18, Y
    1bb2:	ce 58       	subi	r28, 0x8E	; 142
    1bb4:	d0 40       	sbci	r29, 0x00	; 0
    1bb6:	04 e0       	ldi	r16, 0x04	; 4
    1bb8:	20 9f       	mul	r18, r16
    1bba:	90 01       	movw	r18, r0
    1bbc:	11 24       	eor	r1, r1
    1bbe:	84 2f       	mov	r24, r20
    1bc0:	90 e0       	ldi	r25, 0x00	; 0
    1bc2:	b0 e0       	ldi	r27, 0x00	; 0
    1bc4:	a0 e0       	ldi	r26, 0x00	; 0
    1bc6:	56 e0       	ldi	r21, 0x06	; 6
    1bc8:	b6 95       	lsr	r27
    1bca:	a7 95       	ror	r26
    1bcc:	97 95       	ror	r25
    1bce:	87 95       	ror	r24
    1bd0:	5a 95       	dec	r21
    1bd2:	d1 f7       	brne	.-12     	; 0x1bc8 <main+0xaa6>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:822
                        ((uint32_t)buff[4] >> 4));  // put the 3 bytes of Pressure
  adc_temp = (uint32_t)(((uint32_t)buff[5] << 12) | ((uint32_t)buff[6] << 4) |
                        ((uint32_t)buff[7] >> 4));  // put the 3 bytes of Temperature
  adc_hum =
      (uint16_t)(((uint32_t)buff[8] << 8) | (uint32_t)buff[9]);  // put the 2 bytes of Humidity
  adc_gas_res =
    1bd4:	b9 01       	movw	r22, r18
    1bd6:	68 2b       	or	r22, r24
    1bd8:	79 2b       	or	r23, r25
    1bda:	c3 54       	subi	r28, 0x43	; 67
    1bdc:	df 4f       	sbci	r29, 0xFF	; 255
    1bde:	79 83       	std	Y+1, r23	; 0x01
    1be0:	68 83       	st	Y, r22
    1be2:	cd 5b       	subi	r28, 0xBD	; 189
    1be4:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:824
      (uint16_t)((uint32_t)buff[13] << 2 | (((uint32_t)buff[14]) >> 6));  // put the 2 bytes of Gas
  gas_range = buff[14] & 0X0F;                                            // Retrieve the range
    1be6:	4f 70       	andi	r20, 0x0F	; 15
    1be8:	c1 54       	subi	r28, 0x41	; 65
    1bea:	df 4f       	sbci	r29, 0xFF	; 255
    1bec:	48 83       	st	Y, r20
    1bee:	cf 5b       	subi	r28, 0xBF	; 191
    1bf0:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:818
  uint16_t adc_hum, adc_gas_res;                             // Raw ADC humidity and gas
  if (waitSwitch) waitForReadings();      // Doesn't return until the readings are finished
  getData(BME680_STATUS_REGISTER, buff);  // read all 15 bytes in one go
  adc_pres = (uint32_t)(((uint32_t)buff[2] << 12) | ((uint32_t)buff[3] << 4) |
                        ((uint32_t)buff[4] >> 4));  // put the 3 bytes of Pressure
  adc_temp = (uint32_t)(((uint32_t)buff[5] << 12) | ((uint32_t)buff[6] << 4) |
    1bf2:	ca 57       	subi	r28, 0x7A	; 122
    1bf4:	df 4f       	sbci	r29, 0xFF	; 255
    1bf6:	48 80       	ld	r4, Y
    1bf8:	c6 58       	subi	r28, 0x86	; 134
    1bfa:	d0 40       	sbci	r29, 0x00	; 0
    1bfc:	51 2c       	mov	r5, r1
    1bfe:	71 2c       	mov	r7, r1
    1c00:	61 2c       	mov	r6, r1
    1c02:	6c e0       	ldi	r22, 0x0C	; 12
    1c04:	44 0c       	add	r4, r4
    1c06:	55 1c       	adc	r5, r5
    1c08:	66 1c       	adc	r6, r6
    1c0a:	77 1c       	adc	r7, r7
    1c0c:	6a 95       	dec	r22
    1c0e:	d1 f7       	brne	.-12     	; 0x1c04 <main+0xae2>
    1c10:	c9 57       	subi	r28, 0x79	; 121
    1c12:	df 4f       	sbci	r29, 0xFF	; 255
    1c14:	88 81       	ld	r24, Y
    1c16:	c7 58       	subi	r28, 0x87	; 135
    1c18:	d0 40       	sbci	r29, 0x00	; 0
    1c1a:	90 e0       	ldi	r25, 0x00	; 0
    1c1c:	b0 e0       	ldi	r27, 0x00	; 0
    1c1e:	a0 e0       	ldi	r26, 0x00	; 0
    1c20:	74 e0       	ldi	r23, 0x04	; 4
    1c22:	88 0f       	add	r24, r24
    1c24:	99 1f       	adc	r25, r25
    1c26:	aa 1f       	adc	r26, r26
    1c28:	bb 1f       	adc	r27, r27
    1c2a:	7a 95       	dec	r23
    1c2c:	d1 f7       	brne	.-12     	; 0x1c22 <main+0xb00>
    1c2e:	48 2a       	or	r4, r24
    1c30:	59 2a       	or	r5, r25
    1c32:	6a 2a       	or	r6, r26
    1c34:	7b 2a       	or	r7, r27
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:819
                        ((uint32_t)buff[7] >> 4));  // put the 3 bytes of Temperature
    1c36:	c8 57       	subi	r28, 0x78	; 120
    1c38:	df 4f       	sbci	r29, 0xFF	; 255
    1c3a:	88 81       	ld	r24, Y
    1c3c:	c8 58       	subi	r28, 0x88	; 136
    1c3e:	d0 40       	sbci	r29, 0x00	; 0
    1c40:	90 e0       	ldi	r25, 0x00	; 0
    1c42:	b0 e0       	ldi	r27, 0x00	; 0
    1c44:	a0 e0       	ldi	r26, 0x00	; 0
    1c46:	e4 e0       	ldi	r30, 0x04	; 4
    1c48:	b6 95       	lsr	r27
    1c4a:	a7 95       	ror	r26
    1c4c:	97 95       	ror	r25
    1c4e:	87 95       	ror	r24
    1c50:	ea 95       	dec	r30
    1c52:	d1 f7       	brne	.-12     	; 0x1c48 <main+0xb26>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:818
  uint16_t adc_hum, adc_gas_res;                             // Raw ADC humidity and gas
  if (waitSwitch) waitForReadings();      // Doesn't return until the readings are finished
  getData(BME680_STATUS_REGISTER, buff);  // read all 15 bytes in one go
  adc_pres = (uint32_t)(((uint32_t)buff[2] << 12) | ((uint32_t)buff[3] << 4) |
                        ((uint32_t)buff[4] >> 4));  // put the 3 bytes of Pressure
  adc_temp = (uint32_t)(((uint32_t)buff[5] << 12) | ((uint32_t)buff[6] << 4) |
    1c54:	84 29       	or	r24, r4
    1c56:	95 29       	or	r25, r5
    1c58:	a6 29       	or	r26, r6
    1c5a:	b7 29       	or	r27, r7
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:828
      (uint16_t)((uint32_t)buff[13] << 2 | (((uint32_t)buff[14]) >> 6));  // put the 2 bytes of Gas
  gas_range = buff[14] & 0X0F;                                            // Retrieve the range
                                //*******************************//
                                // First compute the temperature //
                                //*******************************//
  var1         = ((int32_t)adc_temp >> 3) - ((int32_t)_T1 << 1);  // Perform calibration/adjustment
    1c5c:	2c 01       	movw	r4, r24
    1c5e:	3d 01       	movw	r6, r26
    1c60:	f3 e0       	ldi	r31, 0x03	; 3
    1c62:	75 94       	asr	r7
    1c64:	67 94       	ror	r6
    1c66:	57 94       	ror	r5
    1c68:	47 94       	ror	r4
    1c6a:	fa 95       	dec	r31
    1c6c:	d1 f7       	brne	.-12     	; 0x1c62 <main+0xb40>
    1c6e:	80 91 d4 03 	lds	r24, 0x03D4	; 0x8003d4 <BME680+0x31>
    1c72:	90 91 d5 03 	lds	r25, 0x03D5	; 0x8003d5 <BME680+0x32>
    1c76:	b0 e0       	ldi	r27, 0x00	; 0
    1c78:	a0 e0       	ldi	r26, 0x00	; 0
    1c7a:	88 0f       	add	r24, r24
    1c7c:	99 1f       	adc	r25, r25
    1c7e:	aa 1f       	adc	r26, r26
    1c80:	bb 1f       	adc	r27, r27
    1c82:	48 1a       	sub	r4, r24
    1c84:	59 0a       	sbc	r5, r25
    1c86:	6a 0a       	sbc	r6, r26
    1c88:	7b 0a       	sbc	r7, r27
    1c8a:	73 01       	movw	r14, r6
    1c8c:	62 01       	movw	r12, r4
    1c8e:	ff 0c       	add	r15, r15
    1c90:	cc 08       	sbc	r12, r12
    1c92:	dc 2c       	mov	r13, r12
    1c94:	76 01       	movw	r14, r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:830
  var2         = (var1 * (int32_t)_T2) >> 11;                     // of Temperature values according
  var3         = ((var1 >> 1) * (var1 >> 1)) >> 12;               // to formula defined by Bosch
    1c96:	92 01       	movw	r18, r4
    1c98:	a3 01       	movw	r20, r6
    1c9a:	6c 2d       	mov	r22, r12
    1c9c:	7c 2d       	mov	r23, r12
    1c9e:	8c 2d       	mov	r24, r12
    1ca0:	9c 2d       	mov	r25, r12
    1ca2:	01 e0       	ldi	r16, 0x01	; 1
    1ca4:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1ca8:	59 01       	movw	r10, r18
    1caa:	6a 01       	movw	r12, r20
    1cac:	7b 01       	movw	r14, r22
    1cae:	8c 01       	movw	r16, r24
    1cb0:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    1cb4:	0c e0       	ldi	r16, 0x0C	; 12
    1cb6:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:831
  var3         = ((var3) * ((int32_t)_T3 << 4)) >> 14;
    1cba:	e0 90 ca 03 	lds	r14, 0x03CA	; 0x8003ca <BME680+0x27>
    1cbe:	0e 2c       	mov	r0, r14
    1cc0:	00 0c       	add	r0, r0
    1cc2:	ff 08       	sbc	r15, r15
    1cc4:	00 0b       	sbc	r16, r16
    1cc6:	11 0b       	sbc	r17, r17
    1cc8:	e4 e0       	ldi	r30, 0x04	; 4
    1cca:	ee 0c       	add	r14, r14
    1ccc:	ff 1c       	adc	r15, r15
    1cce:	00 1f       	adc	r16, r16
    1cd0:	11 1f       	adc	r17, r17
    1cd2:	ea 95       	dec	r30
    1cd4:	d1 f7       	brne	.-12     	; 0x1cca <main+0xba8>
    1cd6:	57 01       	movw	r10, r14
    1cd8:	68 01       	movw	r12, r16
    1cda:	dd 0c       	add	r13, r13
    1cdc:	aa 08       	sbc	r10, r10
    1cde:	ba 2c       	mov	r11, r10
    1ce0:	65 01       	movw	r12, r10
    1ce2:	cd 56       	subi	r28, 0x6D	; 109
    1ce4:	df 4f       	sbci	r29, 0xFF	; 255
    1ce6:	a8 82       	st	Y, r10
    1ce8:	b9 82       	std	Y+1, r11	; 0x01
    1cea:	ca 82       	std	Y+2, r12	; 0x02
    1cec:	db 82       	std	Y+3, r13	; 0x03
    1cee:	c3 59       	subi	r28, 0x93	; 147
    1cf0:	d0 40       	sbci	r29, 0x00	; 0
    1cf2:	57 01       	movw	r10, r14
    1cf4:	68 01       	movw	r12, r16
    1cf6:	cd 56       	subi	r28, 0x6D	; 109
    1cf8:	df 4f       	sbci	r29, 0xFF	; 255
    1cfa:	e8 80       	ld	r14, Y
    1cfc:	c3 59       	subi	r28, 0x93	; 147
    1cfe:	d0 40       	sbci	r29, 0x00	; 0
    1d00:	fe 2c       	mov	r15, r14
    1d02:	0e 2d       	mov	r16, r14
    1d04:	1e 2d       	mov	r17, r14
    1d06:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    1d0a:	0e e0       	ldi	r16, 0x0E	; 14
    1d0c:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1d10:	49 01       	movw	r8, r18
    1d12:	5a 01       	movw	r10, r20
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:829
  gas_range = buff[14] & 0X0F;                                            // Retrieve the range
                                //*******************************//
                                // First compute the temperature //
                                //*******************************//
  var1         = ((int32_t)adc_temp >> 3) - ((int32_t)_T1 << 1);  // Perform calibration/adjustment
  var2         = (var1 * (int32_t)_T2) >> 11;                     // of Temperature values according
    1d14:	60 91 da 03 	lds	r22, 0x03DA	; 0x8003da <BME680+0x37>
    1d18:	70 91 db 03 	lds	r23, 0x03DB	; 0x8003db <BME680+0x38>
    1d1c:	07 2e       	mov	r0, r23
    1d1e:	00 0c       	add	r0, r0
    1d20:	88 0b       	sbc	r24, r24
    1d22:	99 0b       	sbc	r25, r25
    1d24:	a3 01       	movw	r20, r6
    1d26:	92 01       	movw	r18, r4
    1d28:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    1d2c:	0b e0       	ldi	r16, 0x0B	; 11
    1d2e:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1d32:	cd 56       	subi	r28, 0x6D	; 109
    1d34:	df 4f       	sbci	r29, 0xFF	; 255
    1d36:	28 83       	st	Y, r18
    1d38:	c3 59       	subi	r28, 0x93	; 147
    1d3a:	d0 40       	sbci	r29, 0x00	; 0
    1d3c:	cc 56       	subi	r28, 0x6C	; 108
    1d3e:	df 4f       	sbci	r29, 0xFF	; 255
    1d40:	38 83       	st	Y, r19
    1d42:	c4 59       	subi	r28, 0x94	; 148
    1d44:	d0 40       	sbci	r29, 0x00	; 0
    1d46:	cb 56       	subi	r28, 0x6B	; 107
    1d48:	df 4f       	sbci	r29, 0xFF	; 255
    1d4a:	48 83       	st	Y, r20
    1d4c:	c5 59       	subi	r28, 0x95	; 149
    1d4e:	d0 40       	sbci	r29, 0x00	; 0
    1d50:	ca 56       	subi	r28, 0x6A	; 106
    1d52:	df 4f       	sbci	r29, 0xFF	; 255
    1d54:	58 83       	st	Y, r21
    1d56:	c6 59       	subi	r28, 0x96	; 150
    1d58:	d0 40       	sbci	r29, 0x00	; 0
    1d5a:	c9 56       	subi	r28, 0x69	; 105
    1d5c:	df 4f       	sbci	r29, 0xFF	; 255
    1d5e:	68 83       	st	Y, r22
    1d60:	c7 59       	subi	r28, 0x97	; 151
    1d62:	d0 40       	sbci	r29, 0x00	; 0
    1d64:	c8 56       	subi	r28, 0x68	; 104
    1d66:	df 4f       	sbci	r29, 0xFF	; 255
    1d68:	78 83       	st	Y, r23
    1d6a:	c8 59       	subi	r28, 0x98	; 152
    1d6c:	d0 40       	sbci	r29, 0x00	; 0
    1d6e:	c7 56       	subi	r28, 0x67	; 103
    1d70:	df 4f       	sbci	r29, 0xFF	; 255
    1d72:	88 83       	st	Y, r24
    1d74:	c9 59       	subi	r28, 0x99	; 153
    1d76:	d0 40       	sbci	r29, 0x00	; 0
    1d78:	c6 56       	subi	r28, 0x66	; 102
    1d7a:	df 4f       	sbci	r29, 0xFF	; 255
    1d7c:	98 83       	st	Y, r25
    1d7e:	ca 59       	subi	r28, 0x9A	; 154
    1d80:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:832
  var3         = ((var1 >> 1) * (var1 >> 1)) >> 12;               // to formula defined by Bosch
  var3         = ((var3) * ((int32_t)_T3 << 4)) >> 14;
  _tfine       = (int32_t)(var2 + var3);
    1d82:	cd 56       	subi	r28, 0x6D	; 109
    1d84:	df 4f       	sbci	r29, 0xFF	; 255
    1d86:	08 81       	ld	r16, Y
    1d88:	19 81       	ldd	r17, Y+1	; 0x01
    1d8a:	2a 81       	ldd	r18, Y+2	; 0x02
    1d8c:	3b 81       	ldd	r19, Y+3	; 0x03
    1d8e:	c3 59       	subi	r28, 0x93	; 147
    1d90:	d0 40       	sbci	r29, 0x00	; 0
    1d92:	80 0e       	add	r8, r16
    1d94:	91 1e       	adc	r9, r17
    1d96:	a2 1e       	adc	r10, r18
    1d98:	b3 1e       	adc	r11, r19
    1d9a:	80 92 e6 03 	sts	0x03E6, r8	; 0x8003e6 <BME680+0x43>
    1d9e:	90 92 e7 03 	sts	0x03E7, r9	; 0x8003e7 <BME680+0x44>
    1da2:	a0 92 e8 03 	sts	0x03E8, r10	; 0x8003e8 <BME680+0x45>
    1da6:	b0 92 e9 03 	sts	0x03E9, r11	; 0x8003e9 <BME680+0x46>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:833
  _Temperature = (int16_t)(((_tfine * 5) + 128) >> 8);
    1daa:	a5 e0       	ldi	r26, 0x05	; 5
    1dac:	b0 e0       	ldi	r27, 0x00	; 0
    1dae:	a5 01       	movw	r20, r10
    1db0:	94 01       	movw	r18, r8
    1db2:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
    1db6:	60 58       	subi	r22, 0x80	; 128
    1db8:	7f 4f       	sbci	r23, 0xFF	; 255
    1dba:	8f 4f       	sbci	r24, 0xFF	; 255
    1dbc:	9f 4f       	sbci	r25, 0xFF	; 255
    1dbe:	27 2f       	mov	r18, r23
    1dc0:	38 2f       	mov	r19, r24
    1dc2:	49 2f       	mov	r20, r25
    1dc4:	55 27       	eor	r21, r21
    1dc6:	47 fd       	sbrc	r20, 7
    1dc8:	5a 95       	dec	r21
    1dca:	cd 56       	subi	r28, 0x6D	; 109
    1dcc:	df 4f       	sbci	r29, 0xFF	; 255
    1dce:	28 83       	st	Y, r18
    1dd0:	39 83       	std	Y+1, r19	; 0x01
    1dd2:	4a 83       	std	Y+2, r20	; 0x02
    1dd4:	5b 83       	std	Y+3, r21	; 0x03
    1dd6:	c3 59       	subi	r28, 0x93	; 147
    1dd8:	d0 40       	sbci	r29, 0x00	; 0
    1dda:	c9 01       	movw	r24, r18
    1ddc:	33 0f       	add	r19, r19
    1dde:	aa 0b       	sbc	r26, r26
    1de0:	bb 0b       	sbc	r27, r27
    1de2:	80 93 ea 03 	sts	0x03EA, r24	; 0x8003ea <BME680+0x47>
    1de6:	90 93 eb 03 	sts	0x03EB, r25	; 0x8003eb <BME680+0x48>
    1dea:	a0 93 ec 03 	sts	0x03EC, r26	; 0x8003ec <BME680+0x49>
    1dee:	b0 93 ed 03 	sts	0x03ED, r27	; 0x8003ed <BME680+0x4a>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:837
  //*******************************//
  // Now compute the pressure      //
  //*******************************//
  var1 = (((int32_t)_tfine) >> 1) - 64000;
    1df2:	b5 94       	asr	r11
    1df4:	a7 94       	ror	r10
    1df6:	97 94       	ror	r9
    1df8:	87 94       	ror	r8
    1dfa:	b5 01       	movw	r22, r10
    1dfc:	a4 01       	movw	r20, r8
    1dfe:	5a 5f       	subi	r21, 0xFA	; 250
    1e00:	61 09       	sbc	r22, r1
    1e02:	71 09       	sbc	r23, r1
    1e04:	c5 56       	subi	r28, 0x65	; 101
    1e06:	df 4f       	sbci	r29, 0xFF	; 255
    1e08:	48 83       	st	Y, r20
    1e0a:	59 83       	std	Y+1, r21	; 0x01
    1e0c:	6a 83       	std	Y+2, r22	; 0x02
    1e0e:	7b 83       	std	Y+3, r23	; 0x03
    1e10:	cb 59       	subi	r28, 0x9B	; 155
    1e12:	d0 40       	sbci	r29, 0x00	; 0
    1e14:	6a 01       	movw	r12, r20
    1e16:	7b 01       	movw	r14, r22
    1e18:	ff 0c       	add	r15, r15
    1e1a:	cc 08       	sbc	r12, r12
    1e1c:	dc 2c       	mov	r13, r12
    1e1e:	76 01       	movw	r14, r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:838
  var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)_P6) >> 2;
    1e20:	c5 56       	subi	r28, 0x65	; 101
    1e22:	df 4f       	sbci	r29, 0xFF	; 255
    1e24:	28 81       	ld	r18, Y
    1e26:	cb 59       	subi	r28, 0x9B	; 155
    1e28:	d0 40       	sbci	r29, 0x00	; 0
    1e2a:	c4 56       	subi	r28, 0x64	; 100
    1e2c:	df 4f       	sbci	r29, 0xFF	; 255
    1e2e:	38 81       	ld	r19, Y
    1e30:	cc 59       	subi	r28, 0x9C	; 156
    1e32:	d0 40       	sbci	r29, 0x00	; 0
    1e34:	c3 56       	subi	r28, 0x63	; 99
    1e36:	df 4f       	sbci	r29, 0xFF	; 255
    1e38:	48 81       	ld	r20, Y
    1e3a:	cd 59       	subi	r28, 0x9D	; 157
    1e3c:	d0 40       	sbci	r29, 0x00	; 0
    1e3e:	c2 56       	subi	r28, 0x62	; 98
    1e40:	df 4f       	sbci	r29, 0xFF	; 255
    1e42:	58 81       	ld	r21, Y
    1e44:	ce 59       	subi	r28, 0x9E	; 158
    1e46:	d0 40       	sbci	r29, 0x00	; 0
    1e48:	6c 2d       	mov	r22, r12
    1e4a:	7c 2d       	mov	r23, r12
    1e4c:	8c 2d       	mov	r24, r12
    1e4e:	9c 2d       	mov	r25, r12
    1e50:	02 e0       	ldi	r16, 0x02	; 2
    1e52:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1e56:	59 01       	movw	r10, r18
    1e58:	6a 01       	movw	r12, r20
    1e5a:	7b 01       	movw	r14, r22
    1e5c:	8c 01       	movw	r16, r24
    1e5e:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    1e62:	92 2e       	mov	r9, r18
    1e64:	83 2e       	mov	r8, r19
    1e66:	34 2e       	mov	r3, r20
    1e68:	25 2e       	mov	r2, r21
    1e6a:	c9 55       	subi	r28, 0x59	; 89
    1e6c:	df 4f       	sbci	r29, 0xFF	; 255
    1e6e:	68 83       	st	Y, r22
    1e70:	c7 5a       	subi	r28, 0xA7	; 167
    1e72:	d0 40       	sbci	r29, 0x00	; 0
    1e74:	c5 55       	subi	r28, 0x55	; 85
    1e76:	df 4f       	sbci	r29, 0xFF	; 255
    1e78:	78 83       	st	Y, r23
    1e7a:	cb 5a       	subi	r28, 0xAB	; 171
    1e7c:	d0 40       	sbci	r29, 0x00	; 0
    1e7e:	c4 55       	subi	r28, 0x54	; 84
    1e80:	df 4f       	sbci	r29, 0xFF	; 255
    1e82:	88 83       	st	Y, r24
    1e84:	cc 5a       	subi	r28, 0xAC	; 172
    1e86:	d0 40       	sbci	r29, 0x00	; 0
    1e88:	c3 55       	subi	r28, 0x53	; 83
    1e8a:	df 4f       	sbci	r29, 0xFF	; 255
    1e8c:	98 83       	st	Y, r25
    1e8e:	cd 5a       	subi	r28, 0xAD	; 173
    1e90:	d0 40       	sbci	r29, 0x00	; 0
    1e92:	0b e0       	ldi	r16, 0x0B	; 11
    1e94:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1e98:	a0 90 cc 03 	lds	r10, 0x03CC	; 0x8003cc <BME680+0x29>
    1e9c:	1a 2d       	mov	r17, r10
    1e9e:	11 0f       	add	r17, r17
    1ea0:	11 0b       	sbc	r17, r17
    1ea2:	b1 2e       	mov	r11, r17
    1ea4:	c1 2e       	mov	r12, r17
    1ea6:	d1 2e       	mov	r13, r17
    1ea8:	e1 2e       	mov	r14, r17
    1eaa:	f1 2e       	mov	r15, r17
    1eac:	01 2f       	mov	r16, r17
    1eae:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    1eb2:	02 e0       	ldi	r16, 0x02	; 2
    1eb4:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1eb8:	59 01       	movw	r10, r18
    1eba:	6a 01       	movw	r12, r20
    1ebc:	7b 01       	movw	r14, r22
    1ebe:	78 2e       	mov	r7, r24
    1ec0:	19 2f       	mov	r17, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:839
  var2 = var2 + ((var1 * (int32_t)_P5) << 1);
    1ec2:	60 91 e0 03 	lds	r22, 0x03E0	; 0x8003e0 <BME680+0x3d>
    1ec6:	70 91 e1 03 	lds	r23, 0x03E1	; 0x8003e1 <BME680+0x3e>
    1eca:	07 2e       	mov	r0, r23
    1ecc:	00 0c       	add	r0, r0
    1ece:	88 0b       	sbc	r24, r24
    1ed0:	99 0b       	sbc	r25, r25
    1ed2:	c5 56       	subi	r28, 0x65	; 101
    1ed4:	df 4f       	sbci	r29, 0xFF	; 255
    1ed6:	28 81       	ld	r18, Y
    1ed8:	39 81       	ldd	r19, Y+1	; 0x01
    1eda:	4a 81       	ldd	r20, Y+2	; 0x02
    1edc:	5b 81       	ldd	r21, Y+3	; 0x03
    1ede:	cb 59       	subi	r28, 0x9B	; 155
    1ee0:	d0 40       	sbci	r29, 0x00	; 0
    1ee2:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    1ee6:	01 e0       	ldi	r16, 0x01	; 1
    1ee8:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <__ashldi3>
    1eec:	07 2d       	mov	r16, r7
    1eee:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:840
  var2 = (var2 >> 2) + ((int32_t)_P4 << 16);
    1ef2:	02 e0       	ldi	r16, 0x02	; 2
    1ef4:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1ef8:	ca 54       	subi	r28, 0x4A	; 74
    1efa:	df 4f       	sbci	r29, 0xFF	; 255
    1efc:	28 83       	st	Y, r18
    1efe:	c6 5b       	subi	r28, 0xB6	; 182
    1f00:	d0 40       	sbci	r29, 0x00	; 0
    1f02:	c9 54       	subi	r28, 0x49	; 73
    1f04:	df 4f       	sbci	r29, 0xFF	; 255
    1f06:	38 83       	st	Y, r19
    1f08:	c7 5b       	subi	r28, 0xB7	; 183
    1f0a:	d0 40       	sbci	r29, 0x00	; 0
    1f0c:	c8 54       	subi	r28, 0x48	; 72
    1f0e:	df 4f       	sbci	r29, 0xFF	; 255
    1f10:	48 83       	st	Y, r20
    1f12:	c8 5b       	subi	r28, 0xB8	; 184
    1f14:	d0 40       	sbci	r29, 0x00	; 0
    1f16:	c7 54       	subi	r28, 0x47	; 71
    1f18:	df 4f       	sbci	r29, 0xFF	; 255
    1f1a:	58 83       	st	Y, r21
    1f1c:	c9 5b       	subi	r28, 0xB9	; 185
    1f1e:	d0 40       	sbci	r29, 0x00	; 0
    1f20:	c6 54       	subi	r28, 0x46	; 70
    1f22:	df 4f       	sbci	r29, 0xFF	; 255
    1f24:	68 83       	st	Y, r22
    1f26:	ca 5b       	subi	r28, 0xBA	; 186
    1f28:	d0 40       	sbci	r29, 0x00	; 0
    1f2a:	c5 54       	subi	r28, 0x45	; 69
    1f2c:	df 4f       	sbci	r29, 0xFF	; 255
    1f2e:	78 83       	st	Y, r23
    1f30:	cb 5b       	subi	r28, 0xBB	; 187
    1f32:	d0 40       	sbci	r29, 0x00	; 0
    1f34:	c4 54       	subi	r28, 0x44	; 68
    1f36:	df 4f       	sbci	r29, 0xFF	; 255
    1f38:	88 83       	st	Y, r24
    1f3a:	cc 5b       	subi	r28, 0xBC	; 188
    1f3c:	d0 40       	sbci	r29, 0x00	; 0
    1f3e:	c0 54       	subi	r28, 0x40	; 64
    1f40:	df 4f       	sbci	r29, 0xFF	; 255
    1f42:	98 83       	st	Y, r25
    1f44:	c0 5c       	subi	r28, 0xC0	; 192
    1f46:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:841
  var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)_P3 << 5)) >> 3) +
    1f48:	40 90 cb 03 	lds	r4, 0x03CB	; 0x8003cb <BME680+0x28>
    1f4c:	04 2c       	mov	r0, r4
    1f4e:	00 0c       	add	r0, r0
    1f50:	55 08       	sbc	r5, r5
    1f52:	66 08       	sbc	r6, r6
    1f54:	77 08       	sbc	r7, r7
    1f56:	05 e0       	ldi	r16, 0x05	; 5
    1f58:	44 0c       	add	r4, r4
    1f5a:	55 1c       	adc	r5, r5
    1f5c:	66 1c       	adc	r6, r6
    1f5e:	77 1c       	adc	r7, r7
    1f60:	0a 95       	dec	r16
    1f62:	d1 f7       	brne	.-12     	; 0x1f58 <main+0xe36>
    1f64:	c3 01       	movw	r24, r6
    1f66:	b2 01       	movw	r22, r4
    1f68:	99 0f       	add	r25, r25
    1f6a:	66 0b       	sbc	r22, r22
    1f6c:	76 2f       	mov	r23, r22
    1f6e:	cb 01       	movw	r24, r22
    1f70:	cd 55       	subi	r28, 0x5D	; 93
    1f72:	df 4f       	sbci	r29, 0xFF	; 255
    1f74:	68 83       	st	Y, r22
    1f76:	79 83       	std	Y+1, r23	; 0x01
    1f78:	8a 83       	std	Y+2, r24	; 0x02
    1f7a:	9b 83       	std	Y+3, r25	; 0x03
    1f7c:	c3 5a       	subi	r28, 0xA3	; 163
    1f7e:	d0 40       	sbci	r29, 0x00	; 0
    1f80:	29 2d       	mov	r18, r9
    1f82:	38 2d       	mov	r19, r8
    1f84:	43 2d       	mov	r20, r3
    1f86:	52 2d       	mov	r21, r2
    1f88:	c9 55       	subi	r28, 0x59	; 89
    1f8a:	df 4f       	sbci	r29, 0xFF	; 255
    1f8c:	68 81       	ld	r22, Y
    1f8e:	c7 5a       	subi	r28, 0xA7	; 167
    1f90:	d0 40       	sbci	r29, 0x00	; 0
    1f92:	c5 55       	subi	r28, 0x55	; 85
    1f94:	df 4f       	sbci	r29, 0xFF	; 255
    1f96:	78 81       	ld	r23, Y
    1f98:	cb 5a       	subi	r28, 0xAB	; 171
    1f9a:	d0 40       	sbci	r29, 0x00	; 0
    1f9c:	c4 55       	subi	r28, 0x54	; 84
    1f9e:	df 4f       	sbci	r29, 0xFF	; 255
    1fa0:	88 81       	ld	r24, Y
    1fa2:	cc 5a       	subi	r28, 0xAC	; 172
    1fa4:	d0 40       	sbci	r29, 0x00	; 0
    1fa6:	c3 55       	subi	r28, 0x53	; 83
    1fa8:	df 4f       	sbci	r29, 0xFF	; 255
    1faa:	98 81       	ld	r25, Y
    1fac:	cd 5a       	subi	r28, 0xAD	; 173
    1fae:	d0 40       	sbci	r29, 0x00	; 0
    1fb0:	0d e0       	ldi	r16, 0x0D	; 13
    1fb2:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1fb6:	59 01       	movw	r10, r18
    1fb8:	6a 01       	movw	r12, r20
    1fba:	7b 01       	movw	r14, r22
    1fbc:	8c 01       	movw	r16, r24
    1fbe:	92 01       	movw	r18, r4
    1fc0:	a3 01       	movw	r20, r6
    1fc2:	cd 55       	subi	r28, 0x5D	; 93
    1fc4:	df 4f       	sbci	r29, 0xFF	; 255
    1fc6:	68 81       	ld	r22, Y
    1fc8:	c3 5a       	subi	r28, 0xA3	; 163
    1fca:	d0 40       	sbci	r29, 0x00	; 0
    1fcc:	76 2f       	mov	r23, r22
    1fce:	86 2f       	mov	r24, r22
    1fd0:	96 2f       	mov	r25, r22
    1fd2:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    1fd6:	03 e0       	ldi	r16, 0x03	; 3
    1fd8:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    1fdc:	19 01       	movw	r2, r18
    1fde:	2a 01       	movw	r4, r20
    1fe0:	3b 01       	movw	r6, r22
    1fe2:	4c 01       	movw	r8, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:842
         (((int32_t)_P2 * var1) >> 1);
    1fe4:	60 91 dc 03 	lds	r22, 0x03DC	; 0x8003dc <BME680+0x39>
    1fe8:	70 91 dd 03 	lds	r23, 0x03DD	; 0x8003dd <BME680+0x3a>
    1fec:	07 2e       	mov	r0, r23
    1fee:	00 0c       	add	r0, r0
    1ff0:	88 0b       	sbc	r24, r24
    1ff2:	99 0b       	sbc	r25, r25
    1ff4:	c5 56       	subi	r28, 0x65	; 101
    1ff6:	df 4f       	sbci	r29, 0xFF	; 255
    1ff8:	28 81       	ld	r18, Y
    1ffa:	39 81       	ldd	r19, Y+1	; 0x01
    1ffc:	4a 81       	ldd	r20, Y+2	; 0x02
    1ffe:	5b 81       	ldd	r21, Y+3	; 0x03
    2000:	cb 59       	subi	r28, 0x9B	; 155
    2002:	d0 40       	sbci	r29, 0x00	; 0
    2004:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    2008:	01 e0       	ldi	r16, 0x01	; 1
    200a:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    200e:	59 01       	movw	r10, r18
    2010:	6a 01       	movw	r12, r20
    2012:	7b 01       	movw	r14, r22
    2014:	8c 01       	movw	r16, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:841
  //*******************************//
  var1 = (((int32_t)_tfine) >> 1) - 64000;
  var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)_P6) >> 2;
  var2 = var2 + ((var1 * (int32_t)_P5) << 1);
  var2 = (var2 >> 2) + ((int32_t)_P4 << 16);
  var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)_P3 << 5)) >> 3) +
    2016:	91 01       	movw	r18, r2
    2018:	a2 01       	movw	r20, r4
    201a:	b3 01       	movw	r22, r6
    201c:	c4 01       	movw	r24, r8
    201e:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:843
         (((int32_t)_P2 * var1) >> 1);
  var1      = var1 >> 18;
    2022:	02 e1       	ldi	r16, 0x12	; 18
    2024:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:844
  var1      = ((32768 + var1) * (int32_t)_P1) >> 15;
    2028:	30 58       	subi	r19, 0x80	; 128
    202a:	4f 4f       	sbci	r20, 0xFF	; 255
    202c:	5f 4f       	sbci	r21, 0xFF	; 255
    202e:	6f 4f       	sbci	r22, 0xFF	; 255
    2030:	7f 4f       	sbci	r23, 0xFF	; 255
    2032:	8f 4f       	sbci	r24, 0xFF	; 255
    2034:	9f 4f       	sbci	r25, 0xFF	; 255
    2036:	20 90 d6 03 	lds	r2, 0x03D6	; 0x8003d6 <BME680+0x33>
    203a:	30 90 d7 03 	lds	r3, 0x03D7	; 0x8003d7 <BME680+0x34>
    203e:	51 01       	movw	r10, r2
    2040:	c1 2c       	mov	r12, r1
    2042:	d1 2c       	mov	r13, r1
    2044:	e1 2c       	mov	r14, r1
    2046:	f1 2c       	mov	r15, r1
    2048:	00 e0       	ldi	r16, 0x00	; 0
    204a:	10 e0       	ldi	r17, 0x00	; 0
    204c:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    2050:	29 01       	movw	r4, r18
    2052:	3a 01       	movw	r6, r20
    2054:	4b 01       	movw	r8, r22
    2056:	f8 2f       	mov	r31, r24
    2058:	e9 2f       	mov	r30, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:845
  _Pressure = 1048576 - adc_pres;
    205a:	80 e0       	ldi	r24, 0x00	; 0
    205c:	90 e0       	ldi	r25, 0x00	; 0
    205e:	a0 e1       	ldi	r26, 0x10	; 16
    2060:	b0 e0       	ldi	r27, 0x00	; 0
    2062:	c0 55       	subi	r28, 0x50	; 80
    2064:	df 4f       	sbci	r29, 0xFF	; 255
    2066:	a8 80       	ld	r10, Y
    2068:	b9 80       	ldd	r11, Y+1	; 0x01
    206a:	ca 80       	ldd	r12, Y+2	; 0x02
    206c:	db 80       	ldd	r13, Y+3	; 0x03
    206e:	c0 5b       	subi	r28, 0xB0	; 176
    2070:	d0 40       	sbci	r29, 0x00	; 0
    2072:	8a 19       	sub	r24, r10
    2074:	9b 09       	sbc	r25, r11
    2076:	ac 09       	sbc	r26, r12
    2078:	bd 09       	sbc	r27, r13
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:846
  _Pressure = (int32_t)((_Pressure - (var2 >> 12)) * ((uint32_t)3125));
    207a:	6c 01       	movw	r12, r24
    207c:	7d 01       	movw	r14, r26
    207e:	00 e0       	ldi	r16, 0x00	; 0
    2080:	10 e0       	ldi	r17, 0x00	; 0
    2082:	98 01       	movw	r18, r16
    2084:	c5 56       	subi	r28, 0x65	; 101
    2086:	df 4f       	sbci	r29, 0xFF	; 255
    2088:	88 83       	st	Y, r24
    208a:	cb 59       	subi	r28, 0x9B	; 155
    208c:	d0 40       	sbci	r29, 0x00	; 0
    208e:	c4 56       	subi	r28, 0x64	; 100
    2090:	df 4f       	sbci	r29, 0xFF	; 255
    2092:	d8 82       	st	Y, r13
    2094:	cc 59       	subi	r28, 0x9C	; 156
    2096:	d0 40       	sbci	r29, 0x00	; 0
    2098:	c3 56       	subi	r28, 0x63	; 99
    209a:	df 4f       	sbci	r29, 0xFF	; 255
    209c:	a8 83       	st	Y, r26
    209e:	cd 59       	subi	r28, 0x9D	; 157
    20a0:	d0 40       	sbci	r29, 0x00	; 0
    20a2:	c2 56       	subi	r28, 0x62	; 98
    20a4:	df 4f       	sbci	r29, 0xFF	; 255
    20a6:	f8 82       	st	Y, r15
    20a8:	ce 59       	subi	r28, 0x9E	; 158
    20aa:	d0 40       	sbci	r29, 0x00	; 0
    20ac:	c1 56       	subi	r28, 0x61	; 97
    20ae:	df 4f       	sbci	r29, 0xFF	; 255
    20b0:	08 83       	st	Y, r16
    20b2:	cf 59       	subi	r28, 0x9F	; 159
    20b4:	d0 40       	sbci	r29, 0x00	; 0
    20b6:	c0 56       	subi	r28, 0x60	; 96
    20b8:	df 4f       	sbci	r29, 0xFF	; 255
    20ba:	18 83       	st	Y, r17
    20bc:	c0 5a       	subi	r28, 0xA0	; 160
    20be:	d0 40       	sbci	r29, 0x00	; 0
    20c0:	cf 55       	subi	r28, 0x5F	; 95
    20c2:	df 4f       	sbci	r29, 0xFF	; 255
    20c4:	28 83       	st	Y, r18
    20c6:	c1 5a       	subi	r28, 0xA1	; 161
    20c8:	d0 40       	sbci	r29, 0x00	; 0
    20ca:	ce 55       	subi	r28, 0x5E	; 94
    20cc:	df 4f       	sbci	r29, 0xFF	; 255
    20ce:	38 83       	st	Y, r19
    20d0:	c2 5a       	subi	r28, 0xA2	; 162
    20d2:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:840
  // Now compute the pressure      //
  //*******************************//
  var1 = (((int32_t)_tfine) >> 1) - 64000;
  var2 = ((((var1 >> 2) * (var1 >> 2)) >> 11) * (int32_t)_P6) >> 2;
  var2 = var2 + ((var1 * (int32_t)_P5) << 1);
  var2 = (var2 >> 2) + ((int32_t)_P4 << 16);
    20d4:	80 91 de 03 	lds	r24, 0x03DE	; 0x8003de <BME680+0x3b>
    20d8:	90 91 df 03 	lds	r25, 0x03DF	; 0x8003df <BME680+0x3c>
    20dc:	09 2e       	mov	r0, r25
    20de:	00 0c       	add	r0, r0
    20e0:	aa 0b       	sbc	r26, r26
    20e2:	bb 0b       	sbc	r27, r27
    20e4:	dc 01       	movw	r26, r24
    20e6:	99 27       	eor	r25, r25
    20e8:	88 27       	eor	r24, r24
    20ea:	6c 01       	movw	r12, r24
    20ec:	7d 01       	movw	r14, r26
    20ee:	ff 0c       	add	r15, r15
    20f0:	cc 08       	sbc	r12, r12
    20f2:	dc 2c       	mov	r13, r12
    20f4:	76 01       	movw	r14, r12
    20f6:	9c 01       	movw	r18, r24
    20f8:	ad 01       	movw	r20, r26
    20fa:	6c 2d       	mov	r22, r12
    20fc:	7c 2d       	mov	r23, r12
    20fe:	8c 2d       	mov	r24, r12
    2100:	9c 2d       	mov	r25, r12
    2102:	ca 54       	subi	r28, 0x4A	; 74
    2104:	df 4f       	sbci	r29, 0xFF	; 255
    2106:	a8 80       	ld	r10, Y
    2108:	c6 5b       	subi	r28, 0xB6	; 182
    210a:	d0 40       	sbci	r29, 0x00	; 0
    210c:	c9 54       	subi	r28, 0x49	; 73
    210e:	df 4f       	sbci	r29, 0xFF	; 255
    2110:	b8 80       	ld	r11, Y
    2112:	c7 5b       	subi	r28, 0xB7	; 183
    2114:	d0 40       	sbci	r29, 0x00	; 0
    2116:	c8 54       	subi	r28, 0x48	; 72
    2118:	df 4f       	sbci	r29, 0xFF	; 255
    211a:	c8 80       	ld	r12, Y
    211c:	c8 5b       	subi	r28, 0xB8	; 184
    211e:	d0 40       	sbci	r29, 0x00	; 0
    2120:	c7 54       	subi	r28, 0x47	; 71
    2122:	df 4f       	sbci	r29, 0xFF	; 255
    2124:	d8 80       	ld	r13, Y
    2126:	c9 5b       	subi	r28, 0xB9	; 185
    2128:	d0 40       	sbci	r29, 0x00	; 0
    212a:	c6 54       	subi	r28, 0x46	; 70
    212c:	df 4f       	sbci	r29, 0xFF	; 255
    212e:	e8 80       	ld	r14, Y
    2130:	ca 5b       	subi	r28, 0xBA	; 186
    2132:	d0 40       	sbci	r29, 0x00	; 0
    2134:	c5 54       	subi	r28, 0x45	; 69
    2136:	df 4f       	sbci	r29, 0xFF	; 255
    2138:	f8 80       	ld	r15, Y
    213a:	cb 5b       	subi	r28, 0xBB	; 187
    213c:	d0 40       	sbci	r29, 0x00	; 0
    213e:	c4 54       	subi	r28, 0x44	; 68
    2140:	df 4f       	sbci	r29, 0xFF	; 255
    2142:	08 81       	ld	r16, Y
    2144:	cc 5b       	subi	r28, 0xBC	; 188
    2146:	d0 40       	sbci	r29, 0x00	; 0
    2148:	c0 54       	subi	r28, 0x40	; 64
    214a:	df 4f       	sbci	r29, 0xFF	; 255
    214c:	18 81       	ld	r17, Y
    214e:	c0 5c       	subi	r28, 0xC0	; 192
    2150:	d0 40       	sbci	r29, 0x00	; 0
    2152:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:846
  var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)_P3 << 5)) >> 3) +
         (((int32_t)_P2 * var1) >> 1);
  var1      = var1 >> 18;
  var1      = ((32768 + var1) * (int32_t)_P1) >> 15;
  _Pressure = 1048576 - adc_pres;
  _Pressure = (int32_t)((_Pressure - (var2 >> 12)) * ((uint32_t)3125));
    2156:	0c e0       	ldi	r16, 0x0C	; 12
    2158:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    215c:	59 01       	movw	r10, r18
    215e:	6a 01       	movw	r12, r20
    2160:	7b 01       	movw	r14, r22
    2162:	8c 01       	movw	r16, r24
    2164:	c5 56       	subi	r28, 0x65	; 101
    2166:	df 4f       	sbci	r29, 0xFF	; 255
    2168:	28 81       	ld	r18, Y
    216a:	cb 59       	subi	r28, 0x9B	; 155
    216c:	d0 40       	sbci	r29, 0x00	; 0
    216e:	c4 56       	subi	r28, 0x64	; 100
    2170:	df 4f       	sbci	r29, 0xFF	; 255
    2172:	38 81       	ld	r19, Y
    2174:	cc 59       	subi	r28, 0x9C	; 156
    2176:	d0 40       	sbci	r29, 0x00	; 0
    2178:	c3 56       	subi	r28, 0x63	; 99
    217a:	df 4f       	sbci	r29, 0xFF	; 255
    217c:	48 81       	ld	r20, Y
    217e:	cd 59       	subi	r28, 0x9D	; 157
    2180:	d0 40       	sbci	r29, 0x00	; 0
    2182:	c2 56       	subi	r28, 0x62	; 98
    2184:	df 4f       	sbci	r29, 0xFF	; 255
    2186:	58 81       	ld	r21, Y
    2188:	ce 59       	subi	r28, 0x9E	; 158
    218a:	d0 40       	sbci	r29, 0x00	; 0
    218c:	60 e0       	ldi	r22, 0x00	; 0
    218e:	70 e0       	ldi	r23, 0x00	; 0
    2190:	80 e0       	ldi	r24, 0x00	; 0
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__subdi3>
    2198:	a5 e3       	ldi	r26, 0x35	; 53
    219a:	bc e0       	ldi	r27, 0x0C	; 12
    219c:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
    21a0:	6b 01       	movw	r12, r22
    21a2:	7c 01       	movw	r14, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:844
  var2 = var2 + ((var1 * (int32_t)_P5) << 1);
  var2 = (var2 >> 2) + ((int32_t)_P4 << 16);
  var1 = (((((var1 >> 2) * (var1 >> 2)) >> 13) * ((int32_t)_P3 << 5)) >> 3) +
         (((int32_t)_P2 * var1) >> 1);
  var1      = var1 >> 18;
  var1      = ((32768 + var1) * (int32_t)_P1) >> 15;
    21a4:	92 01       	movw	r18, r4
    21a6:	a3 01       	movw	r20, r6
    21a8:	b4 01       	movw	r22, r8
    21aa:	8f 2f       	mov	r24, r31
    21ac:	9e 2f       	mov	r25, r30
    21ae:	0f e0       	ldi	r16, 0x0F	; 15
    21b0:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:849
  _Pressure = 1048576 - adc_pres;
  _Pressure = (int32_t)((_Pressure - (var2 >> 12)) * ((uint32_t)3125));

  if (_Pressure >= INT32_C(0x40000000))  // Issue #26
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
    21b4:	c7 01       	movw	r24, r14
    21b6:	b6 01       	movw	r22, r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:848
  var1      = var1 >> 18;
  var1      = ((32768 + var1) * (int32_t)_P1) >> 15;
  _Pressure = 1048576 - adc_pres;
  _Pressure = (int32_t)((_Pressure - (var2 >> 12)) * ((uint32_t)3125));

  if (_Pressure >= INT32_C(0x40000000))  // Issue #26
    21b8:	c1 14       	cp	r12, r1
    21ba:	d1 04       	cpc	r13, r1
    21bc:	e1 04       	cpc	r14, r1
    21be:	00 e4       	ldi	r16, 0x40	; 64
    21c0:	f0 06       	cpc	r15, r16
    21c2:	0c f4       	brge	.+2      	; 0x21c6 <main+0x10a4>
    21c4:	ea c5       	rjmp	.+3028   	; 0x2d9a <main+0x1c78>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:849
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
    21c6:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <__udivmodsi4>
    21ca:	22 0f       	add	r18, r18
    21cc:	33 1f       	adc	r19, r19
    21ce:	44 1f       	adc	r20, r20
    21d0:	55 1f       	adc	r21, r21
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:851
  else
    _Pressure = ((_Pressure << 1) / (uint32_t)var1);
    21d2:	20 93 ee 03 	sts	0x03EE, r18	; 0x8003ee <BME680+0x4b>
    21d6:	30 93 ef 03 	sts	0x03EF, r19	; 0x8003ef <BME680+0x4c>
    21da:	40 93 f0 03 	sts	0x03F0, r20	; 0x8003f0 <BME680+0x4d>
    21de:	50 93 f1 03 	sts	0x03F1, r21	; 0x8003f1 <BME680+0x4e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:852
  var1 = ((int32_t)_P9 * (int32_t)(((_Pressure >> 3) * (_Pressure >> 3)) >> 13)) >> 12;
    21e2:	20 91 ee 03 	lds	r18, 0x03EE	; 0x8003ee <BME680+0x4b>
    21e6:	30 91 ef 03 	lds	r19, 0x03EF	; 0x8003ef <BME680+0x4c>
    21ea:	40 91 f0 03 	lds	r20, 0x03F0	; 0x8003f0 <BME680+0x4d>
    21ee:	50 91 f1 03 	lds	r21, 0x03F1	; 0x8003f1 <BME680+0x4e>
    21f2:	c5 56       	subi	r28, 0x65	; 101
    21f4:	df 4f       	sbci	r29, 0xFF	; 255
    21f6:	28 83       	st	Y, r18
    21f8:	39 83       	std	Y+1, r19	; 0x01
    21fa:	4a 83       	std	Y+2, r20	; 0x02
    21fc:	5b 83       	std	Y+3, r21	; 0x03
    21fe:	cb 59       	subi	r28, 0x9B	; 155
    2200:	d0 40       	sbci	r29, 0x00	; 0
    2202:	ca 01       	movw	r24, r20
    2204:	b9 01       	movw	r22, r18
    2206:	e3 e0       	ldi	r30, 0x03	; 3
    2208:	95 95       	asr	r25
    220a:	87 95       	ror	r24
    220c:	77 95       	ror	r23
    220e:	67 95       	ror	r22
    2210:	ea 95       	dec	r30
    2212:	d1 f7       	brne	.-12     	; 0x2208 <main+0x10e6>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:854
  var2 = ((int32_t)(_Pressure >> 2) * (int32_t)_P8) >> 13;
  var3 = ((int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) *
    2214:	43 2e       	mov	r4, r19
    2216:	54 2e       	mov	r5, r20
    2218:	65 2e       	mov	r6, r21
    221a:	77 24       	eor	r7, r7
    221c:	67 fc       	sbrc	r6, 7
    221e:	7a 94       	dec	r7
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:852

  if (_Pressure >= INT32_C(0x40000000))  // Issue #26
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
  else
    _Pressure = ((_Pressure << 1) / (uint32_t)var1);
  var1 = ((int32_t)_P9 * (int32_t)(((_Pressure >> 3) * (_Pressure >> 3)) >> 13)) >> 12;
    2220:	9b 01       	movw	r18, r22
    2222:	ac 01       	movw	r20, r24
    2224:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__mulsi3>
    2228:	9b 01       	movw	r18, r22
    222a:	ac 01       	movw	r20, r24
    222c:	ad e0       	ldi	r26, 0x0D	; 13
    222e:	55 95       	asr	r21
    2230:	47 95       	ror	r20
    2232:	37 95       	ror	r19
    2234:	27 95       	ror	r18
    2236:	aa 95       	dec	r26
    2238:	d1 f7       	brne	.-12     	; 0x222e <main+0x110c>
    223a:	a0 91 e4 03 	lds	r26, 0x03E4	; 0x8003e4 <BME680+0x41>
    223e:	b0 91 e5 03 	lds	r27, 0x03E5	; 0x8003e5 <BME680+0x42>
    2242:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <__mulshisi3>
    2246:	4b 01       	movw	r8, r22
    2248:	5c 01       	movw	r10, r24
    224a:	bc e0       	ldi	r27, 0x0C	; 12
    224c:	b5 94       	asr	r11
    224e:	a7 94       	ror	r10
    2250:	97 94       	ror	r9
    2252:	87 94       	ror	r8
    2254:	ba 95       	dec	r27
    2256:	d1 f7       	brne	.-12     	; 0x224c <main+0x112a>
    2258:	6b 01       	movw	r12, r22
    225a:	7c 01       	movw	r14, r24
    225c:	ff 0c       	add	r15, r15
    225e:	cc 08       	sbc	r12, r12
    2260:	dc 2c       	mov	r13, r12
    2262:	76 01       	movw	r14, r12
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:853
  var2 = ((int32_t)(_Pressure >> 2) * (int32_t)_P8) >> 13;
    2264:	c5 56       	subi	r28, 0x65	; 101
    2266:	df 4f       	sbci	r29, 0xFF	; 255
    2268:	28 81       	ld	r18, Y
    226a:	39 81       	ldd	r19, Y+1	; 0x01
    226c:	4a 81       	ldd	r20, Y+2	; 0x02
    226e:	5b 81       	ldd	r21, Y+3	; 0x03
    2270:	cb 59       	subi	r28, 0x9B	; 155
    2272:	d0 40       	sbci	r29, 0x00	; 0
    2274:	02 e0       	ldi	r16, 0x02	; 2
    2276:	55 95       	asr	r21
    2278:	47 95       	ror	r20
    227a:	37 95       	ror	r19
    227c:	27 95       	ror	r18
    227e:	0a 95       	dec	r16
    2280:	d1 f7       	brne	.-12     	; 0x2276 <main+0x1154>
    2282:	a0 91 e2 03 	lds	r26, 0x03E2	; 0x8003e2 <BME680+0x3f>
    2286:	b0 91 e3 03 	lds	r27, 0x03E3	; 0x8003e3 <BME680+0x40>
    228a:	0e 94 bd 1d 	call	0x3b7a	; 0x3b7a <__mulshisi3>
    228e:	8b 01       	movw	r16, r22
    2290:	9c 01       	movw	r18, r24
    2292:	4d e0       	ldi	r20, 0x0D	; 13
    2294:	35 95       	asr	r19
    2296:	27 95       	ror	r18
    2298:	17 95       	ror	r17
    229a:	07 95       	ror	r16
    229c:	4a 95       	dec	r20
    229e:	d1 f7       	brne	.-12     	; 0x2294 <main+0x1172>
    22a0:	cd 55       	subi	r28, 0x5D	; 93
    22a2:	df 4f       	sbci	r29, 0xFF	; 255
    22a4:	08 83       	st	Y, r16
    22a6:	19 83       	std	Y+1, r17	; 0x01
    22a8:	2a 83       	std	Y+2, r18	; 0x02
    22aa:	3b 83       	std	Y+3, r19	; 0x03
    22ac:	c3 5a       	subi	r28, 0xA3	; 163
    22ae:	d0 40       	sbci	r29, 0x00	; 0
    22b0:	9b 01       	movw	r18, r22
    22b2:	ac 01       	movw	r20, r24
    22b4:	55 0f       	add	r21, r21
    22b6:	22 0b       	sbc	r18, r18
    22b8:	32 2f       	mov	r19, r18
    22ba:	a9 01       	movw	r20, r18
    22bc:	c9 55       	subi	r28, 0x59	; 89
    22be:	df 4f       	sbci	r29, 0xFF	; 255
    22c0:	28 83       	st	Y, r18
    22c2:	39 83       	std	Y+1, r19	; 0x01
    22c4:	4a 83       	std	Y+2, r20	; 0x02
    22c6:	5b 83       	std	Y+3, r21	; 0x03
    22c8:	c7 5a       	subi	r28, 0xA7	; 167
    22ca:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:857
  var3 = ((int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) *
          (int32_t)_P10) >>
         17;
  _Pressure = (int32_t)(_Pressure) + ((var1 + var2 + var3 + ((int32_t)_P7 << 7)) >> 4);
    22cc:	94 01       	movw	r18, r8
    22ce:	a5 01       	movw	r20, r10
    22d0:	6c 2d       	mov	r22, r12
    22d2:	7c 2d       	mov	r23, r12
    22d4:	8c 2d       	mov	r24, r12
    22d6:	9c 2d       	mov	r25, r12
    22d8:	cd 55       	subi	r28, 0x5D	; 93
    22da:	df 4f       	sbci	r29, 0xFF	; 255
    22dc:	a8 80       	ld	r10, Y
    22de:	c3 5a       	subi	r28, 0xA3	; 163
    22e0:	d0 40       	sbci	r29, 0x00	; 0
    22e2:	cc 55       	subi	r28, 0x5C	; 92
    22e4:	df 4f       	sbci	r29, 0xFF	; 255
    22e6:	b8 80       	ld	r11, Y
    22e8:	c4 5a       	subi	r28, 0xA4	; 164
    22ea:	d0 40       	sbci	r29, 0x00	; 0
    22ec:	cb 55       	subi	r28, 0x5B	; 91
    22ee:	df 4f       	sbci	r29, 0xFF	; 255
    22f0:	c8 80       	ld	r12, Y
    22f2:	c5 5a       	subi	r28, 0xA5	; 165
    22f4:	d0 40       	sbci	r29, 0x00	; 0
    22f6:	ca 55       	subi	r28, 0x5A	; 90
    22f8:	df 4f       	sbci	r29, 0xFF	; 255
    22fa:	d8 80       	ld	r13, Y
    22fc:	c6 5a       	subi	r28, 0xA6	; 166
    22fe:	d0 40       	sbci	r29, 0x00	; 0
    2300:	c9 55       	subi	r28, 0x59	; 89
    2302:	df 4f       	sbci	r29, 0xFF	; 255
    2304:	e8 80       	ld	r14, Y
    2306:	c7 5a       	subi	r28, 0xA7	; 167
    2308:	d0 40       	sbci	r29, 0x00	; 0
    230a:	fe 2c       	mov	r15, r14
    230c:	0e 2d       	mov	r16, r14
    230e:	1e 2d       	mov	r17, r14
    2310:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2314:	b2 2e       	mov	r11, r18
    2316:	c3 2e       	mov	r12, r19
    2318:	d4 2e       	mov	r13, r20
    231a:	85 2e       	mov	r8, r21
    231c:	96 2e       	mov	r9, r22
    231e:	f7 2f       	mov	r31, r23
    2320:	e8 2f       	mov	r30, r24
    2322:	a9 2e       	mov	r10, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:854
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
  else
    _Pressure = ((_Pressure << 1) / (uint32_t)var1);
  var1 = ((int32_t)_P9 * (int32_t)(((_Pressure >> 3) * (_Pressure >> 3)) >> 13)) >> 12;
  var2 = ((int32_t)(_Pressure >> 2) * (int32_t)_P8) >> 13;
  var3 = ((int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) *
    2324:	a3 01       	movw	r20, r6
    2326:	92 01       	movw	r18, r4
    2328:	c3 01       	movw	r24, r6
    232a:	b2 01       	movw	r22, r4
    232c:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__mulsi3>
    2330:	9b 01       	movw	r18, r22
    2332:	ac 01       	movw	r20, r24
    2334:	c3 01       	movw	r24, r6
    2336:	b2 01       	movw	r22, r4
    2338:	0e 94 4c 1d 	call	0x3a98	; 0x3a98 <__mulsi3>
    233c:	9b 01       	movw	r18, r22
    233e:	ac 01       	movw	r20, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:855
          (int32_t)_P10) >>
    2340:	a0 91 c2 03 	lds	r26, 0x03C2	; 0x8003c2 <BME680+0x1f>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:854
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
  else
    _Pressure = ((_Pressure << 1) / (uint32_t)var1);
  var1 = ((int32_t)_P9 * (int32_t)(((_Pressure >> 3) * (_Pressure >> 3)) >> 13)) >> 12;
  var2 = ((int32_t)(_Pressure >> 2) * (int32_t)_P8) >> 13;
  var3 = ((int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) * (int32_t)(_Pressure >> 8) *
    2344:	b0 e0       	ldi	r27, 0x00	; 0
    2346:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:855
          (int32_t)_P10) >>
    234a:	7b 01       	movw	r14, r22
    234c:	8c 01       	movw	r16, r24
    234e:	a1 e1       	ldi	r26, 0x11	; 17
    2350:	15 95       	asr	r17
    2352:	07 95       	ror	r16
    2354:	f7 94       	ror	r15
    2356:	e7 94       	ror	r14
    2358:	aa 95       	dec	r26
    235a:	d1 f7       	brne	.-12     	; 0x2350 <main+0x122e>
    235c:	2b 01       	movw	r4, r22
    235e:	3c 01       	movw	r6, r24
    2360:	77 0c       	add	r7, r7
    2362:	44 08       	sbc	r4, r4
    2364:	54 2c       	mov	r5, r4
    2366:	32 01       	movw	r6, r4
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:857
         17;
  _Pressure = (int32_t)(_Pressure) + ((var1 + var2 + var3 + ((int32_t)_P7 << 7)) >> 4);
    2368:	2b 2d       	mov	r18, r11
    236a:	3c 2d       	mov	r19, r12
    236c:	4d 2d       	mov	r20, r13
    236e:	58 2d       	mov	r21, r8
    2370:	69 2d       	mov	r22, r9
    2372:	7f 2f       	mov	r23, r31
    2374:	8e 2f       	mov	r24, r30
    2376:	9a 2d       	mov	r25, r10
    2378:	57 01       	movw	r10, r14
    237a:	68 01       	movw	r12, r16
    237c:	e4 2c       	mov	r14, r4
    237e:	f4 2c       	mov	r15, r4
    2380:	04 2d       	mov	r16, r4
    2382:	14 2d       	mov	r17, r4
    2384:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2388:	e0 90 cd 03 	lds	r14, 0x03CD	; 0x8003cd <BME680+0x2a>
    238c:	0e 2c       	mov	r0, r14
    238e:	00 0c       	add	r0, r0
    2390:	ff 08       	sbc	r15, r15
    2392:	00 0b       	sbc	r16, r16
    2394:	11 0b       	sbc	r17, r17
    2396:	e7 e0       	ldi	r30, 0x07	; 7
    2398:	ee 0c       	add	r14, r14
    239a:	ff 1c       	adc	r15, r15
    239c:	00 1f       	adc	r16, r16
    239e:	11 1f       	adc	r17, r17
    23a0:	ea 95       	dec	r30
    23a2:	d1 f7       	brne	.-12     	; 0x2398 <main+0x1276>
    23a4:	27 01       	movw	r4, r14
    23a6:	38 01       	movw	r6, r16
    23a8:	77 0c       	add	r7, r7
    23aa:	44 08       	sbc	r4, r4
    23ac:	54 2c       	mov	r5, r4
    23ae:	32 01       	movw	r6, r4
    23b0:	57 01       	movw	r10, r14
    23b2:	68 01       	movw	r12, r16
    23b4:	e4 2c       	mov	r14, r4
    23b6:	f4 2c       	mov	r15, r4
    23b8:	04 2d       	mov	r16, r4
    23ba:	14 2d       	mov	r17, r4
    23bc:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    23c0:	04 e0       	ldi	r16, 0x04	; 4
    23c2:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    23c6:	49 01       	movw	r8, r18
    23c8:	5a 01       	movw	r10, r20
    23ca:	c5 56       	subi	r28, 0x65	; 101
    23cc:	df 4f       	sbci	r29, 0xFF	; 255
    23ce:	48 81       	ld	r20, Y
    23d0:	59 81       	ldd	r21, Y+1	; 0x01
    23d2:	6a 81       	ldd	r22, Y+2	; 0x02
    23d4:	7b 81       	ldd	r23, Y+3	; 0x03
    23d6:	cb 59       	subi	r28, 0x9B	; 155
    23d8:	d0 40       	sbci	r29, 0x00	; 0
    23da:	84 0e       	add	r8, r20
    23dc:	95 1e       	adc	r9, r21
    23de:	a6 1e       	adc	r10, r22
    23e0:	b7 1e       	adc	r11, r23
    23e2:	80 92 ee 03 	sts	0x03EE, r8	; 0x8003ee <BME680+0x4b>
    23e6:	90 92 ef 03 	sts	0x03EF, r9	; 0x8003ef <BME680+0x4c>
    23ea:	a0 92 f0 03 	sts	0x03F0, r10	; 0x8003f0 <BME680+0x4d>
    23ee:	b0 92 f1 03 	sts	0x03F1, r11	; 0x8003f1 <BME680+0x4e>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:867
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
  var2 =
      ((int32_t)_H2 *
       (((temp_scaled * (int32_t)_H4) / ((int32_t)100)) +
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
    23f2:	60 91 c6 03 	lds	r22, 0x03C6	; 0x8003c6 <BME680+0x23>
    23f6:	06 2e       	mov	r0, r22
    23f8:	00 0c       	add	r0, r0
    23fa:	77 0b       	sbc	r23, r23
    23fc:	88 0b       	sbc	r24, r24
    23fe:	99 0b       	sbc	r25, r25
    2400:	cd 56       	subi	r28, 0x6D	; 109
    2402:	df 4f       	sbci	r29, 0xFF	; 255
    2404:	28 81       	ld	r18, Y
    2406:	39 81       	ldd	r19, Y+1	; 0x01
    2408:	4a 81       	ldd	r20, Y+2	; 0x02
    240a:	5b 81       	ldd	r21, Y+3	; 0x03
    240c:	c3 59       	subi	r28, 0x93	; 147
    240e:	d0 40       	sbci	r29, 0x00	; 0
    2410:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    2414:	a4 e6       	ldi	r26, 0x64	; 100
    2416:	aa 2e       	mov	r10, r26
    2418:	b1 2c       	mov	r11, r1
    241a:	c1 2c       	mov	r12, r1
    241c:	d1 2c       	mov	r13, r1
    241e:	e1 2c       	mov	r14, r1
    2420:	f1 2c       	mov	r15, r1
    2422:	00 e0       	ldi	r16, 0x00	; 0
    2424:	10 e0       	ldi	r17, 0x00	; 0
    2426:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:861
         17;
  _Pressure = (int32_t)(_Pressure) + ((var1 + var2 + var3 + ((int32_t)_P7 << 7)) >> 4);
  //**********************//
  // Compute the humidity //
  //**********************//
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
    242a:	cd 56       	subi	r28, 0x6D	; 109
    242c:	df 4f       	sbci	r29, 0xFF	; 255
    242e:	48 80       	ld	r4, Y
    2430:	59 80       	ldd	r5, Y+1	; 0x01
    2432:	6a 80       	ldd	r6, Y+2	; 0x02
    2434:	7b 80       	ldd	r7, Y+3	; 0x03
    2436:	c3 59       	subi	r28, 0x93	; 147
    2438:	d0 40       	sbci	r29, 0x00	; 0
    243a:	77 0c       	add	r7, r7
    243c:	44 08       	sbc	r4, r4
    243e:	54 2c       	mov	r5, r4
    2440:	32 01       	movw	r6, r4
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:867
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
  var2 =
      ((int32_t)_H2 *
       (((temp_scaled * (int32_t)_H4) / ((int32_t)100)) +
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
    2442:	cd 56       	subi	r28, 0x6D	; 109
    2444:	df 4f       	sbci	r29, 0xFF	; 255
    2446:	a8 80       	ld	r10, Y
    2448:	c3 59       	subi	r28, 0x93	; 147
    244a:	d0 40       	sbci	r29, 0x00	; 0
    244c:	cc 56       	subi	r28, 0x6C	; 108
    244e:	df 4f       	sbci	r29, 0xFF	; 255
    2450:	b8 80       	ld	r11, Y
    2452:	c4 59       	subi	r28, 0x94	; 148
    2454:	d0 40       	sbci	r29, 0x00	; 0
    2456:	cb 56       	subi	r28, 0x6B	; 107
    2458:	df 4f       	sbci	r29, 0xFF	; 255
    245a:	c8 80       	ld	r12, Y
    245c:	c5 59       	subi	r28, 0x95	; 149
    245e:	d0 40       	sbci	r29, 0x00	; 0
    2460:	ca 56       	subi	r28, 0x6A	; 106
    2462:	df 4f       	sbci	r29, 0xFF	; 255
    2464:	d8 80       	ld	r13, Y
    2466:	c6 59       	subi	r28, 0x96	; 150
    2468:	d0 40       	sbci	r29, 0x00	; 0
    246a:	e4 2c       	mov	r14, r4
    246c:	f4 2c       	mov	r15, r4
    246e:	04 2d       	mov	r16, r4
    2470:	14 2d       	mov	r17, r4
    2472:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    2476:	06 e0       	ldi	r16, 0x06	; 6
    2478:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    247c:	14 e6       	ldi	r17, 0x64	; 100
    247e:	a1 2e       	mov	r10, r17
    2480:	b1 2c       	mov	r11, r1
    2482:	c1 2c       	mov	r12, r1
    2484:	d1 2c       	mov	r13, r1
    2486:	e1 2c       	mov	r14, r1
    2488:	f1 2c       	mov	r15, r1
    248a:	00 e0       	ldi	r16, 0x00	; 0
    248c:	10 e0       	ldi	r17, 0x00	; 0
    248e:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
    2492:	32 2e       	mov	r3, r18
    2494:	43 2e       	mov	r4, r19
    2496:	54 2e       	mov	r5, r20
    2498:	65 2e       	mov	r6, r21
    249a:	76 2e       	mov	r7, r22
    249c:	87 2e       	mov	r8, r23
    249e:	98 2e       	mov	r9, r24
    24a0:	29 2e       	mov	r2, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:866
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
  var2 =
      ((int32_t)_H2 *
       (((temp_scaled * (int32_t)_H4) / ((int32_t)100)) +
    24a2:	60 91 c5 03 	lds	r22, 0x03C5	; 0x8003c5 <BME680+0x22>
    24a6:	06 2e       	mov	r0, r22
    24a8:	00 0c       	add	r0, r0
    24aa:	77 0b       	sbc	r23, r23
    24ac:	88 0b       	sbc	r24, r24
    24ae:	99 0b       	sbc	r25, r25
    24b0:	cd 56       	subi	r28, 0x6D	; 109
    24b2:	df 4f       	sbci	r29, 0xFF	; 255
    24b4:	28 81       	ld	r18, Y
    24b6:	39 81       	ldd	r19, Y+1	; 0x01
    24b8:	4a 81       	ldd	r20, Y+2	; 0x02
    24ba:	5b 81       	ldd	r21, Y+3	; 0x03
    24bc:	c3 59       	subi	r28, 0x93	; 147
    24be:	d0 40       	sbci	r29, 0x00	; 0
    24c0:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    24c4:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
    24c8:	59 01       	movw	r10, r18
    24ca:	6a 01       	movw	r12, r20
    24cc:	7b 01       	movw	r14, r22
    24ce:	8c 01       	movw	r16, r24
    24d0:	23 2d       	mov	r18, r3
    24d2:	34 2d       	mov	r19, r4
    24d4:	45 2d       	mov	r20, r5
    24d6:	56 2d       	mov	r21, r6
    24d8:	67 2d       	mov	r22, r7
    24da:	78 2d       	mov	r23, r8
    24dc:	89 2d       	mov	r24, r9
    24de:	92 2d       	mov	r25, r2
    24e0:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:867
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
    24e4:	30 5c       	subi	r19, 0xC0	; 192
    24e6:	4f 4f       	sbci	r20, 0xFF	; 255
    24e8:	5f 4f       	sbci	r21, 0xFF	; 255
    24ea:	6f 4f       	sbci	r22, 0xFF	; 255
    24ec:	7f 4f       	sbci	r23, 0xFF	; 255
    24ee:	8f 4f       	sbci	r24, 0xFF	; 255
    24f0:	9f 4f       	sbci	r25, 0xFF	; 255
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:865
  //**********************//
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
  var2 =
      ((int32_t)_H2 *
    24f2:	20 90 d2 03 	lds	r2, 0x03D2	; 0x8003d2 <BME680+0x2f>
    24f6:	30 90 d3 03 	lds	r3, 0x03D3	; 0x8003d3 <BME680+0x30>
    24fa:	51 01       	movw	r10, r2
    24fc:	c1 2c       	mov	r12, r1
    24fe:	d1 2c       	mov	r13, r1
    2500:	e1 2c       	mov	r14, r1
    2502:	f1 2c       	mov	r15, r1
    2504:	00 e0       	ldi	r16, 0x00	; 0
    2506:	10 e0       	ldi	r17, 0x00	; 0
    2508:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:864
  // Compute the humidity //
  //**********************//
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
  var2 =
    250c:	0a e0       	ldi	r16, 0x0A	; 10
    250e:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2512:	92 2e       	mov	r9, r18
    2514:	83 2e       	mov	r8, r19
    2516:	34 2e       	mov	r3, r20
    2518:	25 2e       	mov	r2, r21
    251a:	cd 55       	subi	r28, 0x5D	; 93
    251c:	df 4f       	sbci	r29, 0xFF	; 255
    251e:	68 83       	st	Y, r22
    2520:	c3 5a       	subi	r28, 0xA3	; 163
    2522:	d0 40       	sbci	r29, 0x00	; 0
    2524:	c9 55       	subi	r28, 0x59	; 89
    2526:	df 4f       	sbci	r29, 0xFF	; 255
    2528:	78 83       	st	Y, r23
    252a:	c7 5a       	subi	r28, 0xA7	; 167
    252c:	d0 40       	sbci	r29, 0x00	; 0
    252e:	c5 55       	subi	r28, 0x55	; 85
    2530:	df 4f       	sbci	r29, 0xFF	; 255
    2532:	88 83       	st	Y, r24
    2534:	cb 5a       	subi	r28, 0xAB	; 171
    2536:	d0 40       	sbci	r29, 0x00	; 0
    2538:	c4 55       	subi	r28, 0x54	; 84
    253a:	df 4f       	sbci	r29, 0xFF	; 255
    253c:	98 83       	st	Y, r25
    253e:	cc 5a       	subi	r28, 0xAC	; 172
    2540:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:862
  _Pressure = (int32_t)(_Pressure) + ((var1 + var2 + var3 + ((int32_t)_P7 << 7)) >> 4);
  //**********************//
  // Compute the humidity //
  //**********************//
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
    2542:	cc 54       	subi	r28, 0x4C	; 76
    2544:	df 4f       	sbci	r29, 0xFF	; 255
    2546:	68 81       	ld	r22, Y
    2548:	79 81       	ldd	r23, Y+1	; 0x01
    254a:	c4 5b       	subi	r28, 0xB4	; 180
    254c:	d0 40       	sbci	r29, 0x00	; 0
    254e:	2b 01       	movw	r4, r22
    2550:	71 2c       	mov	r7, r1
    2552:	61 2c       	mov	r6, r1
    2554:	80 91 d0 03 	lds	r24, 0x03D0	; 0x8003d0 <BME680+0x2d>
    2558:	90 91 d1 03 	lds	r25, 0x03D1	; 0x8003d1 <BME680+0x2e>
    255c:	b0 e0       	ldi	r27, 0x00	; 0
    255e:	a0 e0       	ldi	r26, 0x00	; 0
    2560:	04 e0       	ldi	r16, 0x04	; 4
    2562:	88 0f       	add	r24, r24
    2564:	99 1f       	adc	r25, r25
    2566:	aa 1f       	adc	r26, r26
    2568:	bb 1f       	adc	r27, r27
    256a:	0a 95       	dec	r16
    256c:	d1 f7       	brne	.-12     	; 0x2562 <main+0x1440>
    256e:	48 1a       	sub	r4, r24
    2570:	59 0a       	sbc	r5, r25
    2572:	6a 0a       	sbc	r6, r26
    2574:	7b 0a       	sbc	r7, r27
    2576:	d3 01       	movw	r26, r6
    2578:	c2 01       	movw	r24, r4
    257a:	bb 0f       	add	r27, r27
    257c:	88 0b       	sbc	r24, r24
    257e:	98 2f       	mov	r25, r24
    2580:	dc 01       	movw	r26, r24
    2582:	c5 56       	subi	r28, 0x65	; 101
    2584:	df 4f       	sbci	r29, 0xFF	; 255
    2586:	88 83       	st	Y, r24
    2588:	99 83       	std	Y+1, r25	; 0x01
    258a:	aa 83       	std	Y+2, r26	; 0x02
    258c:	bb 83       	std	Y+3, r27	; 0x03
    258e:	cb 59       	subi	r28, 0x9B	; 155
    2590:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:863
         (((temp_scaled * (int32_t)_H3) / ((int32_t)100)) >> 1);
    2592:	60 91 c4 03 	lds	r22, 0x03C4	; 0x8003c4 <BME680+0x21>
    2596:	06 2e       	mov	r0, r22
    2598:	00 0c       	add	r0, r0
    259a:	77 0b       	sbc	r23, r23
    259c:	88 0b       	sbc	r24, r24
    259e:	99 0b       	sbc	r25, r25
    25a0:	cd 56       	subi	r28, 0x6D	; 109
    25a2:	df 4f       	sbci	r29, 0xFF	; 255
    25a4:	28 81       	ld	r18, Y
    25a6:	39 81       	ldd	r19, Y+1	; 0x01
    25a8:	4a 81       	ldd	r20, Y+2	; 0x02
    25aa:	5b 81       	ldd	r21, Y+3	; 0x03
    25ac:	c3 59       	subi	r28, 0x93	; 147
    25ae:	d0 40       	sbci	r29, 0x00	; 0
    25b0:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    25b4:	e4 e6       	ldi	r30, 0x64	; 100
    25b6:	ae 2e       	mov	r10, r30
    25b8:	b1 2c       	mov	r11, r1
    25ba:	00 e0       	ldi	r16, 0x00	; 0
    25bc:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
    25c0:	01 e0       	ldi	r16, 0x01	; 1
    25c2:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    25c6:	59 01       	movw	r10, r18
    25c8:	6a 01       	movw	r12, r20
    25ca:	7b 01       	movw	r14, r22
    25cc:	8c 01       	movw	r16, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:862
  _Pressure = (int32_t)(_Pressure) + ((var1 + var2 + var3 + ((int32_t)_P7 << 7)) >> 4);
  //**********************//
  // Compute the humidity //
  //**********************//
  temp_scaled = (((int32_t)_tfine * 5) + 128) >> 8;
  var1        = (int32_t)(adc_hum - ((int32_t)((int32_t)_H1 << 4))) -
    25ce:	92 01       	movw	r18, r4
    25d0:	a3 01       	movw	r20, r6
    25d2:	c5 56       	subi	r28, 0x65	; 101
    25d4:	df 4f       	sbci	r29, 0xFF	; 255
    25d6:	68 81       	ld	r22, Y
    25d8:	cb 59       	subi	r28, 0x9B	; 155
    25da:	d0 40       	sbci	r29, 0x00	; 0
    25dc:	76 2f       	mov	r23, r22
    25de:	86 2f       	mov	r24, r22
    25e0:	96 2f       	mov	r25, r22
    25e2:	0e 94 36 1f 	call	0x3e6c	; 0x3e6c <__subdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:870
      ((int32_t)_H2 *
       (((temp_scaled * (int32_t)_H4) / ((int32_t)100)) +
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
        (int32_t)(1 << 14))) >>
      10;
  var3      = var1 * var2;
    25e6:	59 01       	movw	r10, r18
    25e8:	6a 01       	movw	r12, r20
    25ea:	7b 01       	movw	r14, r22
    25ec:	8c 01       	movw	r16, r24
    25ee:	29 2d       	mov	r18, r9
    25f0:	38 2d       	mov	r19, r8
    25f2:	43 2d       	mov	r20, r3
    25f4:	52 2d       	mov	r21, r2
    25f6:	cd 55       	subi	r28, 0x5D	; 93
    25f8:	df 4f       	sbci	r29, 0xFF	; 255
    25fa:	68 81       	ld	r22, Y
    25fc:	c3 5a       	subi	r28, 0xA3	; 163
    25fe:	d0 40       	sbci	r29, 0x00	; 0
    2600:	c9 55       	subi	r28, 0x59	; 89
    2602:	df 4f       	sbci	r29, 0xFF	; 255
    2604:	78 81       	ld	r23, Y
    2606:	c7 5a       	subi	r28, 0xA7	; 167
    2608:	d0 40       	sbci	r29, 0x00	; 0
    260a:	c5 55       	subi	r28, 0x55	; 85
    260c:	df 4f       	sbci	r29, 0xFF	; 255
    260e:	88 81       	ld	r24, Y
    2610:	cb 5a       	subi	r28, 0xAB	; 171
    2612:	d0 40       	sbci	r29, 0x00	; 0
    2614:	c4 55       	subi	r28, 0x54	; 84
    2616:	df 4f       	sbci	r29, 0xFF	; 255
    2618:	98 81       	ld	r25, Y
    261a:	cc 5a       	subi	r28, 0xAC	; 172
    261c:	d0 40       	sbci	r29, 0x00	; 0
    261e:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    2622:	ca 54       	subi	r28, 0x4A	; 74
    2624:	df 4f       	sbci	r29, 0xFF	; 255
    2626:	28 83       	st	Y, r18
    2628:	c6 5b       	subi	r28, 0xB6	; 182
    262a:	d0 40       	sbci	r29, 0x00	; 0
    262c:	c9 54       	subi	r28, 0x49	; 73
    262e:	df 4f       	sbci	r29, 0xFF	; 255
    2630:	38 83       	st	Y, r19
    2632:	c7 5b       	subi	r28, 0xB7	; 183
    2634:	d0 40       	sbci	r29, 0x00	; 0
    2636:	c8 54       	subi	r28, 0x48	; 72
    2638:	df 4f       	sbci	r29, 0xFF	; 255
    263a:	48 83       	st	Y, r20
    263c:	c8 5b       	subi	r28, 0xB8	; 184
    263e:	d0 40       	sbci	r29, 0x00	; 0
    2640:	c7 54       	subi	r28, 0x47	; 71
    2642:	df 4f       	sbci	r29, 0xFF	; 255
    2644:	58 83       	st	Y, r21
    2646:	c9 5b       	subi	r28, 0xB9	; 185
    2648:	d0 40       	sbci	r29, 0x00	; 0
    264a:	1b 01       	movw	r2, r22
    264c:	4c 01       	movw	r8, r24
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:873
  var4      = (int32_t)_H6 << 7;
  var4      = ((var4) + ((temp_scaled * (int32_t)_H7) / ((int32_t)100))) >> 4;
  var5      = ((var3 >> 14) * (var3 >> 14)) >> 10;
    264e:	0e e0       	ldi	r16, 0x0E	; 14
    2650:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2654:	c5 56       	subi	r28, 0x65	; 101
    2656:	df 4f       	sbci	r29, 0xFF	; 255
    2658:	28 83       	st	Y, r18
    265a:	cb 59       	subi	r28, 0x9B	; 155
    265c:	d0 40       	sbci	r29, 0x00	; 0
    265e:	cd 55       	subi	r28, 0x5D	; 93
    2660:	df 4f       	sbci	r29, 0xFF	; 255
    2662:	38 83       	st	Y, r19
    2664:	c3 5a       	subi	r28, 0xA3	; 163
    2666:	d0 40       	sbci	r29, 0x00	; 0
    2668:	c9 55       	subi	r28, 0x59	; 89
    266a:	df 4f       	sbci	r29, 0xFF	; 255
    266c:	48 83       	st	Y, r20
    266e:	c7 5a       	subi	r28, 0xA7	; 167
    2670:	d0 40       	sbci	r29, 0x00	; 0
    2672:	c5 55       	subi	r28, 0x55	; 85
    2674:	df 4f       	sbci	r29, 0xFF	; 255
    2676:	58 83       	st	Y, r21
    2678:	cb 5a       	subi	r28, 0xAB	; 171
    267a:	d0 40       	sbci	r29, 0x00	; 0
    267c:	c4 55       	subi	r28, 0x54	; 84
    267e:	df 4f       	sbci	r29, 0xFF	; 255
    2680:	68 83       	st	Y, r22
    2682:	cc 5a       	subi	r28, 0xAC	; 172
    2684:	d0 40       	sbci	r29, 0x00	; 0
    2686:	c3 55       	subi	r28, 0x53	; 83
    2688:	df 4f       	sbci	r29, 0xFF	; 255
    268a:	78 83       	st	Y, r23
    268c:	cd 5a       	subi	r28, 0xAD	; 173
    268e:	d0 40       	sbci	r29, 0x00	; 0
    2690:	c0 55       	subi	r28, 0x50	; 80
    2692:	df 4f       	sbci	r29, 0xFF	; 255
    2694:	88 83       	st	Y, r24
    2696:	c0 5b       	subi	r28, 0xB0	; 176
    2698:	d0 40       	sbci	r29, 0x00	; 0
    269a:	cc 54       	subi	r28, 0x4C	; 76
    269c:	df 4f       	sbci	r29, 0xFF	; 255
    269e:	98 83       	st	Y, r25
    26a0:	c4 5b       	subi	r28, 0xB4	; 180
    26a2:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:872
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
        (int32_t)(1 << 14))) >>
      10;
  var3      = var1 * var2;
  var4      = (int32_t)_H6 << 7;
  var4      = ((var4) + ((temp_scaled * (int32_t)_H7) / ((int32_t)100))) >> 4;
    26a4:	60 91 c7 03 	lds	r22, 0x03C7	; 0x8003c7 <BME680+0x24>
    26a8:	06 2e       	mov	r0, r22
    26aa:	00 0c       	add	r0, r0
    26ac:	77 0b       	sbc	r23, r23
    26ae:	88 0b       	sbc	r24, r24
    26b0:	99 0b       	sbc	r25, r25
    26b2:	cd 56       	subi	r28, 0x6D	; 109
    26b4:	df 4f       	sbci	r29, 0xFF	; 255
    26b6:	28 81       	ld	r18, Y
    26b8:	39 81       	ldd	r19, Y+1	; 0x01
    26ba:	4a 81       	ldd	r20, Y+2	; 0x02
    26bc:	5b 81       	ldd	r21, Y+3	; 0x03
    26be:	c3 59       	subi	r28, 0x93	; 147
    26c0:	d0 40       	sbci	r29, 0x00	; 0
    26c2:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    26c6:	f4 e6       	ldi	r31, 0x64	; 100
    26c8:	af 2e       	mov	r10, r31
    26ca:	b1 2c       	mov	r11, r1
    26cc:	c1 2c       	mov	r12, r1
    26ce:	d1 2c       	mov	r13, r1
    26d0:	e1 2c       	mov	r14, r1
    26d2:	f1 2c       	mov	r15, r1
    26d4:	00 e0       	ldi	r16, 0x00	; 0
    26d6:	10 e0       	ldi	r17, 0x00	; 0
    26d8:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:871
       (((temp_scaled * (int32_t)_H4) / ((int32_t)100)) +
        (((temp_scaled * ((temp_scaled * (int32_t)_H5) / ((int32_t)100))) >> 6) / ((int32_t)100)) +
        (int32_t)(1 << 14))) >>
      10;
  var3      = var1 * var2;
  var4      = (int32_t)_H6 << 7;
    26dc:	e0 90 c1 03 	lds	r14, 0x03C1	; 0x8003c1 <BME680+0x1e>
    26e0:	f1 2c       	mov	r15, r1
    26e2:	10 e0       	ldi	r17, 0x00	; 0
    26e4:	00 e0       	ldi	r16, 0x00	; 0
    26e6:	a7 e0       	ldi	r26, 0x07	; 7
    26e8:	ee 0c       	add	r14, r14
    26ea:	ff 1c       	adc	r15, r15
    26ec:	00 1f       	adc	r16, r16
    26ee:	11 1f       	adc	r17, r17
    26f0:	aa 95       	dec	r26
    26f2:	d1 f7       	brne	.-12     	; 0x26e8 <main+0x15c6>
    26f4:	27 01       	movw	r4, r14
    26f6:	38 01       	movw	r6, r16
    26f8:	77 0c       	add	r7, r7
    26fa:	44 08       	sbc	r4, r4
    26fc:	54 2c       	mov	r5, r4
    26fe:	32 01       	movw	r6, r4
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:872
  var4      = ((var4) + ((temp_scaled * (int32_t)_H7) / ((int32_t)100))) >> 4;
    2700:	57 01       	movw	r10, r14
    2702:	68 01       	movw	r12, r16
    2704:	e4 2c       	mov	r14, r4
    2706:	f4 2c       	mov	r15, r4
    2708:	04 2d       	mov	r16, r4
    270a:	14 2d       	mov	r17, r4
    270c:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2710:	04 e0       	ldi	r16, 0x04	; 4
    2712:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2716:	cd 56       	subi	r28, 0x6D	; 109
    2718:	df 4f       	sbci	r29, 0xFF	; 255
    271a:	28 83       	st	Y, r18
    271c:	c3 59       	subi	r28, 0x93	; 147
    271e:	d0 40       	sbci	r29, 0x00	; 0
    2720:	c6 54       	subi	r28, 0x46	; 70
    2722:	df 4f       	sbci	r29, 0xFF	; 255
    2724:	38 83       	st	Y, r19
    2726:	ca 5b       	subi	r28, 0xBA	; 186
    2728:	d0 40       	sbci	r29, 0x00	; 0
    272a:	2a 01       	movw	r4, r20
    272c:	3b 01       	movw	r6, r22
    272e:	c5 54       	subi	r28, 0x45	; 69
    2730:	df 4f       	sbci	r29, 0xFF	; 255
    2732:	88 83       	st	Y, r24
    2734:	cb 5b       	subi	r28, 0xBB	; 187
    2736:	d0 40       	sbci	r29, 0x00	; 0
    2738:	c4 54       	subi	r28, 0x44	; 68
    273a:	df 4f       	sbci	r29, 0xFF	; 255
    273c:	98 83       	st	Y, r25
    273e:	cc 5b       	subi	r28, 0xBC	; 188
    2740:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:873
  var5      = ((var3 >> 14) * (var3 >> 14)) >> 10;
    2742:	c5 56       	subi	r28, 0x65	; 101
    2744:	df 4f       	sbci	r29, 0xFF	; 255
    2746:	a8 80       	ld	r10, Y
    2748:	cb 59       	subi	r28, 0x9B	; 155
    274a:	d0 40       	sbci	r29, 0x00	; 0
    274c:	cd 55       	subi	r28, 0x5D	; 93
    274e:	df 4f       	sbci	r29, 0xFF	; 255
    2750:	b8 80       	ld	r11, Y
    2752:	c3 5a       	subi	r28, 0xA3	; 163
    2754:	d0 40       	sbci	r29, 0x00	; 0
    2756:	c9 55       	subi	r28, 0x59	; 89
    2758:	df 4f       	sbci	r29, 0xFF	; 255
    275a:	c8 80       	ld	r12, Y
    275c:	c7 5a       	subi	r28, 0xA7	; 167
    275e:	d0 40       	sbci	r29, 0x00	; 0
    2760:	c5 55       	subi	r28, 0x55	; 85
    2762:	df 4f       	sbci	r29, 0xFF	; 255
    2764:	d8 80       	ld	r13, Y
    2766:	cb 5a       	subi	r28, 0xAB	; 171
    2768:	d0 40       	sbci	r29, 0x00	; 0
    276a:	c4 55       	subi	r28, 0x54	; 84
    276c:	df 4f       	sbci	r29, 0xFF	; 255
    276e:	e8 80       	ld	r14, Y
    2770:	cc 5a       	subi	r28, 0xAC	; 172
    2772:	d0 40       	sbci	r29, 0x00	; 0
    2774:	c3 55       	subi	r28, 0x53	; 83
    2776:	df 4f       	sbci	r29, 0xFF	; 255
    2778:	f8 80       	ld	r15, Y
    277a:	cd 5a       	subi	r28, 0xAD	; 173
    277c:	d0 40       	sbci	r29, 0x00	; 0
    277e:	c0 55       	subi	r28, 0x50	; 80
    2780:	df 4f       	sbci	r29, 0xFF	; 255
    2782:	08 81       	ld	r16, Y
    2784:	c0 5b       	subi	r28, 0xB0	; 176
    2786:	d0 40       	sbci	r29, 0x00	; 0
    2788:	cc 54       	subi	r28, 0x4C	; 76
    278a:	df 4f       	sbci	r29, 0xFF	; 255
    278c:	18 81       	ld	r17, Y
    278e:	c4 5b       	subi	r28, 0xB4	; 180
    2790:	d0 40       	sbci	r29, 0x00	; 0
    2792:	95 01       	movw	r18, r10
    2794:	a6 01       	movw	r20, r12
    2796:	b7 01       	movw	r22, r14
    2798:	c8 01       	movw	r24, r16
    279a:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    279e:	0a e0       	ldi	r16, 0x0A	; 10
    27a0:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:874
  var6      = (var4 * var5) >> 1;
    27a4:	59 01       	movw	r10, r18
    27a6:	6a 01       	movw	r12, r20
    27a8:	7b 01       	movw	r14, r22
    27aa:	8c 01       	movw	r16, r24
    27ac:	cd 56       	subi	r28, 0x6D	; 109
    27ae:	df 4f       	sbci	r29, 0xFF	; 255
    27b0:	28 81       	ld	r18, Y
    27b2:	c3 59       	subi	r28, 0x93	; 147
    27b4:	d0 40       	sbci	r29, 0x00	; 0
    27b6:	c6 54       	subi	r28, 0x46	; 70
    27b8:	df 4f       	sbci	r29, 0xFF	; 255
    27ba:	38 81       	ld	r19, Y
    27bc:	ca 5b       	subi	r28, 0xBA	; 186
    27be:	d0 40       	sbci	r29, 0x00	; 0
    27c0:	a2 01       	movw	r20, r4
    27c2:	b3 01       	movw	r22, r6
    27c4:	c5 54       	subi	r28, 0x45	; 69
    27c6:	df 4f       	sbci	r29, 0xFF	; 255
    27c8:	88 81       	ld	r24, Y
    27ca:	cb 5b       	subi	r28, 0xBB	; 187
    27cc:	d0 40       	sbci	r29, 0x00	; 0
    27ce:	c4 54       	subi	r28, 0x44	; 68
    27d0:	df 4f       	sbci	r29, 0xFF	; 255
    27d2:	98 81       	ld	r25, Y
    27d4:	cc 5b       	subi	r28, 0xBC	; 188
    27d6:	d0 40       	sbci	r29, 0x00	; 0
    27d8:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    27dc:	01 e0       	ldi	r16, 0x01	; 1
    27de:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:875
  _Humidity = (((var3 + var6) >> 10) * ((int32_t)1000)) >> 12;
    27e2:	ca 54       	subi	r28, 0x4A	; 74
    27e4:	df 4f       	sbci	r29, 0xFF	; 255
    27e6:	a8 80       	ld	r10, Y
    27e8:	c6 5b       	subi	r28, 0xB6	; 182
    27ea:	d0 40       	sbci	r29, 0x00	; 0
    27ec:	c9 54       	subi	r28, 0x49	; 73
    27ee:	df 4f       	sbci	r29, 0xFF	; 255
    27f0:	b8 80       	ld	r11, Y
    27f2:	c7 5b       	subi	r28, 0xB7	; 183
    27f4:	d0 40       	sbci	r29, 0x00	; 0
    27f6:	c8 54       	subi	r28, 0x48	; 72
    27f8:	df 4f       	sbci	r29, 0xFF	; 255
    27fa:	c8 80       	ld	r12, Y
    27fc:	c8 5b       	subi	r28, 0xB8	; 184
    27fe:	d0 40       	sbci	r29, 0x00	; 0
    2800:	c7 54       	subi	r28, 0x47	; 71
    2802:	df 4f       	sbci	r29, 0xFF	; 255
    2804:	d8 80       	ld	r13, Y
    2806:	c9 5b       	subi	r28, 0xB9	; 185
    2808:	d0 40       	sbci	r29, 0x00	; 0
    280a:	71 01       	movw	r14, r2
    280c:	84 01       	movw	r16, r8
    280e:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2812:	0a e0       	ldi	r16, 0x0A	; 10
    2814:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2818:	18 ee       	ldi	r17, 0xE8	; 232
    281a:	a1 2e       	mov	r10, r17
    281c:	03 e0       	ldi	r16, 0x03	; 3
    281e:	b0 2e       	mov	r11, r16
    2820:	c1 2c       	mov	r12, r1
    2822:	d1 2c       	mov	r13, r1
    2824:	e1 2c       	mov	r14, r1
    2826:	f1 2c       	mov	r15, r1
    2828:	00 e0       	ldi	r16, 0x00	; 0
    282a:	10 e0       	ldi	r17, 0x00	; 0
    282c:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    2830:	0c e0       	ldi	r16, 0x0C	; 12
    2832:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2836:	c9 01       	movw	r24, r18
    2838:	da 01       	movw	r26, r20
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:876
  if (_Humidity > 100000) /* Cap at 100%rH */
    283a:	81 3a       	cpi	r24, 0xA1	; 161
    283c:	e6 e8       	ldi	r30, 0x86	; 134
    283e:	9e 07       	cpc	r25, r30
    2840:	e1 e0       	ldi	r30, 0x01	; 1
    2842:	ae 07       	cpc	r26, r30
    2844:	b1 05       	cpc	r27, r1
    2846:	0c f4       	brge	.+2      	; 0x284a <main+0x1728>
    2848:	af c2       	rjmp	.+1374   	; 0x2da8 <main+0x1c86>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:877
    _Humidity = 100000;
    284a:	20 ea       	ldi	r18, 0xA0	; 160
    284c:	a2 2e       	mov	r10, r18
    284e:	26 e8       	ldi	r18, 0x86	; 134
    2850:	b2 2e       	mov	r11, r18
    2852:	cc 24       	eor	r12, r12
    2854:	c3 94       	inc	r12
    2856:	d1 2c       	mov	r13, r1
    2858:	a0 92 f2 03 	sts	0x03F2, r10	; 0x8003f2 <BME680+0x4f>
    285c:	b0 92 f3 03 	sts	0x03F3, r11	; 0x8003f3 <BME680+0x50>
    2860:	c0 92 f4 03 	sts	0x03F4, r12	; 0x8003f4 <BME680+0x51>
    2864:	d0 92 f5 03 	sts	0x03F5, r13	; 0x8003f5 <BME680+0x52>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:884
    _Humidity = 0;
  //**********************//
  // Compute the Gas      //
  //**********************//
  uint64_t uvar2;
  var1  = (int64_t)((1340 + (5 * (int64_t)_rng_sw_err)) * ((int64_t)lookupTable1[gas_range])) >> 16;
    2868:	60 91 cf 03 	lds	r22, 0x03CF	; 0x8003cf <BME680+0x2c>
    286c:	06 2e       	mov	r0, r22
    286e:	00 0c       	add	r0, r0
    2870:	77 0b       	sbc	r23, r23
    2872:	88 0b       	sbc	r24, r24
    2874:	99 0b       	sbc	r25, r25
    2876:	25 e0       	ldi	r18, 0x05	; 5
    2878:	30 e0       	ldi	r19, 0x00	; 0
    287a:	40 e0       	ldi	r20, 0x00	; 0
    287c:	50 e0       	ldi	r21, 0x00	; 0
    287e:	0e 94 1d 1e 	call	0x3c3a	; 0x3c3a <__mulsidi3>
    2882:	24 5c       	subi	r18, 0xC4	; 196
    2884:	3a 4f       	sbci	r19, 0xFA	; 250
    2886:	4f 4f       	sbci	r20, 0xFF	; 255
    2888:	5f 4f       	sbci	r21, 0xFF	; 255
    288a:	6f 4f       	sbci	r22, 0xFF	; 255
    288c:	7f 4f       	sbci	r23, 0xFF	; 255
    288e:	8f 4f       	sbci	r24, 0xFF	; 255
    2890:	9f 4f       	sbci	r25, 0xFF	; 255
    2892:	c1 54       	subi	r28, 0x41	; 65
    2894:	df 4f       	sbci	r29, 0xFF	; 255
    2896:	c8 80       	ld	r12, Y
    2898:	cf 5b       	subi	r28, 0xBF	; 191
    289a:	d0 40       	sbci	r29, 0x00	; 0
    289c:	04 e0       	ldi	r16, 0x04	; 4
    289e:	c0 9e       	mul	r12, r16
    28a0:	60 01       	movw	r12, r0
    28a2:	11 24       	eor	r1, r1
    28a4:	cd 56       	subi	r28, 0x6D	; 109
    28a6:	df 4f       	sbci	r29, 0xFF	; 255
    28a8:	d9 82       	std	Y+1, r13	; 0x01
    28aa:	c8 82       	st	Y, r12
    28ac:	c3 59       	subi	r28, 0x93	; 147
    28ae:	d0 40       	sbci	r29, 0x00	; 0
    28b0:	e1 e4       	ldi	r30, 0x41	; 65
    28b2:	f0 e0       	ldi	r31, 0x00	; 0
    28b4:	ec 0f       	add	r30, r28
    28b6:	fd 1f       	adc	r31, r29
    28b8:	ec 0d       	add	r30, r12
    28ba:	fd 1d       	adc	r31, r13
    28bc:	c0 80       	ld	r12, Z
    28be:	d1 80       	ldd	r13, Z+1	; 0x01
    28c0:	e2 80       	ldd	r14, Z+2	; 0x02
    28c2:	f3 80       	ldd	r15, Z+3	; 0x03
    28c4:	56 01       	movw	r10, r12
    28c6:	67 01       	movw	r12, r14
    28c8:	e1 2c       	mov	r14, r1
    28ca:	f1 2c       	mov	r15, r1
    28cc:	00 e0       	ldi	r16, 0x00	; 0
    28ce:	10 e0       	ldi	r17, 0x00	; 0
    28d0:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    28d4:	00 e1       	ldi	r16, 0x10	; 16
    28d6:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    28da:	52 2e       	mov	r5, r18
    28dc:	63 2e       	mov	r6, r19
    28de:	74 2e       	mov	r7, r20
    28e0:	85 2e       	mov	r8, r21
    28e2:	b6 2f       	mov	r27, r22
    28e4:	a7 2f       	mov	r26, r23
    28e6:	c4 55       	subi	r28, 0x54	; 84
    28e8:	df 4f       	sbci	r29, 0xFF	; 255
    28ea:	88 83       	st	Y, r24
    28ec:	cc 5a       	subi	r28, 0xAC	; 172
    28ee:	d0 40       	sbci	r29, 0x00	; 0
    28f0:	c3 55       	subi	r28, 0x53	; 83
    28f2:	df 4f       	sbci	r29, 0xFF	; 255
    28f4:	98 83       	st	Y, r25
    28f6:	cd 5a       	subi	r28, 0xAD	; 173
    28f8:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:885
  uvar2 = (((int64_t)((int64_t)adc_gas_res << 15) - (int64_t)(16777216)) + var1);
    28fa:	c3 54       	subi	r28, 0x43	; 67
    28fc:	df 4f       	sbci	r29, 0xFF	; 255
    28fe:	28 81       	ld	r18, Y
    2900:	39 81       	ldd	r19, Y+1	; 0x01
    2902:	cd 5b       	subi	r28, 0xBD	; 189
    2904:	d0 40       	sbci	r29, 0x00	; 0
    2906:	40 e0       	ldi	r20, 0x00	; 0
    2908:	50 e0       	ldi	r21, 0x00	; 0
    290a:	60 e0       	ldi	r22, 0x00	; 0
    290c:	70 e0       	ldi	r23, 0x00	; 0
    290e:	80 e0       	ldi	r24, 0x00	; 0
    2910:	90 e0       	ldi	r25, 0x00	; 0
    2912:	0f e0       	ldi	r16, 0x0F	; 15
    2914:	0e 94 f7 1e 	call	0x3dee	; 0x3dee <__ashldi3>
    2918:	51 50       	subi	r21, 0x01	; 1
    291a:	61 09       	sbc	r22, r1
    291c:	71 09       	sbc	r23, r1
    291e:	81 09       	sbc	r24, r1
    2920:	91 09       	sbc	r25, r1
    2922:	a5 2c       	mov	r10, r5
    2924:	b6 2c       	mov	r11, r6
    2926:	c7 2c       	mov	r12, r7
    2928:	d8 2c       	mov	r13, r8
    292a:	eb 2e       	mov	r14, r27
    292c:	fa 2e       	mov	r15, r26
    292e:	c4 55       	subi	r28, 0x54	; 84
    2930:	df 4f       	sbci	r29, 0xFF	; 255
    2932:	08 81       	ld	r16, Y
    2934:	cc 5a       	subi	r28, 0xAC	; 172
    2936:	d0 40       	sbci	r29, 0x00	; 0
    2938:	c3 55       	subi	r28, 0x53	; 83
    293a:	df 4f       	sbci	r29, 0xFF	; 255
    293c:	18 81       	ld	r17, Y
    293e:	cd 5a       	subi	r28, 0xAD	; 173
    2940:	d0 40       	sbci	r29, 0x00	; 0
    2942:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2946:	92 2e       	mov	r9, r18
    2948:	43 2e       	mov	r4, r19
    294a:	34 2e       	mov	r3, r20
    294c:	25 2e       	mov	r2, r21
    294e:	c5 56       	subi	r28, 0x65	; 101
    2950:	df 4f       	sbci	r29, 0xFF	; 255
    2952:	68 83       	st	Y, r22
    2954:	cb 59       	subi	r28, 0x9B	; 155
    2956:	d0 40       	sbci	r29, 0x00	; 0
    2958:	cd 55       	subi	r28, 0x5D	; 93
    295a:	df 4f       	sbci	r29, 0xFF	; 255
    295c:	78 83       	st	Y, r23
    295e:	c3 5a       	subi	r28, 0xA3	; 163
    2960:	d0 40       	sbci	r29, 0x00	; 0
    2962:	c9 55       	subi	r28, 0x59	; 89
    2964:	df 4f       	sbci	r29, 0xFF	; 255
    2966:	88 83       	st	Y, r24
    2968:	c7 5a       	subi	r28, 0xA7	; 167
    296a:	d0 40       	sbci	r29, 0x00	; 0
    296c:	c5 55       	subi	r28, 0x55	; 85
    296e:	df 4f       	sbci	r29, 0xFF	; 255
    2970:	98 83       	st	Y, r25
    2972:	cb 5a       	subi	r28, 0xAB	; 171
    2974:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:886
  var3  = (((int64_t)lookupTable2[gas_range] * (int64_t)var1) >> 9);
    2976:	81 e0       	ldi	r24, 0x01	; 1
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	8c 0f       	add	r24, r28
    297c:	9d 1f       	adc	r25, r29
    297e:	cd 56       	subi	r28, 0x6D	; 109
    2980:	df 4f       	sbci	r29, 0xFF	; 255
    2982:	48 81       	ld	r20, Y
    2984:	59 81       	ldd	r21, Y+1	; 0x01
    2986:	c3 59       	subi	r28, 0x93	; 147
    2988:	d0 40       	sbci	r29, 0x00	; 0
    298a:	84 0f       	add	r24, r20
    298c:	95 1f       	adc	r25, r21
    298e:	fc 01       	movw	r30, r24
    2990:	40 81       	ld	r20, Z
    2992:	51 81       	ldd	r21, Z+1	; 0x01
    2994:	62 81       	ldd	r22, Z+2	; 0x02
    2996:	73 81       	ldd	r23, Z+3	; 0x03
    2998:	5a 01       	movw	r10, r20
    299a:	6b 01       	movw	r12, r22
    299c:	e1 2c       	mov	r14, r1
    299e:	f1 2c       	mov	r15, r1
    29a0:	87 01       	movw	r16, r14
    29a2:	cd 56       	subi	r28, 0x6D	; 109
    29a4:	df 4f       	sbci	r29, 0xFF	; 255
    29a6:	48 83       	st	Y, r20
    29a8:	c3 59       	subi	r28, 0x93	; 147
    29aa:	d0 40       	sbci	r29, 0x00	; 0
    29ac:	cc 56       	subi	r28, 0x6C	; 108
    29ae:	df 4f       	sbci	r29, 0xFF	; 255
    29b0:	b8 82       	st	Y, r11
    29b2:	c4 59       	subi	r28, 0x94	; 148
    29b4:	d0 40       	sbci	r29, 0x00	; 0
    29b6:	cb 56       	subi	r28, 0x6B	; 107
    29b8:	df 4f       	sbci	r29, 0xFF	; 255
    29ba:	68 83       	st	Y, r22
    29bc:	c5 59       	subi	r28, 0x95	; 149
    29be:	d0 40       	sbci	r29, 0x00	; 0
    29c0:	ca 56       	subi	r28, 0x6A	; 106
    29c2:	df 4f       	sbci	r29, 0xFF	; 255
    29c4:	d8 82       	st	Y, r13
    29c6:	c6 59       	subi	r28, 0x96	; 150
    29c8:	d0 40       	sbci	r29, 0x00	; 0
    29ca:	c9 56       	subi	r28, 0x69	; 105
    29cc:	df 4f       	sbci	r29, 0xFF	; 255
    29ce:	e8 82       	st	Y, r14
    29d0:	c7 59       	subi	r28, 0x97	; 151
    29d2:	d0 40       	sbci	r29, 0x00	; 0
    29d4:	c8 56       	subi	r28, 0x68	; 104
    29d6:	df 4f       	sbci	r29, 0xFF	; 255
    29d8:	f8 82       	st	Y, r15
    29da:	c8 59       	subi	r28, 0x98	; 152
    29dc:	d0 40       	sbci	r29, 0x00	; 0
    29de:	c7 56       	subi	r28, 0x67	; 103
    29e0:	df 4f       	sbci	r29, 0xFF	; 255
    29e2:	08 83       	st	Y, r16
    29e4:	c9 59       	subi	r28, 0x99	; 153
    29e6:	d0 40       	sbci	r29, 0x00	; 0
    29e8:	c6 56       	subi	r28, 0x66	; 102
    29ea:	df 4f       	sbci	r29, 0xFF	; 255
    29ec:	18 83       	st	Y, r17
    29ee:	ca 59       	subi	r28, 0x9A	; 154
    29f0:	d0 40       	sbci	r29, 0x00	; 0
    29f2:	a5 2c       	mov	r10, r5
    29f4:	b6 2c       	mov	r11, r6
    29f6:	c7 2c       	mov	r12, r7
    29f8:	d8 2c       	mov	r13, r8
    29fa:	eb 2e       	mov	r14, r27
    29fc:	fa 2e       	mov	r15, r26
    29fe:	c4 55       	subi	r28, 0x54	; 84
    2a00:	df 4f       	sbci	r29, 0xFF	; 255
    2a02:	08 81       	ld	r16, Y
    2a04:	cc 5a       	subi	r28, 0xAC	; 172
    2a06:	d0 40       	sbci	r29, 0x00	; 0
    2a08:	c3 55       	subi	r28, 0x53	; 83
    2a0a:	df 4f       	sbci	r29, 0xFF	; 255
    2a0c:	18 81       	ld	r17, Y
    2a0e:	cd 5a       	subi	r28, 0xAD	; 173
    2a10:	d0 40       	sbci	r29, 0x00	; 0
    2a12:	cd 56       	subi	r28, 0x6D	; 109
    2a14:	df 4f       	sbci	r29, 0xFF	; 255
    2a16:	28 81       	ld	r18, Y
    2a18:	c3 59       	subi	r28, 0x93	; 147
    2a1a:	d0 40       	sbci	r29, 0x00	; 0
    2a1c:	cc 56       	subi	r28, 0x6C	; 108
    2a1e:	df 4f       	sbci	r29, 0xFF	; 255
    2a20:	38 81       	ld	r19, Y
    2a22:	c4 59       	subi	r28, 0x94	; 148
    2a24:	d0 40       	sbci	r29, 0x00	; 0
    2a26:	cb 56       	subi	r28, 0x6B	; 107
    2a28:	df 4f       	sbci	r29, 0xFF	; 255
    2a2a:	48 81       	ld	r20, Y
    2a2c:	c5 59       	subi	r28, 0x95	; 149
    2a2e:	d0 40       	sbci	r29, 0x00	; 0
    2a30:	ca 56       	subi	r28, 0x6A	; 106
    2a32:	df 4f       	sbci	r29, 0xFF	; 255
    2a34:	58 81       	ld	r21, Y
    2a36:	c6 59       	subi	r28, 0x96	; 150
    2a38:	d0 40       	sbci	r29, 0x00	; 0
    2a3a:	60 e0       	ldi	r22, 0x00	; 0
    2a3c:	70 e0       	ldi	r23, 0x00	; 0
    2a3e:	80 e0       	ldi	r24, 0x00	; 0
    2a40:	90 e0       	ldi	r25, 0x00	; 0
    2a42:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <__muldi3>
    2a46:	09 e0       	ldi	r16, 0x09	; 9
    2a48:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2a4c:	52 2e       	mov	r5, r18
    2a4e:	63 2e       	mov	r6, r19
    2a50:	74 2e       	mov	r7, r20
    2a52:	85 2e       	mov	r8, r21
    2a54:	b6 2f       	mov	r27, r22
    2a56:	a7 2f       	mov	r26, r23
    2a58:	f8 2f       	mov	r31, r24
    2a5a:	e9 2f       	mov	r30, r25
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:887
  _Gas  = (uint32_t)((var3 + ((int64_t)uvar2 >> 1)) / (int64_t)uvar2);
    2a5c:	29 2d       	mov	r18, r9
    2a5e:	34 2d       	mov	r19, r4
    2a60:	43 2d       	mov	r20, r3
    2a62:	52 2d       	mov	r21, r2
    2a64:	c5 56       	subi	r28, 0x65	; 101
    2a66:	df 4f       	sbci	r29, 0xFF	; 255
    2a68:	68 81       	ld	r22, Y
    2a6a:	cb 59       	subi	r28, 0x9B	; 155
    2a6c:	d0 40       	sbci	r29, 0x00	; 0
    2a6e:	cd 55       	subi	r28, 0x5D	; 93
    2a70:	df 4f       	sbci	r29, 0xFF	; 255
    2a72:	78 81       	ld	r23, Y
    2a74:	c3 5a       	subi	r28, 0xA3	; 163
    2a76:	d0 40       	sbci	r29, 0x00	; 0
    2a78:	c9 55       	subi	r28, 0x59	; 89
    2a7a:	df 4f       	sbci	r29, 0xFF	; 255
    2a7c:	88 81       	ld	r24, Y
    2a7e:	c7 5a       	subi	r28, 0xA7	; 167
    2a80:	d0 40       	sbci	r29, 0x00	; 0
    2a82:	c5 55       	subi	r28, 0x55	; 85
    2a84:	df 4f       	sbci	r29, 0xFF	; 255
    2a86:	98 81       	ld	r25, Y
    2a88:	cb 5a       	subi	r28, 0xAB	; 171
    2a8a:	d0 40       	sbci	r29, 0x00	; 0
    2a8c:	01 e0       	ldi	r16, 0x01	; 1
    2a8e:	0e 94 10 1f 	call	0x3e20	; 0x3e20 <__ashrdi3>
    2a92:	59 01       	movw	r10, r18
    2a94:	6a 01       	movw	r12, r20
    2a96:	7b 01       	movw	r14, r22
    2a98:	8c 01       	movw	r16, r24
    2a9a:	25 2d       	mov	r18, r5
    2a9c:	36 2d       	mov	r19, r6
    2a9e:	47 2d       	mov	r20, r7
    2aa0:	58 2d       	mov	r21, r8
    2aa2:	6b 2f       	mov	r22, r27
    2aa4:	7a 2f       	mov	r23, r26
    2aa6:	8f 2f       	mov	r24, r31
    2aa8:	9e 2f       	mov	r25, r30
    2aaa:	0e 94 2d 1f 	call	0x3e5a	; 0x3e5a <__adddi3>
    2aae:	a9 2c       	mov	r10, r9
    2ab0:	b4 2c       	mov	r11, r4
    2ab2:	c3 2c       	mov	r12, r3
    2ab4:	d2 2c       	mov	r13, r2
    2ab6:	c5 56       	subi	r28, 0x65	; 101
    2ab8:	df 4f       	sbci	r29, 0xFF	; 255
    2aba:	e8 80       	ld	r14, Y
    2abc:	cb 59       	subi	r28, 0x9B	; 155
    2abe:	d0 40       	sbci	r29, 0x00	; 0
    2ac0:	cd 55       	subi	r28, 0x5D	; 93
    2ac2:	df 4f       	sbci	r29, 0xFF	; 255
    2ac4:	f8 80       	ld	r15, Y
    2ac6:	c3 5a       	subi	r28, 0xA3	; 163
    2ac8:	d0 40       	sbci	r29, 0x00	; 0
    2aca:	c9 55       	subi	r28, 0x59	; 89
    2acc:	df 4f       	sbci	r29, 0xFF	; 255
    2ace:	08 81       	ld	r16, Y
    2ad0:	c7 5a       	subi	r28, 0xA7	; 167
    2ad2:	d0 40       	sbci	r29, 0x00	; 0
    2ad4:	c5 55       	subi	r28, 0x55	; 85
    2ad6:	df 4f       	sbci	r29, 0xFF	; 255
    2ad8:	18 81       	ld	r17, Y
    2ada:	cb 5a       	subi	r28, 0xAB	; 171
    2adc:	d0 40       	sbci	r29, 0x00	; 0
    2ade:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <__divdi3>
    2ae2:	20 93 f6 03 	sts	0x03F6, r18	; 0x8003f6 <BME680+0x53>
    2ae6:	30 93 f7 03 	sts	0x03F7, r19	; 0x8003f7 <BME680+0x54>
    2aea:	40 93 f8 03 	sts	0x03F8, r20	; 0x8003f8 <BME680+0x55>
    2aee:	50 93 f9 03 	sts	0x03F9, r21	; 0x8003f9 <BME680+0x56>
triggerMeasurement():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:960
}  // of method "measuring()"
void BME680_Class::triggerMeasurement() const {
  /*!
   * @brief Trigger a new measurement on the BME680
   */
  uint8_t workRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the control measure
    2af2:	84 e7       	ldi	r24, 0x74	; 116
    2af4:	0e 94 5d 06 	call	0xcba	; 0xcba <BME680_Class::readByte(unsigned char) const [clone .constprop.31]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:962
  putData(BME680_CONTROL_MEASURE_REGISTER,
          (uint8_t)(workRegister | 1));  // Trigger start of next measurement
    2af8:	81 60       	ori	r24, 0x01	; 1
    2afa:	c0 57       	subi	r28, 0x70	; 112
    2afc:	df 4f       	sbci	r29, 0xFF	; 255
    2afe:	88 83       	st	Y, r24
    2b00:	c0 59       	subi	r28, 0x90	; 144
    2b02:	d0 40       	sbci	r29, 0x00	; 0
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:961
void BME680_Class::triggerMeasurement() const {
  /*!
   * @brief Trigger a new measurement on the BME680
   */
  uint8_t workRegister = readByte(BME680_CONTROL_MEASURE_REGISTER);  // Read the control measure
  putData(BME680_CONTROL_MEASURE_REGISTER,
    2b04:	be 01       	movw	r22, r28
    2b06:	60 57       	subi	r22, 0x70	; 112
    2b08:	7f 4f       	sbci	r23, 0xFF	; 255
    2b0a:	84 e7       	ldi	r24, 0x74	; 116
    2b0c:	0e 94 b9 04 	call	0x972	; 0x972 <unsigned char& BME680_Class::putData<unsigned char>(unsigned char, unsigned char const&) const [clone .constprop.39]>
getSensorData():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:784
   param[out] press      Pressure reading
   param[out] gas        Gas reading
   param[in]  waitSwitch (Optional) When set will not return until reading is finished
   */
  uint8_t status = readSensors(waitSwitch);  // Get compensated data from BME680
  temp           = _Temperature;             // Copy global variables to parameters
    2b10:	60 91 ea 03 	lds	r22, 0x03EA	; 0x8003ea <BME680+0x47>
    2b14:	70 91 eb 03 	lds	r23, 0x03EB	; 0x8003eb <BME680+0x48>
    2b18:	80 91 ec 03 	lds	r24, 0x03EC	; 0x8003ec <BME680+0x49>
    2b1c:	90 91 ed 03 	lds	r25, 0x03ED	; 0x8003ed <BME680+0x4a>
    2b20:	60 93 35 02 	sts	0x0235, r22	; 0x800235 <loop::temp>
    2b24:	70 93 36 02 	sts	0x0236, r23	; 0x800236 <loop::temp+0x1>
    2b28:	80 93 37 02 	sts	0x0237, r24	; 0x800237 <loop::temp+0x2>
    2b2c:	90 93 38 02 	sts	0x0238, r25	; 0x800238 <loop::temp+0x3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:785
  hum            = _Humidity;                // Copy global variables to parameters
    2b30:	00 91 f2 03 	lds	r16, 0x03F2	; 0x8003f2 <BME680+0x4f>
    2b34:	10 91 f3 03 	lds	r17, 0x03F3	; 0x8003f3 <BME680+0x50>
    2b38:	20 91 f4 03 	lds	r18, 0x03F4	; 0x8003f4 <BME680+0x51>
    2b3c:	30 91 f5 03 	lds	r19, 0x03F5	; 0x8003f5 <BME680+0x52>
    2b40:	00 93 31 02 	sts	0x0231, r16	; 0x800231 <loop::humidity>
    2b44:	10 93 32 02 	sts	0x0232, r17	; 0x800232 <loop::humidity+0x1>
    2b48:	20 93 33 02 	sts	0x0233, r18	; 0x800233 <loop::humidity+0x2>
    2b4c:	30 93 34 02 	sts	0x0234, r19	; 0x800234 <loop::humidity+0x3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:786
  press          = _Pressure;                // Copy global variables to parameters
    2b50:	00 91 ee 03 	lds	r16, 0x03EE	; 0x8003ee <BME680+0x4b>
    2b54:	10 91 ef 03 	lds	r17, 0x03EF	; 0x8003ef <BME680+0x4c>
    2b58:	20 91 f0 03 	lds	r18, 0x03F0	; 0x8003f0 <BME680+0x4d>
    2b5c:	30 91 f1 03 	lds	r19, 0x03F1	; 0x8003f1 <BME680+0x4e>
    2b60:	00 93 2d 02 	sts	0x022D, r16	; 0x80022d <loop::pressure>
    2b64:	10 93 2e 02 	sts	0x022E, r17	; 0x80022e <loop::pressure+0x1>
    2b68:	20 93 2f 02 	sts	0x022F, r18	; 0x80022f <loop::pressure+0x2>
    2b6c:	30 93 30 02 	sts	0x0230, r19	; 0x800230 <loop::pressure+0x3>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:787
  gas            = _Gas;                     // Copy global variables to parameters
    2b70:	00 91 f6 03 	lds	r16, 0x03F6	; 0x8003f6 <BME680+0x53>
    2b74:	10 91 f7 03 	lds	r17, 0x03F7	; 0x8003f7 <BME680+0x54>
    2b78:	20 91 f8 03 	lds	r18, 0x03F8	; 0x8003f8 <BME680+0x55>
    2b7c:	30 91 f9 03 	lds	r19, 0x03F9	; 0x8003f9 <BME680+0x56>
    2b80:	00 93 29 02 	sts	0x0229, r16	; 0x800229 <loop::gas>
    2b84:	10 93 2a 02 	sts	0x022A, r17	; 0x80022a <loop::gas+0x1>
    2b88:	20 93 2b 02 	sts	0x022B, r18	; 0x80022b <loop::gas+0x2>
    2b8c:	30 93 2c 02 	sts	0x022C, r19	; 0x80022c <loop::gas+0x3>
loop():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:65
  if (loopCounter % 25 == 0) {                   // Show header @25 loops
    Serial.print(F("\nLoop Temp\xC2\xB0\x43 Humid% Press hPa   Alt m Air m"));
    Serial.print(F("\xE2\x84\xA6\n==== ====== ====== ========= ======= ======\n"));  // "�C" symbol
  }                                                                                  // if-then time to show headers
  BME680.getSensorData(temp, humidity, pressure, gas);                               // Get readings
  if (loopCounter++ != 0) {                                                          // Ignore first reading, might be incorrect
    2b90:	c2 55       	subi	r28, 0x52	; 82
    2b92:	df 4f       	sbci	r29, 0xFF	; 255
    2b94:	28 81       	ld	r18, Y
    2b96:	39 81       	ldd	r19, Y+1	; 0x01
    2b98:	ce 5a       	subi	r28, 0xAE	; 174
    2b9a:	d0 40       	sbci	r29, 0x00	; 0
    2b9c:	2f 5f       	subi	r18, 0xFF	; 255
    2b9e:	3f 4f       	sbci	r19, 0xFF	; 255
    2ba0:	30 93 3a 02 	sts	0x023A, r19	; 0x80023a <loop::loopCounter+0x1>
    2ba4:	20 93 39 02 	sts	0x0239, r18	; 0x800239 <loop::loopCounter>
    2ba8:	c2 55       	subi	r28, 0x52	; 82
    2baa:	df 4f       	sbci	r29, 0xFF	; 255
    2bac:	c8 80       	ld	r12, Y
    2bae:	d9 80       	ldd	r13, Y+1	; 0x01
    2bb0:	ce 5a       	subi	r28, 0xAE	; 174
    2bb2:	d0 40       	sbci	r29, 0x00	; 0
    2bb4:	cd 28       	or	r12, r13
    2bb6:	09 f4       	brne	.+2      	; 0x2bba <main+0x1a98>
    2bb8:	e0 c0       	rjmp	.+448    	; 0x2d7a <main+0x1c58>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:67
    sprintf(buf, "%4d %3d.%02d", (loopCounter - 1) % 9999,                           // Clamp to 9999,
            (int8_t)(temp / 100), (uint8_t)(temp % 100));                            // Temp in decidegrees
    2bba:	24 e6       	ldi	r18, 0x64	; 100
    2bbc:	30 e0       	ldi	r19, 0x00	; 0
    2bbe:	40 e0       	ldi	r20, 0x00	; 0
    2bc0:	50 e0       	ldi	r21, 0x00	; 0
    2bc2:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:66
    Serial.print(F("\nLoop Temp\xC2\xB0\x43 Humid% Press hPa   Alt m Air m"));
    Serial.print(F("\xE2\x84\xA6\n==== ====== ====== ========= ======= ======\n"));  // "�C" symbol
  }                                                                                  // if-then time to show headers
  BME680.getSensorData(temp, humidity, pressure, gas);                               // Get readings
  if (loopCounter++ != 0) {                                                          // Ignore first reading, might be incorrect
    sprintf(buf, "%4d %3d.%02d", (loopCounter - 1) % 9999,                           // Clamp to 9999,
    2bc6:	1f 92       	push	r1
    2bc8:	6f 93       	push	r22
    2bca:	02 2e       	mov	r0, r18
    2bcc:	00 0c       	add	r0, r0
    2bce:	33 0b       	sbc	r19, r19
    2bd0:	3f 93       	push	r19
    2bd2:	2f 93       	push	r18
    2bd4:	c2 55       	subi	r28, 0x52	; 82
    2bd6:	df 4f       	sbci	r29, 0xFF	; 255
    2bd8:	88 81       	ld	r24, Y
    2bda:	99 81       	ldd	r25, Y+1	; 0x01
    2bdc:	ce 5a       	subi	r28, 0xAE	; 174
    2bde:	d0 40       	sbci	r29, 0x00	; 0
    2be0:	6f e0       	ldi	r22, 0x0F	; 15
    2be2:	77 e2       	ldi	r23, 0x27	; 39
    2be4:	0e 94 68 1d 	call	0x3ad0	; 0x3ad0 <__udivmodhi4>
    2be8:	9f 93       	push	r25
    2bea:	8f 93       	push	r24
    2bec:	89 ea       	ldi	r24, 0xA9	; 169
    2bee:	e8 2e       	mov	r14, r24
    2bf0:	81 e0       	ldi	r24, 0x01	; 1
    2bf2:	f8 2e       	mov	r15, r24
    2bf4:	ff 92       	push	r15
    2bf6:	ef 92       	push	r14
    2bf8:	24 e4       	ldi	r18, 0x44	; 68
    2bfa:	32 e0       	ldi	r19, 0x02	; 2
    2bfc:	3f 93       	push	r19
    2bfe:	2f 93       	push	r18
    2c00:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <sprintf>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:68
            (int8_t)(temp / 100), (uint8_t)(temp % 100));                            // Temp in decidegrees
    Serial.print(buf);
    2c04:	0e 94 72 06 	call	0xce4	; 0xce4 <Print::print(char const*) [clone .constprop.9]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:70
    sprintf(buf, "%3d.%03d", (int8_t)(humidity / 1000),
            (uint16_t)(humidity % 1000));  // Humidity milli-pct
    2c08:	60 91 31 02 	lds	r22, 0x0231	; 0x800231 <loop::humidity>
    2c0c:	70 91 32 02 	lds	r23, 0x0232	; 0x800232 <loop::humidity+0x1>
    2c10:	80 91 33 02 	lds	r24, 0x0233	; 0x800233 <loop::humidity+0x2>
    2c14:	90 91 34 02 	lds	r25, 0x0234	; 0x800234 <loop::humidity+0x3>
    2c18:	28 ee       	ldi	r18, 0xE8	; 232
    2c1a:	33 e0       	ldi	r19, 0x03	; 3
    2c1c:	40 e0       	ldi	r20, 0x00	; 0
    2c1e:	50 e0       	ldi	r21, 0x00	; 0
    2c20:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:69
  BME680.getSensorData(temp, humidity, pressure, gas);                               // Get readings
  if (loopCounter++ != 0) {                                                          // Ignore first reading, might be incorrect
    sprintf(buf, "%4d %3d.%02d", (loopCounter - 1) % 9999,                           // Clamp to 9999,
            (int8_t)(temp / 100), (uint8_t)(temp % 100));                            // Temp in decidegrees
    Serial.print(buf);
    sprintf(buf, "%3d.%03d", (int8_t)(humidity / 1000),
    2c24:	7f 93       	push	r23
    2c26:	6f 93       	push	r22
    2c28:	02 2e       	mov	r0, r18
    2c2a:	00 0c       	add	r0, r0
    2c2c:	33 0b       	sbc	r19, r19
    2c2e:	3f 93       	push	r19
    2c30:	2f 93       	push	r18
    2c32:	86 eb       	ldi	r24, 0xB6	; 182
    2c34:	91 e0       	ldi	r25, 0x01	; 1
    2c36:	9f 93       	push	r25
    2c38:	8f 93       	push	r24
    2c3a:	64 e4       	ldi	r22, 0x44	; 68
    2c3c:	72 e0       	ldi	r23, 0x02	; 2
    2c3e:	7f 93       	push	r23
    2c40:	6f 93       	push	r22
    2c42:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <sprintf>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:71
            (uint16_t)(humidity % 1000));  // Humidity milli-pct
    Serial.print(buf);
    2c46:	0e 94 72 06 	call	0xce4	; 0xce4 <Print::print(char const*) [clone .constprop.9]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:73
    sprintf(buf, "%7d.%02d", (int16_t)(pressure / 100),
            (uint8_t)(pressure % 100));  // Pressure Pascals
    2c4a:	60 91 2d 02 	lds	r22, 0x022D	; 0x80022d <loop::pressure>
    2c4e:	70 91 2e 02 	lds	r23, 0x022E	; 0x80022e <loop::pressure+0x1>
    2c52:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <loop::pressure+0x2>
    2c56:	90 91 30 02 	lds	r25, 0x0230	; 0x800230 <loop::pressure+0x3>
    2c5a:	24 e6       	ldi	r18, 0x64	; 100
    2c5c:	30 e0       	ldi	r19, 0x00	; 0
    2c5e:	40 e0       	ldi	r20, 0x00	; 0
    2c60:	50 e0       	ldi	r21, 0x00	; 0
    2c62:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:72
            (int8_t)(temp / 100), (uint8_t)(temp % 100));                            // Temp in decidegrees
    Serial.print(buf);
    sprintf(buf, "%3d.%03d", (int8_t)(humidity / 1000),
            (uint16_t)(humidity % 1000));  // Humidity milli-pct
    Serial.print(buf);
    sprintf(buf, "%7d.%02d", (int16_t)(pressure / 100),
    2c66:	1f 92       	push	r1
    2c68:	6f 93       	push	r22
    2c6a:	3f 93       	push	r19
    2c6c:	2f 93       	push	r18
    2c6e:	8f eb       	ldi	r24, 0xBF	; 191
    2c70:	91 e0       	ldi	r25, 0x01	; 1
    2c72:	9f 93       	push	r25
    2c74:	8f 93       	push	r24
    2c76:	a4 e4       	ldi	r26, 0x44	; 68
    2c78:	b2 e0       	ldi	r27, 0x02	; 2
    2c7a:	bf 93       	push	r27
    2c7c:	af 93       	push	r26
    2c7e:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <sprintf>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:74
            (uint8_t)(pressure % 100));  // Pressure Pascals
    Serial.print(buf);
    2c82:	0e 94 72 06 	call	0xce4	; 0xce4 <Print::print(char const*) [clone .constprop.9]>
altitude():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:19
//< Forward function declaration with default value for sea level
float altitude(const int32_t press, const float seaLevel = 1013.25);
float altitude(const int32_t press, const float seaLevel) {
  static float Altitude;
  Altitude =
    44330.0 * (1.0 - pow(((float)press / 100.0) / seaLevel, 0.1903));  // Convert into meters
    2c86:	60 91 2d 02 	lds	r22, 0x022D	; 0x80022d <loop::pressure>
    2c8a:	70 91 2e 02 	lds	r23, 0x022E	; 0x80022e <loop::pressure+0x1>
    2c8e:	80 91 2f 02 	lds	r24, 0x022F	; 0x80022f <loop::pressure+0x2>
    2c92:	90 91 30 02 	lds	r25, 0x0230	; 0x800230 <loop::pressure+0x3>
    2c96:	0e 94 68 19 	call	0x32d0	; 0x32d0 <__floatsisf>
    2c9a:	20 e0       	ldi	r18, 0x00	; 0
    2c9c:	30 e0       	ldi	r19, 0x00	; 0
    2c9e:	48 ec       	ldi	r20, 0xC8	; 200
    2ca0:	52 e4       	ldi	r21, 0x42	; 66
    2ca2:	0e 94 1f 1b 	call	0x363e	; 0x363e <__divsf3>
    2ca6:	20 e0       	ldi	r18, 0x00	; 0
    2ca8:	30 e5       	ldi	r19, 0x50	; 80
    2caa:	4d e7       	ldi	r20, 0x7D	; 125
    2cac:	54 e4       	ldi	r21, 0x44	; 68
    2cae:	0e 94 1f 1b 	call	0x363e	; 0x363e <__divsf3>
    2cb2:	21 e0       	ldi	r18, 0x01	; 1
    2cb4:	3e ed       	ldi	r19, 0xDE	; 222
    2cb6:	42 e4       	ldi	r20, 0x42	; 66
    2cb8:	5e e3       	ldi	r21, 0x3E	; 62
    2cba:	0e 94 c7 1b 	call	0x378e	; 0x378e <pow>
    2cbe:	9b 01       	movw	r18, r22
    2cc0:	ac 01       	movw	r20, r24
    2cc2:	60 e0       	ldi	r22, 0x00	; 0
    2cc4:	70 e0       	ldi	r23, 0x00	; 0
    2cc6:	80 e8       	ldi	r24, 0x80	; 128
    2cc8:	9f e3       	ldi	r25, 0x3F	; 63
    2cca:	0e 94 b2 1a 	call	0x3564	; 0x3564 <__subsf3>
    2cce:	20 e0       	ldi	r18, 0x00	; 0
    2cd0:	3a e2       	ldi	r19, 0x2A	; 42
    2cd2:	4d e2       	ldi	r20, 0x2D	; 45
    2cd4:	57 e4       	ldi	r21, 0x47	; 71
    2cd6:	0e 94 a3 19 	call	0x3346	; 0x3346 <__mulsf3>
    2cda:	6b 01       	movw	r12, r22
    2cdc:	7c 01       	movw	r14, r24
loop():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:76
    Serial.print(buf);
    sprintf(buf, "%7d.%02d", (int16_t)(pressure / 100),
            (uint8_t)(pressure % 100));  // Pressure Pascals
    Serial.print(buf);
    alt = altitude(pressure);                                                // temp altitude
    sprintf(buf, "%5d.%02d", (int16_t)(alt), ((uint8_t)(alt * 100) % 100));  // Altitude meters
    2cde:	20 e0       	ldi	r18, 0x00	; 0
    2ce0:	30 e0       	ldi	r19, 0x00	; 0
    2ce2:	48 ec       	ldi	r20, 0xC8	; 200
    2ce4:	52 e4       	ldi	r21, 0x42	; 66
    2ce6:	0e 94 a3 19 	call	0x3346	; 0x3346 <__mulsf3>
    2cea:	0e 94 98 1b 	call	0x3730	; 0x3730 <__fixunssfsi>
    2cee:	86 2f       	mov	r24, r22
    2cf0:	64 e6       	ldi	r22, 0x64	; 100
    2cf2:	0e 94 5c 1d 	call	0x3ab8	; 0x3ab8 <__udivmodqi4>
    2cf6:	1f 92       	push	r1
    2cf8:	9f 93       	push	r25
    2cfa:	c7 01       	movw	r24, r14
    2cfc:	b6 01       	movw	r22, r12
    2cfe:	0e 94 91 1b 	call	0x3722	; 0x3722 <__fixsfsi>
    2d02:	7f 93       	push	r23
    2d04:	6f 93       	push	r22
    2d06:	88 ec       	ldi	r24, 0xC8	; 200
    2d08:	91 e0       	ldi	r25, 0x01	; 1
    2d0a:	9f 93       	push	r25
    2d0c:	8f 93       	push	r24
    2d0e:	94 e4       	ldi	r25, 0x44	; 68
    2d10:	a9 2e       	mov	r10, r25
    2d12:	92 e0       	ldi	r25, 0x02	; 2
    2d14:	b9 2e       	mov	r11, r25
    2d16:	bf 92       	push	r11
    2d18:	af 92       	push	r10
    2d1a:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <sprintf>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:77
    Serial.print(buf);
    2d1e:	0f b6       	in	r0, 0x3f	; 63
    2d20:	f8 94       	cli
    2d22:	de bf       	out	0x3e, r29	; 62
    2d24:	0f be       	out	0x3f, r0	; 63
    2d26:	cd bf       	out	0x3d, r28	; 61
    2d28:	0e 94 72 06 	call	0xce4	; 0xce4 <Print::print(char const*) [clone .constprop.9]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:78
    sprintf(buf, "%4d.%02d\n", (int16_t)(gas / 100), (uint8_t)(gas % 100));  // Resistance milliohms
    2d2c:	60 91 29 02 	lds	r22, 0x0229	; 0x800229 <loop::gas>
    2d30:	70 91 2a 02 	lds	r23, 0x022A	; 0x80022a <loop::gas+0x1>
    2d34:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <loop::gas+0x2>
    2d38:	90 91 2c 02 	lds	r25, 0x022C	; 0x80022c <loop::gas+0x3>
    2d3c:	24 e6       	ldi	r18, 0x64	; 100
    2d3e:	30 e0       	ldi	r19, 0x00	; 0
    2d40:	40 e0       	ldi	r20, 0x00	; 0
    2d42:	50 e0       	ldi	r21, 0x00	; 0
    2d44:	0e 94 9e 1d 	call	0x3b3c	; 0x3b3c <__divmodsi4>
    2d48:	1f 92       	push	r1
    2d4a:	6f 93       	push	r22
    2d4c:	3f 93       	push	r19
    2d4e:	2f 93       	push	r18
    2d50:	81 ed       	ldi	r24, 0xD1	; 209
    2d52:	91 e0       	ldi	r25, 0x01	; 1
    2d54:	9f 93       	push	r25
    2d56:	8f 93       	push	r24
    2d58:	bf 92       	push	r11
    2d5a:	af 92       	push	r10
    2d5c:	0e 94 45 1f 	call	0x3e8a	; 0x3e8a <sprintf>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:79
    Serial.print(buf);
    2d60:	0e 94 72 06 	call	0xce4	; 0xce4 <Print::print(char const*) [clone .constprop.9]>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680andIR.ino:80
    delay(10000);  // Wait 10s
    2d64:	60 e1       	ldi	r22, 0x10	; 16
    2d66:	77 e2       	ldi	r23, 0x27	; 39
    2d68:	80 e0       	ldi	r24, 0x00	; 0
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	0e 94 a2 02 	call	0x544	; 0x544 <delay>
    2d70:	0f b6       	in	r0, 0x3f	; 63
    2d72:	f8 94       	cli
    2d74:	de bf       	out	0x3e, r29	; 62
    2d76:	0f be       	out	0x3f, r0	; 63
    2d78:	cd bf       	out	0x3d, r28	; 61
serialEventRun():
C:\Users\eroshandel\AppData\Local\Arduino15\packages\MiniCore\hardware\avr\3.0.2\cores\MCUdude_corefiles/HardwareSerial.cpp:67
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
    2d7a:	80 e0       	ldi	r24, 0x00	; 0
    2d7c:	90 e0       	ldi	r25, 0x00	; 0
    2d7e:	89 2b       	or	r24, r25
    2d80:	11 f4       	brne	.+4      	; 0x2d86 <main+0x1c64>
    2d82:	0c 94 8e 0c 	jmp	0x191c	; 0x191c <main+0x7fa>
    2d86:	0e 94 40 03 	call	0x680	; 0x680 <Serial0_available()>
    2d8a:	88 23       	and	r24, r24
    2d8c:	11 f4       	brne	.+4      	; 0x2d92 <main+0x1c70>
    2d8e:	0c 94 8e 0c 	jmp	0x191c	; 0x191c <main+0x7fa>
    2d92:	0e 94 00 00 	call	0	; 0x0 <__vectors>
    2d96:	0c 94 8e 0c 	jmp	0x191c	; 0x191c <main+0x7fa>
readSensors():
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:851
  _Pressure = (int32_t)((_Pressure - (var2 >> 12)) * ((uint32_t)3125));

  if (_Pressure >= INT32_C(0x40000000))  // Issue #26
    _Pressure = ((_Pressure / (uint32_t)var1) << 1);
  else
    _Pressure = ((_Pressure << 1) / (uint32_t)var1);
    2d9a:	66 0f       	add	r22, r22
    2d9c:	77 1f       	adc	r23, r23
    2d9e:	88 1f       	adc	r24, r24
    2da0:	99 1f       	adc	r25, r25
    2da2:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <__udivmodsi4>
    2da6:	15 ca       	rjmp	.-3030   	; 0x21d2 <main+0x10b0>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:878
  var5      = ((var3 >> 14) * (var3 >> 14)) >> 10;
  var6      = (var4 * var5) >> 1;
  _Humidity = (((var3 + var6) >> 10) * ((int32_t)1000)) >> 12;
  if (_Humidity > 100000) /* Cap at 100%rH */
    _Humidity = 100000;
  else if (_Humidity < 0)
    2da8:	b7 fd       	sbrc	r27, 7
    2daa:	09 c0       	rjmp	.+18     	; 0x2dbe <main+0x1c9c>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:875
  var3      = var1 * var2;
  var4      = (int32_t)_H6 << 7;
  var4      = ((var4) + ((temp_scaled * (int32_t)_H7) / ((int32_t)100))) >> 4;
  var5      = ((var3 >> 14) * (var3 >> 14)) >> 10;
  var6      = (var4 * var5) >> 1;
  _Humidity = (((var3 + var6) >> 10) * ((int32_t)1000)) >> 12;
    2dac:	80 93 f2 03 	sts	0x03F2, r24	; 0x8003f2 <BME680+0x4f>
    2db0:	90 93 f3 03 	sts	0x03F3, r25	; 0x8003f3 <BME680+0x50>
    2db4:	a0 93 f4 03 	sts	0x03F4, r26	; 0x8003f4 <BME680+0x51>
    2db8:	b0 93 f5 03 	sts	0x03F5, r27	; 0x8003f5 <BME680+0x52>
    2dbc:	55 cd       	rjmp	.-1366   	; 0x2868 <main+0x1746>
C:\0_IOT\Sources\FirstTempPrac\mixTry\BME680andIR/BME680mixIR.cpp:879
  if (_Humidity > 100000) /* Cap at 100%rH */
    _Humidity = 100000;
  else if (_Humidity < 0)
    _Humidity = 0;
    2dbe:	10 92 f2 03 	sts	0x03F2, r1	; 0x8003f2 <BME680+0x4f>
    2dc2:	10 92 f3 03 	sts	0x03F3, r1	; 0x8003f3 <BME680+0x50>
    2dc6:	10 92 f4 03 	sts	0x03F4, r1	; 0x8003f4 <BME680+0x51>
    2dca:	10 92 f5 03 	sts	0x03F5, r1	; 0x8003f5 <BME680+0x52>
    2dce:	4c cd       	rjmp	.-1384   	; 0x2868 <main+0x1746>

00002dd0 <vfprintf>:
vfprintf():
    2dd0:	ab e0       	ldi	r26, 0x0B	; 11
    2dd2:	b0 e0       	ldi	r27, 0x00	; 0
    2dd4:	ee ee       	ldi	r30, 0xEE	; 238
    2dd6:	f6 e1       	ldi	r31, 0x16	; 22
    2dd8:	0c 94 6c 1a 	jmp	0x34d8	; 0x34d8 <__prologue_saves__>
    2ddc:	7c 01       	movw	r14, r24
    2dde:	3b 01       	movw	r6, r22
    2de0:	8a 01       	movw	r16, r20
    2de2:	fc 01       	movw	r30, r24
    2de4:	17 82       	std	Z+7, r1	; 0x07
    2de6:	16 82       	std	Z+6, r1	; 0x06
    2de8:	83 81       	ldd	r24, Z+3	; 0x03
    2dea:	81 ff       	sbrs	r24, 1
    2dec:	c8 c1       	rjmp	.+912    	; 0x317e <vfprintf+0x3ae>
    2dee:	ce 01       	movw	r24, r28
    2df0:	01 96       	adiw	r24, 0x01	; 1
    2df2:	5c 01       	movw	r10, r24
    2df4:	f7 01       	movw	r30, r14
    2df6:	93 81       	ldd	r25, Z+3	; 0x03
    2df8:	f3 01       	movw	r30, r6
    2dfa:	93 fd       	sbrc	r25, 3
    2dfc:	85 91       	lpm	r24, Z+
    2dfe:	93 ff       	sbrs	r25, 3
    2e00:	81 91       	ld	r24, Z+
    2e02:	3f 01       	movw	r6, r30
    2e04:	88 23       	and	r24, r24
    2e06:	09 f4       	brne	.+2      	; 0x2e0a <vfprintf+0x3a>
    2e08:	53 c1       	rjmp	.+678    	; 0x30b0 <vfprintf+0x2e0>
    2e0a:	85 32       	cpi	r24, 0x25	; 37
    2e0c:	39 f4       	brne	.+14     	; 0x2e1c <vfprintf+0x4c>
    2e0e:	93 fd       	sbrc	r25, 3
    2e10:	85 91       	lpm	r24, Z+
    2e12:	93 ff       	sbrs	r25, 3
    2e14:	81 91       	ld	r24, Z+
    2e16:	3f 01       	movw	r6, r30
    2e18:	85 32       	cpi	r24, 0x25	; 37
    2e1a:	29 f4       	brne	.+10     	; 0x2e26 <vfprintf+0x56>
    2e1c:	b7 01       	movw	r22, r14
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    2e24:	e7 cf       	rjmp	.-50     	; 0x2df4 <vfprintf+0x24>
    2e26:	91 2c       	mov	r9, r1
    2e28:	21 2c       	mov	r2, r1
    2e2a:	31 2c       	mov	r3, r1
    2e2c:	ff e1       	ldi	r31, 0x1F	; 31
    2e2e:	f3 15       	cp	r31, r3
    2e30:	38 f0       	brcs	.+14     	; 0x2e40 <vfprintf+0x70>
    2e32:	8b 32       	cpi	r24, 0x2B	; 43
    2e34:	11 f1       	breq	.+68     	; 0x2e7a <vfprintf+0xaa>
    2e36:	90 f4       	brcc	.+36     	; 0x2e5c <vfprintf+0x8c>
    2e38:	80 32       	cpi	r24, 0x20	; 32
    2e3a:	09 f1       	breq	.+66     	; 0x2e7e <vfprintf+0xae>
    2e3c:	83 32       	cpi	r24, 0x23	; 35
    2e3e:	29 f1       	breq	.+74     	; 0x2e8a <vfprintf+0xba>
    2e40:	37 fc       	sbrc	r3, 7
    2e42:	3c c0       	rjmp	.+120    	; 0x2ebc <vfprintf+0xec>
    2e44:	20 ed       	ldi	r18, 0xD0	; 208
    2e46:	28 0f       	add	r18, r24
    2e48:	2a 30       	cpi	r18, 0x0A	; 10
    2e4a:	50 f5       	brcc	.+84     	; 0x2ea0 <vfprintf+0xd0>
    2e4c:	36 fe       	sbrs	r3, 6
    2e4e:	20 c0       	rjmp	.+64     	; 0x2e90 <vfprintf+0xc0>
    2e50:	8a e0       	ldi	r24, 0x0A	; 10
    2e52:	98 9e       	mul	r9, r24
    2e54:	20 0d       	add	r18, r0
    2e56:	11 24       	eor	r1, r1
    2e58:	92 2e       	mov	r9, r18
    2e5a:	06 c0       	rjmp	.+12     	; 0x2e68 <vfprintf+0x98>
    2e5c:	8d 32       	cpi	r24, 0x2D	; 45
    2e5e:	91 f0       	breq	.+36     	; 0x2e84 <vfprintf+0xb4>
    2e60:	80 33       	cpi	r24, 0x30	; 48
    2e62:	71 f7       	brne	.-36     	; 0x2e40 <vfprintf+0x70>
    2e64:	68 94       	set
    2e66:	30 f8       	bld	r3, 0
    2e68:	f3 01       	movw	r30, r6
    2e6a:	93 fd       	sbrc	r25, 3
    2e6c:	85 91       	lpm	r24, Z+
    2e6e:	93 ff       	sbrs	r25, 3
    2e70:	81 91       	ld	r24, Z+
    2e72:	3f 01       	movw	r6, r30
    2e74:	81 11       	cpse	r24, r1
    2e76:	da cf       	rjmp	.-76     	; 0x2e2c <vfprintf+0x5c>
    2e78:	21 c0       	rjmp	.+66     	; 0x2ebc <vfprintf+0xec>
    2e7a:	68 94       	set
    2e7c:	31 f8       	bld	r3, 1
    2e7e:	68 94       	set
    2e80:	32 f8       	bld	r3, 2
    2e82:	f2 cf       	rjmp	.-28     	; 0x2e68 <vfprintf+0x98>
    2e84:	68 94       	set
    2e86:	33 f8       	bld	r3, 3
    2e88:	ef cf       	rjmp	.-34     	; 0x2e68 <vfprintf+0x98>
    2e8a:	68 94       	set
    2e8c:	34 f8       	bld	r3, 4
    2e8e:	ec cf       	rjmp	.-40     	; 0x2e68 <vfprintf+0x98>
    2e90:	ea e0       	ldi	r30, 0x0A	; 10
    2e92:	2e 9e       	mul	r2, r30
    2e94:	20 0d       	add	r18, r0
    2e96:	11 24       	eor	r1, r1
    2e98:	22 2e       	mov	r2, r18
    2e9a:	68 94       	set
    2e9c:	35 f8       	bld	r3, 5
    2e9e:	e4 cf       	rjmp	.-56     	; 0x2e68 <vfprintf+0x98>
    2ea0:	8e 32       	cpi	r24, 0x2E	; 46
    2ea2:	29 f4       	brne	.+10     	; 0x2eae <vfprintf+0xde>
    2ea4:	36 fc       	sbrc	r3, 6
    2ea6:	04 c1       	rjmp	.+520    	; 0x30b0 <vfprintf+0x2e0>
    2ea8:	68 94       	set
    2eaa:	36 f8       	bld	r3, 6
    2eac:	dd cf       	rjmp	.-70     	; 0x2e68 <vfprintf+0x98>
    2eae:	8c 36       	cpi	r24, 0x6C	; 108
    2eb0:	19 f4       	brne	.+6      	; 0x2eb8 <vfprintf+0xe8>
    2eb2:	68 94       	set
    2eb4:	37 f8       	bld	r3, 7
    2eb6:	d8 cf       	rjmp	.-80     	; 0x2e68 <vfprintf+0x98>
    2eb8:	88 36       	cpi	r24, 0x68	; 104
    2eba:	b1 f2       	breq	.-84     	; 0x2e68 <vfprintf+0x98>
    2ebc:	98 2f       	mov	r25, r24
    2ebe:	9f 7d       	andi	r25, 0xDF	; 223
    2ec0:	95 54       	subi	r25, 0x45	; 69
    2ec2:	93 30       	cpi	r25, 0x03	; 3
    2ec4:	e0 f0       	brcs	.+56     	; 0x2efe <vfprintf+0x12e>
    2ec6:	83 36       	cpi	r24, 0x63	; 99
    2ec8:	a1 f1       	breq	.+104    	; 0x2f32 <vfprintf+0x162>
    2eca:	83 37       	cpi	r24, 0x73	; 115
    2ecc:	c1 f1       	breq	.+112    	; 0x2f3e <vfprintf+0x16e>
    2ece:	83 35       	cpi	r24, 0x53	; 83
    2ed0:	09 f0       	breq	.+2      	; 0x2ed4 <vfprintf+0x104>
    2ed2:	63 c0       	rjmp	.+198    	; 0x2f9a <vfprintf+0x1ca>
    2ed4:	28 01       	movw	r4, r16
    2ed6:	f2 e0       	ldi	r31, 0x02	; 2
    2ed8:	4f 0e       	add	r4, r31
    2eda:	51 1c       	adc	r5, r1
    2edc:	f8 01       	movw	r30, r16
    2ede:	c0 80       	ld	r12, Z
    2ee0:	d1 80       	ldd	r13, Z+1	; 0x01
    2ee2:	69 2d       	mov	r22, r9
    2ee4:	70 e0       	ldi	r23, 0x00	; 0
    2ee6:	36 fc       	sbrc	r3, 6
    2ee8:	02 c0       	rjmp	.+4      	; 0x2eee <vfprintf+0x11e>
    2eea:	6f ef       	ldi	r22, 0xFF	; 255
    2eec:	7f ef       	ldi	r23, 0xFF	; 255
    2eee:	c6 01       	movw	r24, r12
    2ef0:	0e 94 c2 18 	call	0x3184	; 0x3184 <strnlen_P>
    2ef4:	4c 01       	movw	r8, r24
    2ef6:	68 94       	set
    2ef8:	37 f8       	bld	r3, 7
    2efa:	82 01       	movw	r16, r4
    2efc:	0a c0       	rjmp	.+20     	; 0x2f12 <vfprintf+0x142>
    2efe:	0c 5f       	subi	r16, 0xFC	; 252
    2f00:	1f 4f       	sbci	r17, 0xFF	; 255
    2f02:	ff e3       	ldi	r31, 0x3F	; 63
    2f04:	f9 83       	std	Y+1, r31	; 0x01
    2f06:	88 24       	eor	r8, r8
    2f08:	83 94       	inc	r8
    2f0a:	91 2c       	mov	r9, r1
    2f0c:	65 01       	movw	r12, r10
    2f0e:	e8 94       	clt
    2f10:	37 f8       	bld	r3, 7
    2f12:	33 fe       	sbrs	r3, 3
    2f14:	2d c0       	rjmp	.+90     	; 0x2f70 <vfprintf+0x1a0>
    2f16:	52 2c       	mov	r5, r2
    2f18:	81 14       	cp	r8, r1
    2f1a:	91 04       	cpc	r9, r1
    2f1c:	71 f5       	brne	.+92     	; 0x2f7a <vfprintf+0x1aa>
    2f1e:	55 20       	and	r5, r5
    2f20:	09 f4       	brne	.+2      	; 0x2f24 <vfprintf+0x154>
    2f22:	68 cf       	rjmp	.-304    	; 0x2df4 <vfprintf+0x24>
    2f24:	b7 01       	movw	r22, r14
    2f26:	80 e2       	ldi	r24, 0x20	; 32
    2f28:	90 e0       	ldi	r25, 0x00	; 0
    2f2a:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    2f2e:	5a 94       	dec	r5
    2f30:	f6 cf       	rjmp	.-20     	; 0x2f1e <vfprintf+0x14e>
    2f32:	f8 01       	movw	r30, r16
    2f34:	80 81       	ld	r24, Z
    2f36:	89 83       	std	Y+1, r24	; 0x01
    2f38:	0e 5f       	subi	r16, 0xFE	; 254
    2f3a:	1f 4f       	sbci	r17, 0xFF	; 255
    2f3c:	e4 cf       	rjmp	.-56     	; 0x2f06 <vfprintf+0x136>
    2f3e:	28 01       	movw	r4, r16
    2f40:	f2 e0       	ldi	r31, 0x02	; 2
    2f42:	4f 0e       	add	r4, r31
    2f44:	51 1c       	adc	r5, r1
    2f46:	f8 01       	movw	r30, r16
    2f48:	c0 80       	ld	r12, Z
    2f4a:	d1 80       	ldd	r13, Z+1	; 0x01
    2f4c:	69 2d       	mov	r22, r9
    2f4e:	70 e0       	ldi	r23, 0x00	; 0
    2f50:	36 fc       	sbrc	r3, 6
    2f52:	02 c0       	rjmp	.+4      	; 0x2f58 <vfprintf+0x188>
    2f54:	6f ef       	ldi	r22, 0xFF	; 255
    2f56:	7f ef       	ldi	r23, 0xFF	; 255
    2f58:	c6 01       	movw	r24, r12
    2f5a:	0e 94 cd 18 	call	0x319a	; 0x319a <strnlen>
    2f5e:	4c 01       	movw	r8, r24
    2f60:	82 01       	movw	r16, r4
    2f62:	d5 cf       	rjmp	.-86     	; 0x2f0e <vfprintf+0x13e>
    2f64:	b7 01       	movw	r22, r14
    2f66:	80 e2       	ldi	r24, 0x20	; 32
    2f68:	90 e0       	ldi	r25, 0x00	; 0
    2f6a:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    2f6e:	2a 94       	dec	r2
    2f70:	28 14       	cp	r2, r8
    2f72:	19 04       	cpc	r1, r9
    2f74:	09 f0       	breq	.+2      	; 0x2f78 <vfprintf+0x1a8>
    2f76:	b0 f7       	brcc	.-20     	; 0x2f64 <vfprintf+0x194>
    2f78:	ce cf       	rjmp	.-100    	; 0x2f16 <vfprintf+0x146>
    2f7a:	f6 01       	movw	r30, r12
    2f7c:	37 fc       	sbrc	r3, 7
    2f7e:	85 91       	lpm	r24, Z+
    2f80:	37 fe       	sbrs	r3, 7
    2f82:	81 91       	ld	r24, Z+
    2f84:	6f 01       	movw	r12, r30
    2f86:	b7 01       	movw	r22, r14
    2f88:	90 e0       	ldi	r25, 0x00	; 0
    2f8a:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    2f8e:	51 10       	cpse	r5, r1
    2f90:	5a 94       	dec	r5
    2f92:	f1 e0       	ldi	r31, 0x01	; 1
    2f94:	8f 1a       	sub	r8, r31
    2f96:	91 08       	sbc	r9, r1
    2f98:	bf cf       	rjmp	.-130    	; 0x2f18 <vfprintf+0x148>
    2f9a:	84 36       	cpi	r24, 0x64	; 100
    2f9c:	19 f0       	breq	.+6      	; 0x2fa4 <vfprintf+0x1d4>
    2f9e:	89 36       	cpi	r24, 0x69	; 105
    2fa0:	09 f0       	breq	.+2      	; 0x2fa4 <vfprintf+0x1d4>
    2fa2:	77 c0       	rjmp	.+238    	; 0x3092 <vfprintf+0x2c2>
    2fa4:	f8 01       	movw	r30, r16
    2fa6:	37 fe       	sbrs	r3, 7
    2fa8:	6b c0       	rjmp	.+214    	; 0x3080 <vfprintf+0x2b0>
    2faa:	60 81       	ld	r22, Z
    2fac:	71 81       	ldd	r23, Z+1	; 0x01
    2fae:	82 81       	ldd	r24, Z+2	; 0x02
    2fb0:	93 81       	ldd	r25, Z+3	; 0x03
    2fb2:	0c 5f       	subi	r16, 0xFC	; 252
    2fb4:	1f 4f       	sbci	r17, 0xFF	; 255
    2fb6:	f3 2d       	mov	r31, r3
    2fb8:	ff 76       	andi	r31, 0x6F	; 111
    2fba:	3f 2e       	mov	r3, r31
    2fbc:	97 ff       	sbrs	r25, 7
    2fbe:	09 c0       	rjmp	.+18     	; 0x2fd2 <vfprintf+0x202>
    2fc0:	90 95       	com	r25
    2fc2:	80 95       	com	r24
    2fc4:	70 95       	com	r23
    2fc6:	61 95       	neg	r22
    2fc8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fca:	8f 4f       	sbci	r24, 0xFF	; 255
    2fcc:	9f 4f       	sbci	r25, 0xFF	; 255
    2fce:	68 94       	set
    2fd0:	37 f8       	bld	r3, 7
    2fd2:	2a e0       	ldi	r18, 0x0A	; 10
    2fd4:	30 e0       	ldi	r19, 0x00	; 0
    2fd6:	a5 01       	movw	r20, r10
    2fd8:	0e 94 08 19 	call	0x3210	; 0x3210 <__ultoa_invert>
    2fdc:	c8 2e       	mov	r12, r24
    2fde:	ca 18       	sub	r12, r10
    2fe0:	8c 2c       	mov	r8, r12
    2fe2:	43 2c       	mov	r4, r3
    2fe4:	36 fe       	sbrs	r3, 6
    2fe6:	0c c0       	rjmp	.+24     	; 0x3000 <vfprintf+0x230>
    2fe8:	e8 94       	clt
    2fea:	40 f8       	bld	r4, 0
    2fec:	c9 14       	cp	r12, r9
    2fee:	40 f4       	brcc	.+16     	; 0x3000 <vfprintf+0x230>
    2ff0:	34 fe       	sbrs	r3, 4
    2ff2:	05 c0       	rjmp	.+10     	; 0x2ffe <vfprintf+0x22e>
    2ff4:	32 fc       	sbrc	r3, 2
    2ff6:	03 c0       	rjmp	.+6      	; 0x2ffe <vfprintf+0x22e>
    2ff8:	f3 2d       	mov	r31, r3
    2ffa:	fe 7e       	andi	r31, 0xEE	; 238
    2ffc:	4f 2e       	mov	r4, r31
    2ffe:	89 2c       	mov	r8, r9
    3000:	44 fe       	sbrs	r4, 4
    3002:	95 c0       	rjmp	.+298    	; 0x312e <vfprintf+0x35e>
    3004:	fe 01       	movw	r30, r28
    3006:	ec 0d       	add	r30, r12
    3008:	f1 1d       	adc	r31, r1
    300a:	80 81       	ld	r24, Z
    300c:	80 33       	cpi	r24, 0x30	; 48
    300e:	09 f0       	breq	.+2      	; 0x3012 <vfprintf+0x242>
    3010:	87 c0       	rjmp	.+270    	; 0x3120 <vfprintf+0x350>
    3012:	24 2d       	mov	r18, r4
    3014:	29 7e       	andi	r18, 0xE9	; 233
    3016:	42 2e       	mov	r4, r18
    3018:	84 2d       	mov	r24, r4
    301a:	88 70       	andi	r24, 0x08	; 8
    301c:	58 2e       	mov	r5, r24
    301e:	43 fc       	sbrc	r4, 3
    3020:	95 c0       	rjmp	.+298    	; 0x314c <vfprintf+0x37c>
    3022:	40 fe       	sbrs	r4, 0
    3024:	8f c0       	rjmp	.+286    	; 0x3144 <vfprintf+0x374>
    3026:	9c 2c       	mov	r9, r12
    3028:	82 14       	cp	r8, r2
    302a:	18 f4       	brcc	.+6      	; 0x3032 <vfprintf+0x262>
    302c:	2c 0c       	add	r2, r12
    302e:	92 2c       	mov	r9, r2
    3030:	98 18       	sub	r9, r8
    3032:	44 fe       	sbrs	r4, 4
    3034:	91 c0       	rjmp	.+290    	; 0x3158 <vfprintf+0x388>
    3036:	b7 01       	movw	r22, r14
    3038:	80 e3       	ldi	r24, 0x30	; 48
    303a:	90 e0       	ldi	r25, 0x00	; 0
    303c:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    3040:	42 fe       	sbrs	r4, 2
    3042:	09 c0       	rjmp	.+18     	; 0x3056 <vfprintf+0x286>
    3044:	88 e7       	ldi	r24, 0x78	; 120
    3046:	90 e0       	ldi	r25, 0x00	; 0
    3048:	41 fe       	sbrs	r4, 1
    304a:	02 c0       	rjmp	.+4      	; 0x3050 <vfprintf+0x280>
    304c:	88 e5       	ldi	r24, 0x58	; 88
    304e:	90 e0       	ldi	r25, 0x00	; 0
    3050:	b7 01       	movw	r22, r14
    3052:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    3056:	c9 14       	cp	r12, r9
    3058:	08 f4       	brcc	.+2      	; 0x305c <vfprintf+0x28c>
    305a:	8a c0       	rjmp	.+276    	; 0x3170 <vfprintf+0x3a0>
    305c:	ca 94       	dec	r12
    305e:	d1 2c       	mov	r13, r1
    3060:	9f ef       	ldi	r25, 0xFF	; 255
    3062:	c9 1a       	sub	r12, r25
    3064:	d9 0a       	sbc	r13, r25
    3066:	ca 0c       	add	r12, r10
    3068:	db 1c       	adc	r13, r11
    306a:	f6 01       	movw	r30, r12
    306c:	82 91       	ld	r24, -Z
    306e:	6f 01       	movw	r12, r30
    3070:	b7 01       	movw	r22, r14
    3072:	90 e0       	ldi	r25, 0x00	; 0
    3074:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    3078:	ac 14       	cp	r10, r12
    307a:	bd 04       	cpc	r11, r13
    307c:	b1 f7       	brne	.-20     	; 0x306a <vfprintf+0x29a>
    307e:	4f cf       	rjmp	.-354    	; 0x2f1e <vfprintf+0x14e>
    3080:	60 81       	ld	r22, Z
    3082:	71 81       	ldd	r23, Z+1	; 0x01
    3084:	07 2e       	mov	r0, r23
    3086:	00 0c       	add	r0, r0
    3088:	88 0b       	sbc	r24, r24
    308a:	99 0b       	sbc	r25, r25
    308c:	0e 5f       	subi	r16, 0xFE	; 254
    308e:	1f 4f       	sbci	r17, 0xFF	; 255
    3090:	92 cf       	rjmp	.-220    	; 0x2fb6 <vfprintf+0x1e6>
    3092:	d3 2c       	mov	r13, r3
    3094:	e8 94       	clt
    3096:	d4 f8       	bld	r13, 4
    3098:	2a e0       	ldi	r18, 0x0A	; 10
    309a:	30 e0       	ldi	r19, 0x00	; 0
    309c:	85 37       	cpi	r24, 0x75	; 117
    309e:	39 f1       	breq	.+78     	; 0x30ee <vfprintf+0x31e>
    30a0:	23 2d       	mov	r18, r3
    30a2:	29 7f       	andi	r18, 0xF9	; 249
    30a4:	d2 2e       	mov	r13, r18
    30a6:	8f 36       	cpi	r24, 0x6F	; 111
    30a8:	01 f1       	breq	.+64     	; 0x30ea <vfprintf+0x31a>
    30aa:	48 f4       	brcc	.+18     	; 0x30be <vfprintf+0x2ee>
    30ac:	88 35       	cpi	r24, 0x58	; 88
    30ae:	a9 f0       	breq	.+42     	; 0x30da <vfprintf+0x30a>
    30b0:	f7 01       	movw	r30, r14
    30b2:	86 81       	ldd	r24, Z+6	; 0x06
    30b4:	97 81       	ldd	r25, Z+7	; 0x07
    30b6:	2b 96       	adiw	r28, 0x0b	; 11
    30b8:	e2 e1       	ldi	r30, 0x12	; 18
    30ba:	0c 94 88 1a 	jmp	0x3510	; 0x3510 <__epilogue_restores__>
    30be:	80 37       	cpi	r24, 0x70	; 112
    30c0:	49 f0       	breq	.+18     	; 0x30d4 <vfprintf+0x304>
    30c2:	88 37       	cpi	r24, 0x78	; 120
    30c4:	a9 f7       	brne	.-22     	; 0x30b0 <vfprintf+0x2e0>
    30c6:	d4 fe       	sbrs	r13, 4
    30c8:	02 c0       	rjmp	.+4      	; 0x30ce <vfprintf+0x2fe>
    30ca:	68 94       	set
    30cc:	d2 f8       	bld	r13, 2
    30ce:	20 e1       	ldi	r18, 0x10	; 16
    30d0:	30 e0       	ldi	r19, 0x00	; 0
    30d2:	0d c0       	rjmp	.+26     	; 0x30ee <vfprintf+0x31e>
    30d4:	68 94       	set
    30d6:	d4 f8       	bld	r13, 4
    30d8:	f6 cf       	rjmp	.-20     	; 0x30c6 <vfprintf+0x2f6>
    30da:	34 fe       	sbrs	r3, 4
    30dc:	03 c0       	rjmp	.+6      	; 0x30e4 <vfprintf+0x314>
    30de:	82 2f       	mov	r24, r18
    30e0:	86 60       	ori	r24, 0x06	; 6
    30e2:	d8 2e       	mov	r13, r24
    30e4:	20 e1       	ldi	r18, 0x10	; 16
    30e6:	32 e0       	ldi	r19, 0x02	; 2
    30e8:	02 c0       	rjmp	.+4      	; 0x30ee <vfprintf+0x31e>
    30ea:	28 e0       	ldi	r18, 0x08	; 8
    30ec:	30 e0       	ldi	r19, 0x00	; 0
    30ee:	f8 01       	movw	r30, r16
    30f0:	d7 fe       	sbrs	r13, 7
    30f2:	0f c0       	rjmp	.+30     	; 0x3112 <vfprintf+0x342>
    30f4:	60 81       	ld	r22, Z
    30f6:	71 81       	ldd	r23, Z+1	; 0x01
    30f8:	82 81       	ldd	r24, Z+2	; 0x02
    30fa:	93 81       	ldd	r25, Z+3	; 0x03
    30fc:	0c 5f       	subi	r16, 0xFC	; 252
    30fe:	1f 4f       	sbci	r17, 0xFF	; 255
    3100:	a5 01       	movw	r20, r10
    3102:	0e 94 08 19 	call	0x3210	; 0x3210 <__ultoa_invert>
    3106:	c8 2e       	mov	r12, r24
    3108:	ca 18       	sub	r12, r10
    310a:	3d 2c       	mov	r3, r13
    310c:	e8 94       	clt
    310e:	37 f8       	bld	r3, 7
    3110:	67 cf       	rjmp	.-306    	; 0x2fe0 <vfprintf+0x210>
    3112:	60 81       	ld	r22, Z
    3114:	71 81       	ldd	r23, Z+1	; 0x01
    3116:	90 e0       	ldi	r25, 0x00	; 0
    3118:	80 e0       	ldi	r24, 0x00	; 0
    311a:	0e 5f       	subi	r16, 0xFE	; 254
    311c:	1f 4f       	sbci	r17, 0xFF	; 255
    311e:	f0 cf       	rjmp	.-32     	; 0x3100 <vfprintf+0x330>
    3120:	42 fc       	sbrc	r4, 2
    3122:	02 c0       	rjmp	.+4      	; 0x3128 <vfprintf+0x358>
    3124:	83 94       	inc	r8
    3126:	78 cf       	rjmp	.-272    	; 0x3018 <vfprintf+0x248>
    3128:	83 94       	inc	r8
    312a:	83 94       	inc	r8
    312c:	75 cf       	rjmp	.-278    	; 0x3018 <vfprintf+0x248>
    312e:	84 2d       	mov	r24, r4
    3130:	86 78       	andi	r24, 0x86	; 134
    3132:	09 f4       	brne	.+2      	; 0x3136 <vfprintf+0x366>
    3134:	71 cf       	rjmp	.-286    	; 0x3018 <vfprintf+0x248>
    3136:	f6 cf       	rjmp	.-20     	; 0x3124 <vfprintf+0x354>
    3138:	b7 01       	movw	r22, r14
    313a:	80 e2       	ldi	r24, 0x20	; 32
    313c:	90 e0       	ldi	r25, 0x00	; 0
    313e:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    3142:	83 94       	inc	r8
    3144:	82 14       	cp	r8, r2
    3146:	c0 f3       	brcs	.-16     	; 0x3138 <vfprintf+0x368>
    3148:	51 2c       	mov	r5, r1
    314a:	73 cf       	rjmp	.-282    	; 0x3032 <vfprintf+0x262>
    314c:	52 2c       	mov	r5, r2
    314e:	58 18       	sub	r5, r8
    3150:	82 14       	cp	r8, r2
    3152:	08 f4       	brcc	.+2      	; 0x3156 <vfprintf+0x386>
    3154:	6e cf       	rjmp	.-292    	; 0x3032 <vfprintf+0x262>
    3156:	f8 cf       	rjmp	.-16     	; 0x3148 <vfprintf+0x378>
    3158:	84 2d       	mov	r24, r4
    315a:	86 78       	andi	r24, 0x86	; 134
    315c:	09 f4       	brne	.+2      	; 0x3160 <vfprintf+0x390>
    315e:	7b cf       	rjmp	.-266    	; 0x3056 <vfprintf+0x286>
    3160:	8b e2       	ldi	r24, 0x2B	; 43
    3162:	41 fe       	sbrs	r4, 1
    3164:	80 e2       	ldi	r24, 0x20	; 32
    3166:	47 fc       	sbrc	r4, 7
    3168:	8d e2       	ldi	r24, 0x2D	; 45
    316a:	b7 01       	movw	r22, r14
    316c:	90 e0       	ldi	r25, 0x00	; 0
    316e:	71 cf       	rjmp	.-286    	; 0x3052 <vfprintf+0x282>
    3170:	b7 01       	movw	r22, r14
    3172:	80 e3       	ldi	r24, 0x30	; 48
    3174:	90 e0       	ldi	r25, 0x00	; 0
    3176:	0e 94 d8 18 	call	0x31b0	; 0x31b0 <fputc>
    317a:	9a 94       	dec	r9
    317c:	6c cf       	rjmp	.-296    	; 0x3056 <vfprintf+0x286>
    317e:	8f ef       	ldi	r24, 0xFF	; 255
    3180:	9f ef       	ldi	r25, 0xFF	; 255
    3182:	99 cf       	rjmp	.-206    	; 0x30b6 <vfprintf+0x2e6>

00003184 <strnlen_P>:
strnlen_P():
    3184:	fc 01       	movw	r30, r24
    3186:	05 90       	lpm	r0, Z+
    3188:	61 50       	subi	r22, 0x01	; 1
    318a:	70 40       	sbci	r23, 0x00	; 0
    318c:	01 10       	cpse	r0, r1
    318e:	d8 f7       	brcc	.-10     	; 0x3186 <strnlen_P+0x2>
    3190:	80 95       	com	r24
    3192:	90 95       	com	r25
    3194:	8e 0f       	add	r24, r30
    3196:	9f 1f       	adc	r25, r31
    3198:	08 95       	ret

0000319a <strnlen>:
strnlen():
    319a:	fc 01       	movw	r30, r24
    319c:	61 50       	subi	r22, 0x01	; 1
    319e:	70 40       	sbci	r23, 0x00	; 0
    31a0:	01 90       	ld	r0, Z+
    31a2:	01 10       	cpse	r0, r1
    31a4:	d8 f7       	brcc	.-10     	; 0x319c <strnlen+0x2>
    31a6:	80 95       	com	r24
    31a8:	90 95       	com	r25
    31aa:	8e 0f       	add	r24, r30
    31ac:	9f 1f       	adc	r25, r31
    31ae:	08 95       	ret

000031b0 <fputc>:
fputc():
    31b0:	0f 93       	push	r16
    31b2:	1f 93       	push	r17
    31b4:	cf 93       	push	r28
    31b6:	df 93       	push	r29
    31b8:	18 2f       	mov	r17, r24
    31ba:	09 2f       	mov	r16, r25
    31bc:	eb 01       	movw	r28, r22
    31be:	8b 81       	ldd	r24, Y+3	; 0x03
    31c0:	81 fd       	sbrc	r24, 1
    31c2:	09 c0       	rjmp	.+18     	; 0x31d6 <fputc+0x26>
    31c4:	1f ef       	ldi	r17, 0xFF	; 255
    31c6:	0f ef       	ldi	r16, 0xFF	; 255
    31c8:	81 2f       	mov	r24, r17
    31ca:	90 2f       	mov	r25, r16
    31cc:	df 91       	pop	r29
    31ce:	cf 91       	pop	r28
    31d0:	1f 91       	pop	r17
    31d2:	0f 91       	pop	r16
    31d4:	08 95       	ret
    31d6:	82 ff       	sbrs	r24, 2
    31d8:	14 c0       	rjmp	.+40     	; 0x3202 <fputc+0x52>
    31da:	2e 81       	ldd	r18, Y+6	; 0x06
    31dc:	3f 81       	ldd	r19, Y+7	; 0x07
    31de:	8c 81       	ldd	r24, Y+4	; 0x04
    31e0:	9d 81       	ldd	r25, Y+5	; 0x05
    31e2:	28 17       	cp	r18, r24
    31e4:	39 07       	cpc	r19, r25
    31e6:	3c f4       	brge	.+14     	; 0x31f6 <fputc+0x46>
    31e8:	e8 81       	ld	r30, Y
    31ea:	f9 81       	ldd	r31, Y+1	; 0x01
    31ec:	cf 01       	movw	r24, r30
    31ee:	01 96       	adiw	r24, 0x01	; 1
    31f0:	99 83       	std	Y+1, r25	; 0x01
    31f2:	88 83       	st	Y, r24
    31f4:	10 83       	st	Z, r17
    31f6:	8e 81       	ldd	r24, Y+6	; 0x06
    31f8:	9f 81       	ldd	r25, Y+7	; 0x07
    31fa:	01 96       	adiw	r24, 0x01	; 1
    31fc:	9f 83       	std	Y+7, r25	; 0x07
    31fe:	8e 83       	std	Y+6, r24	; 0x06
    3200:	e3 cf       	rjmp	.-58     	; 0x31c8 <fputc+0x18>
    3202:	e8 85       	ldd	r30, Y+8	; 0x08
    3204:	f9 85       	ldd	r31, Y+9	; 0x09
    3206:	81 2f       	mov	r24, r17
    3208:	09 95       	icall
    320a:	89 2b       	or	r24, r25
    320c:	a1 f3       	breq	.-24     	; 0x31f6 <fputc+0x46>
    320e:	da cf       	rjmp	.-76     	; 0x31c4 <fputc+0x14>

00003210 <__ultoa_invert>:
__ultoa_invert():
    3210:	fa 01       	movw	r30, r20
    3212:	aa 27       	eor	r26, r26
    3214:	28 30       	cpi	r18, 0x08	; 8
    3216:	51 f1       	breq	.+84     	; 0x326c <__ultoa_invert+0x5c>
    3218:	20 31       	cpi	r18, 0x10	; 16
    321a:	81 f1       	breq	.+96     	; 0x327c <__ultoa_invert+0x6c>
    321c:	e8 94       	clt
    321e:	6f 93       	push	r22
    3220:	6e 7f       	andi	r22, 0xFE	; 254
    3222:	6e 5f       	subi	r22, 0xFE	; 254
    3224:	7f 4f       	sbci	r23, 0xFF	; 255
    3226:	8f 4f       	sbci	r24, 0xFF	; 255
    3228:	9f 4f       	sbci	r25, 0xFF	; 255
    322a:	af 4f       	sbci	r26, 0xFF	; 255
    322c:	b1 e0       	ldi	r27, 0x01	; 1
    322e:	3e d0       	rcall	.+124    	; 0x32ac <__ultoa_invert+0x9c>
    3230:	b4 e0       	ldi	r27, 0x04	; 4
    3232:	3c d0       	rcall	.+120    	; 0x32ac <__ultoa_invert+0x9c>
    3234:	67 0f       	add	r22, r23
    3236:	78 1f       	adc	r23, r24
    3238:	89 1f       	adc	r24, r25
    323a:	9a 1f       	adc	r25, r26
    323c:	a1 1d       	adc	r26, r1
    323e:	68 0f       	add	r22, r24
    3240:	79 1f       	adc	r23, r25
    3242:	8a 1f       	adc	r24, r26
    3244:	91 1d       	adc	r25, r1
    3246:	a1 1d       	adc	r26, r1
    3248:	6a 0f       	add	r22, r26
    324a:	71 1d       	adc	r23, r1
    324c:	81 1d       	adc	r24, r1
    324e:	91 1d       	adc	r25, r1
    3250:	a1 1d       	adc	r26, r1
    3252:	20 d0       	rcall	.+64     	; 0x3294 <__ultoa_invert+0x84>
    3254:	09 f4       	brne	.+2      	; 0x3258 <__ultoa_invert+0x48>
    3256:	68 94       	set
    3258:	3f 91       	pop	r19
    325a:	2a e0       	ldi	r18, 0x0A	; 10
    325c:	26 9f       	mul	r18, r22
    325e:	11 24       	eor	r1, r1
    3260:	30 19       	sub	r19, r0
    3262:	30 5d       	subi	r19, 0xD0	; 208
    3264:	31 93       	st	Z+, r19
    3266:	de f6       	brtc	.-74     	; 0x321e <__ultoa_invert+0xe>
    3268:	cf 01       	movw	r24, r30
    326a:	08 95       	ret
    326c:	46 2f       	mov	r20, r22
    326e:	47 70       	andi	r20, 0x07	; 7
    3270:	40 5d       	subi	r20, 0xD0	; 208
    3272:	41 93       	st	Z+, r20
    3274:	b3 e0       	ldi	r27, 0x03	; 3
    3276:	0f d0       	rcall	.+30     	; 0x3296 <__ultoa_invert+0x86>
    3278:	c9 f7       	brne	.-14     	; 0x326c <__ultoa_invert+0x5c>
    327a:	f6 cf       	rjmp	.-20     	; 0x3268 <__ultoa_invert+0x58>
    327c:	46 2f       	mov	r20, r22
    327e:	4f 70       	andi	r20, 0x0F	; 15
    3280:	40 5d       	subi	r20, 0xD0	; 208
    3282:	4a 33       	cpi	r20, 0x3A	; 58
    3284:	18 f0       	brcs	.+6      	; 0x328c <__ultoa_invert+0x7c>
    3286:	49 5d       	subi	r20, 0xD9	; 217
    3288:	31 fd       	sbrc	r19, 1
    328a:	40 52       	subi	r20, 0x20	; 32
    328c:	41 93       	st	Z+, r20
    328e:	02 d0       	rcall	.+4      	; 0x3294 <__ultoa_invert+0x84>
    3290:	a9 f7       	brne	.-22     	; 0x327c <__ultoa_invert+0x6c>
    3292:	ea cf       	rjmp	.-44     	; 0x3268 <__ultoa_invert+0x58>
    3294:	b4 e0       	ldi	r27, 0x04	; 4
    3296:	a6 95       	lsr	r26
    3298:	97 95       	ror	r25
    329a:	87 95       	ror	r24
    329c:	77 95       	ror	r23
    329e:	67 95       	ror	r22
    32a0:	ba 95       	dec	r27
    32a2:	c9 f7       	brne	.-14     	; 0x3296 <__ultoa_invert+0x86>
    32a4:	00 97       	sbiw	r24, 0x00	; 0
    32a6:	61 05       	cpc	r22, r1
    32a8:	71 05       	cpc	r23, r1
    32aa:	08 95       	ret
    32ac:	9b 01       	movw	r18, r22
    32ae:	ac 01       	movw	r20, r24
    32b0:	0a 2e       	mov	r0, r26
    32b2:	06 94       	lsr	r0
    32b4:	57 95       	ror	r21
    32b6:	47 95       	ror	r20
    32b8:	37 95       	ror	r19
    32ba:	27 95       	ror	r18
    32bc:	ba 95       	dec	r27
    32be:	c9 f7       	brne	.-14     	; 0x32b2 <__ultoa_invert+0xa2>
    32c0:	62 0f       	add	r22, r18
    32c2:	73 1f       	adc	r23, r19
    32c4:	84 1f       	adc	r24, r20
    32c6:	95 1f       	adc	r25, r21
    32c8:	a0 1d       	adc	r26, r0
    32ca:	08 95       	ret

000032cc <__floatunsisf>:
__floatunsisf():
    32cc:	e8 94       	clt
    32ce:	09 c0       	rjmp	.+18     	; 0x32e2 <__floatsisf+0x12>

000032d0 <__floatsisf>:
    32d0:	97 fb       	bst	r25, 7
    32d2:	3e f4       	brtc	.+14     	; 0x32e2 <__floatsisf+0x12>
    32d4:	90 95       	com	r25
    32d6:	80 95       	com	r24
    32d8:	70 95       	com	r23
    32da:	61 95       	neg	r22
    32dc:	7f 4f       	sbci	r23, 0xFF	; 255
    32de:	8f 4f       	sbci	r24, 0xFF	; 255
    32e0:	9f 4f       	sbci	r25, 0xFF	; 255
    32e2:	99 23       	and	r25, r25
    32e4:	a9 f0       	breq	.+42     	; 0x3310 <__floatsisf+0x40>
    32e6:	f9 2f       	mov	r31, r25
    32e8:	96 e9       	ldi	r25, 0x96	; 150
    32ea:	bb 27       	eor	r27, r27
    32ec:	93 95       	inc	r25
    32ee:	f6 95       	lsr	r31
    32f0:	87 95       	ror	r24
    32f2:	77 95       	ror	r23
    32f4:	67 95       	ror	r22
    32f6:	b7 95       	ror	r27
    32f8:	f1 11       	cpse	r31, r1
    32fa:	f8 cf       	rjmp	.-16     	; 0x32ec <__floatsisf+0x1c>
    32fc:	fa f4       	brpl	.+62     	; 0x333c <__floatsisf+0x6c>
    32fe:	bb 0f       	add	r27, r27
    3300:	11 f4       	brne	.+4      	; 0x3306 <__floatsisf+0x36>
    3302:	60 ff       	sbrs	r22, 0
    3304:	1b c0       	rjmp	.+54     	; 0x333c <__floatsisf+0x6c>
    3306:	6f 5f       	subi	r22, 0xFF	; 255
    3308:	7f 4f       	sbci	r23, 0xFF	; 255
    330a:	8f 4f       	sbci	r24, 0xFF	; 255
    330c:	9f 4f       	sbci	r25, 0xFF	; 255
    330e:	16 c0       	rjmp	.+44     	; 0x333c <__floatsisf+0x6c>
    3310:	88 23       	and	r24, r24
    3312:	11 f0       	breq	.+4      	; 0x3318 <__floatsisf+0x48>
    3314:	96 e9       	ldi	r25, 0x96	; 150
    3316:	11 c0       	rjmp	.+34     	; 0x333a <__floatsisf+0x6a>
    3318:	77 23       	and	r23, r23
    331a:	21 f0       	breq	.+8      	; 0x3324 <__floatsisf+0x54>
    331c:	9e e8       	ldi	r25, 0x8E	; 142
    331e:	87 2f       	mov	r24, r23
    3320:	76 2f       	mov	r23, r22
    3322:	05 c0       	rjmp	.+10     	; 0x332e <__floatsisf+0x5e>
    3324:	66 23       	and	r22, r22
    3326:	71 f0       	breq	.+28     	; 0x3344 <__floatsisf+0x74>
    3328:	96 e8       	ldi	r25, 0x86	; 134
    332a:	86 2f       	mov	r24, r22
    332c:	70 e0       	ldi	r23, 0x00	; 0
    332e:	60 e0       	ldi	r22, 0x00	; 0
    3330:	2a f0       	brmi	.+10     	; 0x333c <__floatsisf+0x6c>
    3332:	9a 95       	dec	r25
    3334:	66 0f       	add	r22, r22
    3336:	77 1f       	adc	r23, r23
    3338:	88 1f       	adc	r24, r24
    333a:	da f7       	brpl	.-10     	; 0x3332 <__floatsisf+0x62>
    333c:	88 0f       	add	r24, r24
    333e:	96 95       	lsr	r25
    3340:	87 95       	ror	r24
    3342:	97 f9       	bld	r25, 7
    3344:	08 95       	ret

00003346 <__mulsf3>:
__mulsf3():
    3346:	0e 94 b6 19 	call	0x336c	; 0x336c <__mulsf3x>
    334a:	0c 94 27 1a 	jmp	0x344e	; 0x344e <__fp_round>
    334e:	0e 94 19 1a 	call	0x3432	; 0x3432 <__fp_pscA>
    3352:	38 f0       	brcs	.+14     	; 0x3362 <__mulsf3+0x1c>
    3354:	0e 94 20 1a 	call	0x3440	; 0x3440 <__fp_pscB>
    3358:	20 f0       	brcs	.+8      	; 0x3362 <__mulsf3+0x1c>
    335a:	95 23       	and	r25, r21
    335c:	11 f0       	breq	.+4      	; 0x3362 <__mulsf3+0x1c>
    335e:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    3362:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>
    3366:	11 24       	eor	r1, r1
    3368:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>

0000336c <__mulsf3x>:
__mulsf3x():
    336c:	0e 94 38 1a 	call	0x3470	; 0x3470 <__fp_split3>
    3370:	70 f3       	brcs	.-36     	; 0x334e <__mulsf3+0x8>

00003372 <__mulsf3_pse>:
    3372:	95 9f       	mul	r25, r21
    3374:	c1 f3       	breq	.-16     	; 0x3366 <__mulsf3+0x20>
    3376:	95 0f       	add	r25, r21
    3378:	50 e0       	ldi	r21, 0x00	; 0
    337a:	55 1f       	adc	r21, r21
    337c:	62 9f       	mul	r22, r18
    337e:	f0 01       	movw	r30, r0
    3380:	72 9f       	mul	r23, r18
    3382:	bb 27       	eor	r27, r27
    3384:	f0 0d       	add	r31, r0
    3386:	b1 1d       	adc	r27, r1
    3388:	63 9f       	mul	r22, r19
    338a:	aa 27       	eor	r26, r26
    338c:	f0 0d       	add	r31, r0
    338e:	b1 1d       	adc	r27, r1
    3390:	aa 1f       	adc	r26, r26
    3392:	64 9f       	mul	r22, r20
    3394:	66 27       	eor	r22, r22
    3396:	b0 0d       	add	r27, r0
    3398:	a1 1d       	adc	r26, r1
    339a:	66 1f       	adc	r22, r22
    339c:	82 9f       	mul	r24, r18
    339e:	22 27       	eor	r18, r18
    33a0:	b0 0d       	add	r27, r0
    33a2:	a1 1d       	adc	r26, r1
    33a4:	62 1f       	adc	r22, r18
    33a6:	73 9f       	mul	r23, r19
    33a8:	b0 0d       	add	r27, r0
    33aa:	a1 1d       	adc	r26, r1
    33ac:	62 1f       	adc	r22, r18
    33ae:	83 9f       	mul	r24, r19
    33b0:	a0 0d       	add	r26, r0
    33b2:	61 1d       	adc	r22, r1
    33b4:	22 1f       	adc	r18, r18
    33b6:	74 9f       	mul	r23, r20
    33b8:	33 27       	eor	r19, r19
    33ba:	a0 0d       	add	r26, r0
    33bc:	61 1d       	adc	r22, r1
    33be:	23 1f       	adc	r18, r19
    33c0:	84 9f       	mul	r24, r20
    33c2:	60 0d       	add	r22, r0
    33c4:	21 1d       	adc	r18, r1
    33c6:	82 2f       	mov	r24, r18
    33c8:	76 2f       	mov	r23, r22
    33ca:	6a 2f       	mov	r22, r26
    33cc:	11 24       	eor	r1, r1
    33ce:	9f 57       	subi	r25, 0x7F	; 127
    33d0:	50 40       	sbci	r21, 0x00	; 0
    33d2:	9a f0       	brmi	.+38     	; 0x33fa <__mulsf3_pse+0x88>
    33d4:	f1 f0       	breq	.+60     	; 0x3412 <__mulsf3_pse+0xa0>
    33d6:	88 23       	and	r24, r24
    33d8:	4a f0       	brmi	.+18     	; 0x33ec <__mulsf3_pse+0x7a>
    33da:	ee 0f       	add	r30, r30
    33dc:	ff 1f       	adc	r31, r31
    33de:	bb 1f       	adc	r27, r27
    33e0:	66 1f       	adc	r22, r22
    33e2:	77 1f       	adc	r23, r23
    33e4:	88 1f       	adc	r24, r24
    33e6:	91 50       	subi	r25, 0x01	; 1
    33e8:	50 40       	sbci	r21, 0x00	; 0
    33ea:	a9 f7       	brne	.-22     	; 0x33d6 <__mulsf3_pse+0x64>
    33ec:	9e 3f       	cpi	r25, 0xFE	; 254
    33ee:	51 05       	cpc	r21, r1
    33f0:	80 f0       	brcs	.+32     	; 0x3412 <__mulsf3_pse+0xa0>
    33f2:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    33f6:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>
    33fa:	5f 3f       	cpi	r21, 0xFF	; 255
    33fc:	e4 f3       	brlt	.-8      	; 0x33f6 <__mulsf3_pse+0x84>
    33fe:	98 3e       	cpi	r25, 0xE8	; 232
    3400:	d4 f3       	brlt	.-12     	; 0x33f6 <__mulsf3_pse+0x84>
    3402:	86 95       	lsr	r24
    3404:	77 95       	ror	r23
    3406:	67 95       	ror	r22
    3408:	b7 95       	ror	r27
    340a:	f7 95       	ror	r31
    340c:	e7 95       	ror	r30
    340e:	9f 5f       	subi	r25, 0xFF	; 255
    3410:	c1 f7       	brne	.-16     	; 0x3402 <__mulsf3_pse+0x90>
    3412:	fe 2b       	or	r31, r30
    3414:	88 0f       	add	r24, r24
    3416:	91 1d       	adc	r25, r1
    3418:	96 95       	lsr	r25
    341a:	87 95       	ror	r24
    341c:	97 f9       	bld	r25, 7
    341e:	08 95       	ret

00003420 <__fp_inf>:
    3420:	97 f9       	bld	r25, 7
    3422:	9f 67       	ori	r25, 0x7F	; 127
    3424:	80 e8       	ldi	r24, 0x80	; 128
    3426:	70 e0       	ldi	r23, 0x00	; 0
    3428:	60 e0       	ldi	r22, 0x00	; 0
    342a:	08 95       	ret

0000342c <__fp_nan>:
    342c:	9f ef       	ldi	r25, 0xFF	; 255
    342e:	80 ec       	ldi	r24, 0xC0	; 192
    3430:	08 95       	ret

00003432 <__fp_pscA>:
    3432:	00 24       	eor	r0, r0
    3434:	0a 94       	dec	r0
    3436:	16 16       	cp	r1, r22
    3438:	17 06       	cpc	r1, r23
    343a:	18 06       	cpc	r1, r24
    343c:	09 06       	cpc	r0, r25
__fp_pscA():
    343e:	08 95       	ret

00003440 <__fp_pscB>:
__fp_pscB():
    3440:	00 24       	eor	r0, r0
    3442:	0a 94       	dec	r0
    3444:	12 16       	cp	r1, r18
    3446:	13 06       	cpc	r1, r19
    3448:	14 06       	cpc	r1, r20
    344a:	05 06       	cpc	r0, r21
    344c:	08 95       	ret

0000344e <__fp_round>:
__fp_round():
    344e:	09 2e       	mov	r0, r25
    3450:	03 94       	inc	r0
    3452:	00 0c       	add	r0, r0
    3454:	11 f4       	brne	.+4      	; 0x345a <__fp_round+0xc>
    3456:	88 23       	and	r24, r24
    3458:	52 f0       	brmi	.+20     	; 0x346e <__fp_round+0x20>
    345a:	bb 0f       	add	r27, r27
    345c:	40 f4       	brcc	.+16     	; 0x346e <__fp_round+0x20>
    345e:	bf 2b       	or	r27, r31
    3460:	11 f4       	brne	.+4      	; 0x3466 <__fp_round+0x18>
    3462:	60 ff       	sbrs	r22, 0
    3464:	04 c0       	rjmp	.+8      	; 0x346e <__fp_round+0x20>
    3466:	6f 5f       	subi	r22, 0xFF	; 255
    3468:	7f 4f       	sbci	r23, 0xFF	; 255
    346a:	8f 4f       	sbci	r24, 0xFF	; 255
    346c:	9f 4f       	sbci	r25, 0xFF	; 255
    346e:	08 95       	ret

00003470 <__fp_split3>:
__fp_split3():
    3470:	57 fd       	sbrc	r21, 7
    3472:	90 58       	subi	r25, 0x80	; 128
    3474:	44 0f       	add	r20, r20
    3476:	55 1f       	adc	r21, r21
    3478:	59 f0       	breq	.+22     	; 0x3490 <__fp_splitA+0x10>
    347a:	5f 3f       	cpi	r21, 0xFF	; 255
    347c:	71 f0       	breq	.+28     	; 0x349a <__fp_splitA+0x1a>
    347e:	47 95       	ror	r20

00003480 <__fp_splitA>:
    3480:	88 0f       	add	r24, r24
    3482:	97 fb       	bst	r25, 7
    3484:	99 1f       	adc	r25, r25
    3486:	61 f0       	breq	.+24     	; 0x34a0 <__fp_splitA+0x20>
    3488:	9f 3f       	cpi	r25, 0xFF	; 255
    348a:	79 f0       	breq	.+30     	; 0x34aa <__fp_splitA+0x2a>
    348c:	87 95       	ror	r24
    348e:	08 95       	ret
    3490:	12 16       	cp	r1, r18
    3492:	13 06       	cpc	r1, r19
    3494:	14 06       	cpc	r1, r20
    3496:	55 1f       	adc	r21, r21
    3498:	f2 cf       	rjmp	.-28     	; 0x347e <__fp_split3+0xe>
    349a:	46 95       	lsr	r20
    349c:	f1 df       	rcall	.-30     	; 0x3480 <__fp_splitA>
    349e:	08 c0       	rjmp	.+16     	; 0x34b0 <__fp_splitA+0x30>
    34a0:	16 16       	cp	r1, r22
    34a2:	17 06       	cpc	r1, r23
    34a4:	18 06       	cpc	r1, r24
    34a6:	99 1f       	adc	r25, r25
    34a8:	f1 cf       	rjmp	.-30     	; 0x348c <__fp_splitA+0xc>
    34aa:	86 95       	lsr	r24
    34ac:	71 05       	cpc	r23, r1
    34ae:	61 05       	cpc	r22, r1
    34b0:	08 94       	sec
    34b2:	08 95       	ret

000034b4 <__fp_zero>:
__fp_zero():
    34b4:	e8 94       	clt

000034b6 <__fp_szero>:
    34b6:	bb 27       	eor	r27, r27
    34b8:	66 27       	eor	r22, r22
    34ba:	77 27       	eor	r23, r23
    34bc:	cb 01       	movw	r24, r22
    34be:	97 f9       	bld	r25, 7
    34c0:	08 95       	ret

000034c2 <__muluhisi3>:
__muluhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    34c2:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    34c6:	a5 9f       	mul	r26, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    34c8:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    34ca:	b4 9f       	mul	r27, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    34cc:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    34ce:	a4 9f       	mul	r26, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    34d0:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    34d2:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    34d4:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    34d6:	08 95       	ret

000034d8 <__prologue_saves__>:
__prologue_saves__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2169
    34d8:	2f 92       	push	r2
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2170
    34da:	3f 92       	push	r3
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2171
    34dc:	4f 92       	push	r4
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2172
    34de:	5f 92       	push	r5
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2173
    34e0:	6f 92       	push	r6
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2174
    34e2:	7f 92       	push	r7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2175
    34e4:	8f 92       	push	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2176
    34e6:	9f 92       	push	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2177
    34e8:	af 92       	push	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2178
    34ea:	bf 92       	push	r11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2179
    34ec:	cf 92       	push	r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2180
    34ee:	df 92       	push	r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2181
    34f0:	ef 92       	push	r14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2182
    34f2:	ff 92       	push	r15
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2183
    34f4:	0f 93       	push	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2184
    34f6:	1f 93       	push	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2185
    34f8:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2186
    34fa:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2200
    34fc:	cd b7       	in	r28, 0x3d	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2201
    34fe:	de b7       	in	r29, 0x3e	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2202
    3500:	ca 1b       	sub	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2203
    3502:	db 0b       	sbc	r29, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2204
    3504:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2205
    3506:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2206
    3508:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2207
    350a:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2208
    350c:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2211
    350e:	09 94       	ijmp

00003510 <__epilogue_restores__>:
__epilogue_restores__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2222
    3510:	2a 88       	ldd	r2, Y+18	; 0x12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2223
    3512:	39 88       	ldd	r3, Y+17	; 0x11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2224
    3514:	48 88       	ldd	r4, Y+16	; 0x10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2225
    3516:	5f 84       	ldd	r5, Y+15	; 0x0f
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2226
    3518:	6e 84       	ldd	r6, Y+14	; 0x0e
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2227
    351a:	7d 84       	ldd	r7, Y+13	; 0x0d
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2228
    351c:	8c 84       	ldd	r8, Y+12	; 0x0c
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2229
    351e:	9b 84       	ldd	r9, Y+11	; 0x0b
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2230
    3520:	aa 84       	ldd	r10, Y+10	; 0x0a
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2231
    3522:	b9 84       	ldd	r11, Y+9	; 0x09
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2232
    3524:	c8 84       	ldd	r12, Y+8	; 0x08
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2233
    3526:	df 80       	ldd	r13, Y+7	; 0x07
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2234
    3528:	ee 80       	ldd	r14, Y+6	; 0x06
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2235
    352a:	fd 80       	ldd	r15, Y+5	; 0x05
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2236
    352c:	0c 81       	ldd	r16, Y+4	; 0x04
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2237
    352e:	1b 81       	ldd	r17, Y+3	; 0x03
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2238
    3530:	aa 81       	ldd	r26, Y+2	; 0x02
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2252
    3532:	b9 81       	ldd	r27, Y+1	; 0x01
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2253
    3534:	ce 0f       	add	r28, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2254
    3536:	d1 1d       	adc	r29, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2255
    3538:	0f b6       	in	r0, 0x3f	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2256
    353a:	f8 94       	cli
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2257
    353c:	de bf       	out	0x3e, r29	; 62
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2258
    353e:	0f be       	out	0x3f, r0	; 63
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2259
    3540:	cd bf       	out	0x3d, r28	; 61
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2260
    3542:	ed 01       	movw	r28, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2263
    3544:	08 95       	ret

00003546 <__umulhisi3>:
__umulhisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:564
    3546:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    3548:	b0 01       	movw	r22, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    354a:	b3 9f       	mul	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    354c:	c0 01       	movw	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    354e:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    3550:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    3552:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    3554:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    3556:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    3558:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    355a:	70 0d       	add	r23, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    355c:	81 1d       	adc	r24, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    355e:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    3560:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    3562:	08 95       	ret

00003564 <__subsf3>:
__subsf3():
    3564:	50 58       	subi	r21, 0x80	; 128

00003566 <__addsf3>:
    3566:	bb 27       	eor	r27, r27
    3568:	aa 27       	eor	r26, r26
    356a:	0e 94 ca 1a 	call	0x3594	; 0x3594 <__addsf3x>
    356e:	0c 94 27 1a 	jmp	0x344e	; 0x344e <__fp_round>
__addsf3():
    3572:	0e 94 19 1a 	call	0x3432	; 0x3432 <__fp_pscA>
    3576:	38 f0       	brcs	.+14     	; 0x3586 <__addsf3+0x20>
    3578:	0e 94 20 1a 	call	0x3440	; 0x3440 <__fp_pscB>
    357c:	20 f0       	brcs	.+8      	; 0x3586 <__addsf3+0x20>
    357e:	39 f4       	brne	.+14     	; 0x358e <__addsf3+0x28>
    3580:	9f 3f       	cpi	r25, 0xFF	; 255
    3582:	19 f4       	brne	.+6      	; 0x358a <__addsf3+0x24>
    3584:	26 f4       	brtc	.+8      	; 0x358e <__addsf3+0x28>
    3586:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>
    358a:	0e f4       	brtc	.+2      	; 0x358e <__addsf3+0x28>
    358c:	e0 95       	com	r30
    358e:	e7 fb       	bst	r30, 7
    3590:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>

00003594 <__addsf3x>:
__addsf3x():
    3594:	e9 2f       	mov	r30, r25
    3596:	0e 94 38 1a 	call	0x3470	; 0x3470 <__fp_split3>
    359a:	58 f3       	brcs	.-42     	; 0x3572 <__addsf3+0xc>
    359c:	ba 17       	cp	r27, r26
    359e:	62 07       	cpc	r22, r18
    35a0:	73 07       	cpc	r23, r19
    35a2:	84 07       	cpc	r24, r20
    35a4:	95 07       	cpc	r25, r21
    35a6:	20 f0       	brcs	.+8      	; 0x35b0 <__addsf3x+0x1c>
    35a8:	79 f4       	brne	.+30     	; 0x35c8 <__addsf3x+0x34>
    35aa:	a6 f5       	brtc	.+104    	; 0x3614 <__addsf3x+0x80>
    35ac:	0c 94 5a 1a 	jmp	0x34b4	; 0x34b4 <__fp_zero>
    35b0:	0e f4       	brtc	.+2      	; 0x35b4 <__addsf3x+0x20>
    35b2:	e0 95       	com	r30
    35b4:	0b 2e       	mov	r0, r27
    35b6:	ba 2f       	mov	r27, r26
    35b8:	a0 2d       	mov	r26, r0
    35ba:	0b 01       	movw	r0, r22
    35bc:	b9 01       	movw	r22, r18
    35be:	90 01       	movw	r18, r0
    35c0:	0c 01       	movw	r0, r24
    35c2:	ca 01       	movw	r24, r20
    35c4:	a0 01       	movw	r20, r0
    35c6:	11 24       	eor	r1, r1
    35c8:	ff 27       	eor	r31, r31
    35ca:	59 1b       	sub	r21, r25
    35cc:	99 f0       	breq	.+38     	; 0x35f4 <__addsf3x+0x60>
    35ce:	59 3f       	cpi	r21, 0xF9	; 249
    35d0:	50 f4       	brcc	.+20     	; 0x35e6 <__addsf3x+0x52>
    35d2:	50 3e       	cpi	r21, 0xE0	; 224
    35d4:	68 f1       	brcs	.+90     	; 0x3630 <__addsf3x+0x9c>
    35d6:	1a 16       	cp	r1, r26
    35d8:	f0 40       	sbci	r31, 0x00	; 0
    35da:	a2 2f       	mov	r26, r18
    35dc:	23 2f       	mov	r18, r19
    35de:	34 2f       	mov	r19, r20
    35e0:	44 27       	eor	r20, r20
    35e2:	58 5f       	subi	r21, 0xF8	; 248
    35e4:	f3 cf       	rjmp	.-26     	; 0x35cc <__addsf3x+0x38>
    35e6:	46 95       	lsr	r20
    35e8:	37 95       	ror	r19
    35ea:	27 95       	ror	r18
    35ec:	a7 95       	ror	r26
    35ee:	f0 40       	sbci	r31, 0x00	; 0
    35f0:	53 95       	inc	r21
    35f2:	c9 f7       	brne	.-14     	; 0x35e6 <__addsf3x+0x52>
    35f4:	7e f4       	brtc	.+30     	; 0x3614 <__addsf3x+0x80>
    35f6:	1f 16       	cp	r1, r31
    35f8:	ba 0b       	sbc	r27, r26
    35fa:	62 0b       	sbc	r22, r18
    35fc:	73 0b       	sbc	r23, r19
    35fe:	84 0b       	sbc	r24, r20
    3600:	ba f0       	brmi	.+46     	; 0x3630 <__addsf3x+0x9c>
    3602:	91 50       	subi	r25, 0x01	; 1
    3604:	a1 f0       	breq	.+40     	; 0x362e <__addsf3x+0x9a>
    3606:	ff 0f       	add	r31, r31
    3608:	bb 1f       	adc	r27, r27
    360a:	66 1f       	adc	r22, r22
    360c:	77 1f       	adc	r23, r23
    360e:	88 1f       	adc	r24, r24
    3610:	c2 f7       	brpl	.-16     	; 0x3602 <__addsf3x+0x6e>
    3612:	0e c0       	rjmp	.+28     	; 0x3630 <__addsf3x+0x9c>
    3614:	ba 0f       	add	r27, r26
    3616:	62 1f       	adc	r22, r18
    3618:	73 1f       	adc	r23, r19
    361a:	84 1f       	adc	r24, r20
    361c:	48 f4       	brcc	.+18     	; 0x3630 <__addsf3x+0x9c>
    361e:	87 95       	ror	r24
    3620:	77 95       	ror	r23
    3622:	67 95       	ror	r22
    3624:	b7 95       	ror	r27
    3626:	f7 95       	ror	r31
    3628:	9e 3f       	cpi	r25, 0xFE	; 254
    362a:	08 f0       	brcs	.+2      	; 0x362e <__addsf3x+0x9a>
    362c:	b0 cf       	rjmp	.-160    	; 0x358e <__addsf3+0x28>
    362e:	93 95       	inc	r25
    3630:	88 0f       	add	r24, r24
    3632:	08 f0       	brcs	.+2      	; 0x3636 <__addsf3x+0xa2>
    3634:	99 27       	eor	r25, r25
    3636:	ee 0f       	add	r30, r30
    3638:	97 95       	ror	r25
    363a:	87 95       	ror	r24
    363c:	08 95       	ret

0000363e <__divsf3>:
    363e:	0e 94 33 1b 	call	0x3666	; 0x3666 <__divsf3x>
    3642:	0c 94 27 1a 	jmp	0x344e	; 0x344e <__fp_round>
    3646:	0e 94 20 1a 	call	0x3440	; 0x3440 <__fp_pscB>
    364a:	58 f0       	brcs	.+22     	; 0x3662 <__divsf3+0x24>
    364c:	0e 94 19 1a 	call	0x3432	; 0x3432 <__fp_pscA>
    3650:	40 f0       	brcs	.+16     	; 0x3662 <__divsf3+0x24>
    3652:	29 f4       	brne	.+10     	; 0x365e <__divsf3+0x20>
    3654:	5f 3f       	cpi	r21, 0xFF	; 255
    3656:	29 f0       	breq	.+10     	; 0x3662 <__divsf3+0x24>
    3658:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    365c:	51 11       	cpse	r21, r1
    365e:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>
__divsf3():
    3662:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>

00003666 <__divsf3x>:
__divsf3x():
    3666:	0e 94 38 1a 	call	0x3470	; 0x3470 <__fp_split3>
    366a:	68 f3       	brcs	.-38     	; 0x3646 <__divsf3+0x8>

0000366c <__divsf3_pse>:
    366c:	99 23       	and	r25, r25
    366e:	b1 f3       	breq	.-20     	; 0x365c <__divsf3+0x1e>
    3670:	55 23       	and	r21, r21
    3672:	91 f3       	breq	.-28     	; 0x3658 <__divsf3+0x1a>
    3674:	95 1b       	sub	r25, r21
    3676:	55 0b       	sbc	r21, r21
    3678:	bb 27       	eor	r27, r27
    367a:	aa 27       	eor	r26, r26
    367c:	62 17       	cp	r22, r18
    367e:	73 07       	cpc	r23, r19
    3680:	84 07       	cpc	r24, r20
    3682:	38 f0       	brcs	.+14     	; 0x3692 <__divsf3_pse+0x26>
    3684:	9f 5f       	subi	r25, 0xFF	; 255
    3686:	5f 4f       	sbci	r21, 0xFF	; 255
    3688:	22 0f       	add	r18, r18
    368a:	33 1f       	adc	r19, r19
    368c:	44 1f       	adc	r20, r20
    368e:	aa 1f       	adc	r26, r26
    3690:	a9 f3       	breq	.-22     	; 0x367c <__divsf3_pse+0x10>
    3692:	35 d0       	rcall	.+106    	; 0x36fe <__divsf3_pse+0x92>
    3694:	0e 2e       	mov	r0, r30
    3696:	3a f0       	brmi	.+14     	; 0x36a6 <__divsf3_pse+0x3a>
    3698:	e0 e8       	ldi	r30, 0x80	; 128
    369a:	32 d0       	rcall	.+100    	; 0x3700 <__divsf3_pse+0x94>
    369c:	91 50       	subi	r25, 0x01	; 1
    369e:	50 40       	sbci	r21, 0x00	; 0
    36a0:	e6 95       	lsr	r30
    36a2:	00 1c       	adc	r0, r0
    36a4:	ca f7       	brpl	.-14     	; 0x3698 <__divsf3_pse+0x2c>
    36a6:	2b d0       	rcall	.+86     	; 0x36fe <__divsf3_pse+0x92>
    36a8:	fe 2f       	mov	r31, r30
    36aa:	29 d0       	rcall	.+82     	; 0x36fe <__divsf3_pse+0x92>
    36ac:	66 0f       	add	r22, r22
    36ae:	77 1f       	adc	r23, r23
    36b0:	88 1f       	adc	r24, r24
    36b2:	bb 1f       	adc	r27, r27
    36b4:	26 17       	cp	r18, r22
    36b6:	37 07       	cpc	r19, r23
    36b8:	48 07       	cpc	r20, r24
    36ba:	ab 07       	cpc	r26, r27
    36bc:	b0 e8       	ldi	r27, 0x80	; 128
    36be:	09 f0       	breq	.+2      	; 0x36c2 <__divsf3_pse+0x56>
    36c0:	bb 0b       	sbc	r27, r27
    36c2:	80 2d       	mov	r24, r0
    36c4:	bf 01       	movw	r22, r30
    36c6:	ff 27       	eor	r31, r31
    36c8:	93 58       	subi	r25, 0x83	; 131
    36ca:	5f 4f       	sbci	r21, 0xFF	; 255
    36cc:	3a f0       	brmi	.+14     	; 0x36dc <__divsf3_pse+0x70>
    36ce:	9e 3f       	cpi	r25, 0xFE	; 254
    36d0:	51 05       	cpc	r21, r1
    36d2:	78 f0       	brcs	.+30     	; 0x36f2 <__divsf3_pse+0x86>
    36d4:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    36d8:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>
    36dc:	5f 3f       	cpi	r21, 0xFF	; 255
    36de:	e4 f3       	brlt	.-8      	; 0x36d8 <__divsf3_pse+0x6c>
    36e0:	98 3e       	cpi	r25, 0xE8	; 232
    36e2:	d4 f3       	brlt	.-12     	; 0x36d8 <__divsf3_pse+0x6c>
    36e4:	86 95       	lsr	r24
    36e6:	77 95       	ror	r23
    36e8:	67 95       	ror	r22
    36ea:	b7 95       	ror	r27
    36ec:	f7 95       	ror	r31
    36ee:	9f 5f       	subi	r25, 0xFF	; 255
    36f0:	c9 f7       	brne	.-14     	; 0x36e4 <__divsf3_pse+0x78>
    36f2:	88 0f       	add	r24, r24
    36f4:	91 1d       	adc	r25, r1
    36f6:	96 95       	lsr	r25
    36f8:	87 95       	ror	r24
    36fa:	97 f9       	bld	r25, 7
    36fc:	08 95       	ret
    36fe:	e1 e0       	ldi	r30, 0x01	; 1
    3700:	66 0f       	add	r22, r22
    3702:	77 1f       	adc	r23, r23
    3704:	88 1f       	adc	r24, r24
    3706:	bb 1f       	adc	r27, r27
    3708:	62 17       	cp	r22, r18
    370a:	73 07       	cpc	r23, r19
    370c:	84 07       	cpc	r24, r20
    370e:	ba 07       	cpc	r27, r26
    3710:	20 f0       	brcs	.+8      	; 0x371a <__divsf3_pse+0xae>
    3712:	62 1b       	sub	r22, r18
    3714:	73 0b       	sbc	r23, r19
    3716:	84 0b       	sbc	r24, r20
    3718:	ba 0b       	sbc	r27, r26
    371a:	ee 1f       	adc	r30, r30
    371c:	88 f7       	brcc	.-30     	; 0x3700 <__divsf3_pse+0x94>
    371e:	e0 95       	com	r30
    3720:	08 95       	ret

00003722 <__fixsfsi>:
    3722:	0e 94 98 1b 	call	0x3730	; 0x3730 <__fixunssfsi>
    3726:	68 94       	set
    3728:	b1 11       	cpse	r27, r1
    372a:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>
    372e:	08 95       	ret

00003730 <__fixunssfsi>:
    3730:	0e 94 40 1a 	call	0x3480	; 0x3480 <__fp_splitA>
    3734:	88 f0       	brcs	.+34     	; 0x3758 <__fixunssfsi+0x28>
    3736:	9f 57       	subi	r25, 0x7F	; 127
    3738:	98 f0       	brcs	.+38     	; 0x3760 <__fixunssfsi+0x30>
    373a:	b9 2f       	mov	r27, r25
    373c:	99 27       	eor	r25, r25
    373e:	b7 51       	subi	r27, 0x17	; 23
    3740:	b0 f0       	brcs	.+44     	; 0x376e <__fixunssfsi+0x3e>
__fixunssfsi():
    3742:	e1 f0       	breq	.+56     	; 0x377c <__fixunssfsi+0x4c>
    3744:	66 0f       	add	r22, r22
    3746:	77 1f       	adc	r23, r23
    3748:	88 1f       	adc	r24, r24
    374a:	99 1f       	adc	r25, r25
    374c:	1a f0       	brmi	.+6      	; 0x3754 <__fixunssfsi+0x24>
    374e:	ba 95       	dec	r27
    3750:	c9 f7       	brne	.-14     	; 0x3744 <__fixunssfsi+0x14>
    3752:	14 c0       	rjmp	.+40     	; 0x377c <__fixunssfsi+0x4c>
    3754:	b1 30       	cpi	r27, 0x01	; 1
    3756:	91 f0       	breq	.+36     	; 0x377c <__fixunssfsi+0x4c>
    3758:	0e 94 5a 1a 	call	0x34b4	; 0x34b4 <__fp_zero>
    375c:	b1 e0       	ldi	r27, 0x01	; 1
    375e:	08 95       	ret
    3760:	0c 94 5a 1a 	jmp	0x34b4	; 0x34b4 <__fp_zero>
    3764:	67 2f       	mov	r22, r23
    3766:	78 2f       	mov	r23, r24
    3768:	88 27       	eor	r24, r24
    376a:	b8 5f       	subi	r27, 0xF8	; 248
    376c:	39 f0       	breq	.+14     	; 0x377c <__fixunssfsi+0x4c>
    376e:	b9 3f       	cpi	r27, 0xF9	; 249
    3770:	cc f3       	brlt	.-14     	; 0x3764 <__fixunssfsi+0x34>
    3772:	86 95       	lsr	r24
    3774:	77 95       	ror	r23
    3776:	67 95       	ror	r22
    3778:	b3 95       	inc	r27
    377a:	d9 f7       	brne	.-10     	; 0x3772 <__fixunssfsi+0x42>
    377c:	3e f4       	brtc	.+14     	; 0x378c <__fixunssfsi+0x5c>
    377e:	90 95       	com	r25
    3780:	80 95       	com	r24
    3782:	70 95       	com	r23
    3784:	61 95       	neg	r22
    3786:	7f 4f       	sbci	r23, 0xFF	; 255
    3788:	8f 4f       	sbci	r24, 0xFF	; 255
    378a:	9f 4f       	sbci	r25, 0xFF	; 255
    378c:	08 95       	ret

0000378e <pow>:
pow():
    378e:	fa 01       	movw	r30, r20
    3790:	ee 0f       	add	r30, r30
    3792:	ff 1f       	adc	r31, r31
    3794:	30 96       	adiw	r30, 0x00	; 0
    3796:	21 05       	cpc	r18, r1
    3798:	31 05       	cpc	r19, r1
    379a:	a1 f1       	breq	.+104    	; 0x3804 <pow+0x76>
    379c:	61 15       	cp	r22, r1
    379e:	71 05       	cpc	r23, r1
    37a0:	61 f4       	brne	.+24     	; 0x37ba <pow+0x2c>
    37a2:	80 38       	cpi	r24, 0x80	; 128
    37a4:	bf e3       	ldi	r27, 0x3F	; 63
    37a6:	9b 07       	cpc	r25, r27
    37a8:	49 f1       	breq	.+82     	; 0x37fc <pow+0x6e>
    37aa:	68 94       	set
    37ac:	90 38       	cpi	r25, 0x80	; 128
    37ae:	81 05       	cpc	r24, r1
    37b0:	61 f0       	breq	.+24     	; 0x37ca <pow+0x3c>
    37b2:	80 38       	cpi	r24, 0x80	; 128
    37b4:	bf ef       	ldi	r27, 0xFF	; 255
    37b6:	9b 07       	cpc	r25, r27
    37b8:	41 f0       	breq	.+16     	; 0x37ca <pow+0x3c>
    37ba:	99 23       	and	r25, r25
    37bc:	4a f5       	brpl	.+82     	; 0x3810 <pow+0x82>
    37be:	ff 3f       	cpi	r31, 0xFF	; 255
    37c0:	e1 05       	cpc	r30, r1
    37c2:	31 05       	cpc	r19, r1
    37c4:	21 05       	cpc	r18, r1
    37c6:	19 f1       	breq	.+70     	; 0x380e <pow+0x80>
    37c8:	e8 94       	clt
    37ca:	08 94       	sec
    37cc:	e7 95       	ror	r30
    37ce:	d9 01       	movw	r26, r18
    37d0:	aa 23       	and	r26, r26
    37d2:	29 f4       	brne	.+10     	; 0x37de <pow+0x50>
    37d4:	ab 2f       	mov	r26, r27
    37d6:	be 2f       	mov	r27, r30
    37d8:	f8 5f       	subi	r31, 0xF8	; 248
    37da:	d0 f3       	brcs	.-12     	; 0x37d0 <pow+0x42>
    37dc:	10 c0       	rjmp	.+32     	; 0x37fe <pow+0x70>
    37de:	ff 5f       	subi	r31, 0xFF	; 255
    37e0:	70 f4       	brcc	.+28     	; 0x37fe <pow+0x70>
    37e2:	a6 95       	lsr	r26
    37e4:	e0 f7       	brcc	.-8      	; 0x37de <pow+0x50>
    37e6:	f7 39       	cpi	r31, 0x97	; 151
    37e8:	50 f0       	brcs	.+20     	; 0x37fe <pow+0x70>
    37ea:	19 f0       	breq	.+6      	; 0x37f2 <pow+0x64>
    37ec:	ff 3a       	cpi	r31, 0xAF	; 175
    37ee:	38 f4       	brcc	.+14     	; 0x37fe <pow+0x70>
    37f0:	9f 77       	andi	r25, 0x7F	; 127
    37f2:	9f 93       	push	r25
    37f4:	0d d0       	rcall	.+26     	; 0x3810 <pow+0x82>
    37f6:	0f 90       	pop	r0
    37f8:	07 fc       	sbrc	r0, 7
    37fa:	90 58       	subi	r25, 0x80	; 128
    37fc:	08 95       	ret
    37fe:	46 f0       	brts	.+16     	; 0x3810 <pow+0x82>
    3800:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>
    3804:	60 e0       	ldi	r22, 0x00	; 0
    3806:	70 e0       	ldi	r23, 0x00	; 0
    3808:	80 e8       	ldi	r24, 0x80	; 128
    380a:	9f e3       	ldi	r25, 0x3F	; 63
    380c:	08 95       	ret
    380e:	4f e7       	ldi	r20, 0x7F	; 127
    3810:	9f 77       	andi	r25, 0x7F	; 127
    3812:	5f 93       	push	r21
    3814:	4f 93       	push	r20
    3816:	3f 93       	push	r19
    3818:	2f 93       	push	r18
    381a:	0e 94 c2 1c 	call	0x3984	; 0x3984 <log>
    381e:	2f 91       	pop	r18
    3820:	3f 91       	pop	r19
    3822:	4f 91       	pop	r20
    3824:	5f 91       	pop	r21
    3826:	0e 94 a3 19 	call	0x3346	; 0x3346 <__mulsf3>
    382a:	0c 94 1f 1c 	jmp	0x383e	; 0x383e <exp>
    382e:	29 f4       	brne	.+10     	; 0x383a <pow+0xac>
    3830:	16 f0       	brts	.+4      	; 0x3836 <pow+0xa8>
    3832:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    3836:	0c 94 5a 1a 	jmp	0x34b4	; 0x34b4 <__fp_zero>
    383a:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>

0000383e <exp>:
exp():
    383e:	0e 94 40 1a 	call	0x3480	; 0x3480 <__fp_splitA>
    3842:	a8 f3       	brcs	.-22     	; 0x382e <pow+0xa0>
    3844:	96 38       	cpi	r25, 0x86	; 134
    3846:	a0 f7       	brcc	.-24     	; 0x3830 <pow+0xa2>
    3848:	07 f8       	bld	r0, 7
    384a:	0f 92       	push	r0
    384c:	e8 94       	clt
    384e:	2b e3       	ldi	r18, 0x3B	; 59
    3850:	3a ea       	ldi	r19, 0xAA	; 170
    3852:	48 eb       	ldi	r20, 0xB8	; 184
    3854:	5f e7       	ldi	r21, 0x7F	; 127
    3856:	0e 94 b9 19 	call	0x3372	; 0x3372 <__mulsf3_pse>
    385a:	0f 92       	push	r0
    385c:	0f 92       	push	r0
    385e:	0f 92       	push	r0
    3860:	4d b7       	in	r20, 0x3d	; 61
    3862:	5e b7       	in	r21, 0x3e	; 62
    3864:	0f 92       	push	r0
    3866:	0e 94 0a 1d 	call	0x3a14	; 0x3a14 <modf>
    386a:	e8 e6       	ldi	r30, 0x68	; 104
    386c:	f0 e0       	ldi	r31, 0x00	; 0
    386e:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__fp_powser>
    3872:	4f 91       	pop	r20
    3874:	5f 91       	pop	r21
    3876:	ef 91       	pop	r30
    3878:	ff 91       	pop	r31
    387a:	e5 95       	asr	r30
    387c:	ee 1f       	adc	r30, r30
    387e:	ff 1f       	adc	r31, r31
    3880:	49 f0       	breq	.+18     	; 0x3894 <exp+0x56>
    3882:	fe 57       	subi	r31, 0x7E	; 126
    3884:	e0 68       	ori	r30, 0x80	; 128
    3886:	44 27       	eor	r20, r20
    3888:	ee 0f       	add	r30, r30
    388a:	44 1f       	adc	r20, r20
    388c:	fa 95       	dec	r31
    388e:	e1 f7       	brne	.-8      	; 0x3888 <exp+0x4a>
    3890:	41 95       	neg	r20
    3892:	55 0b       	sbc	r21, r21
    3894:	0e 94 84 1c 	call	0x3908	; 0x3908 <ldexp>
    3898:	0f 90       	pop	r0
    389a:	07 fe       	sbrs	r0, 7
    389c:	0c 94 78 1c 	jmp	0x38f0	; 0x38f0 <inverse>
    38a0:	08 95       	ret

000038a2 <__fp_powser>:
    38a2:	df 93       	push	r29
    38a4:	cf 93       	push	r28
    38a6:	1f 93       	push	r17
    38a8:	0f 93       	push	r16
    38aa:	ff 92       	push	r15
    38ac:	ef 92       	push	r14
    38ae:	df 92       	push	r13
    38b0:	7b 01       	movw	r14, r22
__fp_powser():
    38b2:	8c 01       	movw	r16, r24
    38b4:	68 94       	set
    38b6:	06 c0       	rjmp	.+12     	; 0x38c4 <__fp_powser+0x22>
    38b8:	da 2e       	mov	r13, r26
    38ba:	ef 01       	movw	r28, r30
    38bc:	0e 94 b6 19 	call	0x336c	; 0x336c <__mulsf3x>
    38c0:	fe 01       	movw	r30, r28
    38c2:	e8 94       	clt
    38c4:	a5 91       	lpm	r26, Z+
    38c6:	25 91       	lpm	r18, Z+
    38c8:	35 91       	lpm	r19, Z+
    38ca:	45 91       	lpm	r20, Z+
    38cc:	55 91       	lpm	r21, Z+
    38ce:	a6 f3       	brts	.-24     	; 0x38b8 <__fp_powser+0x16>
    38d0:	ef 01       	movw	r28, r30
    38d2:	0e 94 ca 1a 	call	0x3594	; 0x3594 <__addsf3x>
    38d6:	fe 01       	movw	r30, r28
    38d8:	97 01       	movw	r18, r14
    38da:	a8 01       	movw	r20, r16
    38dc:	da 94       	dec	r13
    38de:	69 f7       	brne	.-38     	; 0x38ba <__fp_powser+0x18>
    38e0:	df 90       	pop	r13
    38e2:	ef 90       	pop	r14
    38e4:	ff 90       	pop	r15
    38e6:	0f 91       	pop	r16
    38e8:	1f 91       	pop	r17
    38ea:	cf 91       	pop	r28
    38ec:	df 91       	pop	r29
    38ee:	08 95       	ret

000038f0 <inverse>:
inverse():
    38f0:	9b 01       	movw	r18, r22
    38f2:	ac 01       	movw	r20, r24
    38f4:	60 e0       	ldi	r22, 0x00	; 0
    38f6:	70 e0       	ldi	r23, 0x00	; 0
    38f8:	80 e8       	ldi	r24, 0x80	; 128
    38fa:	9f e3       	ldi	r25, 0x3F	; 63
    38fc:	0c 94 1f 1b 	jmp	0x363e	; 0x363e <__divsf3>
    3900:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>
    3904:	0c 94 3e 1d 	jmp	0x3a7c	; 0x3a7c <__fp_mpack>

00003908 <ldexp>:
ldexp():
    3908:	0e 94 40 1a 	call	0x3480	; 0x3480 <__fp_splitA>
    390c:	d8 f3       	brcs	.-10     	; 0x3904 <inverse+0x14>
    390e:	99 23       	and	r25, r25
    3910:	c9 f3       	breq	.-14     	; 0x3904 <inverse+0x14>
    3912:	94 0f       	add	r25, r20
    3914:	51 1d       	adc	r21, r1
    3916:	a3 f3       	brvs	.-24     	; 0x3900 <inverse+0x10>
    3918:	91 50       	subi	r25, 0x01	; 1
    391a:	50 40       	sbci	r21, 0x00	; 0
    391c:	94 f0       	brlt	.+36     	; 0x3942 <ldexp+0x3a>
    391e:	59 f0       	breq	.+22     	; 0x3936 <ldexp+0x2e>
    3920:	88 23       	and	r24, r24
    3922:	32 f0       	brmi	.+12     	; 0x3930 <ldexp+0x28>
    3924:	66 0f       	add	r22, r22
    3926:	77 1f       	adc	r23, r23
    3928:	88 1f       	adc	r24, r24
    392a:	91 50       	subi	r25, 0x01	; 1
    392c:	50 40       	sbci	r21, 0x00	; 0
    392e:	c1 f7       	brne	.-16     	; 0x3920 <ldexp+0x18>
    3930:	9e 3f       	cpi	r25, 0xFE	; 254
    3932:	51 05       	cpc	r21, r1
    3934:	2c f7       	brge	.-54     	; 0x3900 <inverse+0x10>
    3936:	88 0f       	add	r24, r24
    3938:	91 1d       	adc	r25, r1
    393a:	96 95       	lsr	r25
    393c:	87 95       	ror	r24
    393e:	97 f9       	bld	r25, 7
    3940:	08 95       	ret
    3942:	5f 3f       	cpi	r21, 0xFF	; 255
    3944:	ac f0       	brlt	.+42     	; 0x3970 <ldexp+0x68>
    3946:	98 3e       	cpi	r25, 0xE8	; 232
    3948:	9c f0       	brlt	.+38     	; 0x3970 <ldexp+0x68>
    394a:	bb 27       	eor	r27, r27
    394c:	86 95       	lsr	r24
    394e:	77 95       	ror	r23
    3950:	67 95       	ror	r22
    3952:	b7 95       	ror	r27
    3954:	08 f4       	brcc	.+2      	; 0x3958 <ldexp+0x50>
    3956:	b1 60       	ori	r27, 0x01	; 1
    3958:	93 95       	inc	r25
    395a:	c1 f7       	brne	.-16     	; 0x394c <ldexp+0x44>
    395c:	bb 0f       	add	r27, r27
    395e:	58 f7       	brcc	.-42     	; 0x3936 <ldexp+0x2e>
    3960:	11 f4       	brne	.+4      	; 0x3966 <ldexp+0x5e>
    3962:	60 ff       	sbrs	r22, 0
    3964:	e8 cf       	rjmp	.-48     	; 0x3936 <ldexp+0x2e>
    3966:	6f 5f       	subi	r22, 0xFF	; 255
    3968:	7f 4f       	sbci	r23, 0xFF	; 255
    396a:	8f 4f       	sbci	r24, 0xFF	; 255
    396c:	9f 4f       	sbci	r25, 0xFF	; 255
    396e:	e3 cf       	rjmp	.-58     	; 0x3936 <ldexp+0x2e>
    3970:	0c 94 5b 1a 	jmp	0x34b6	; 0x34b6 <__fp_szero>
    3974:	16 f0       	brts	.+4      	; 0x397a <ldexp+0x72>
    3976:	0c 94 3e 1d 	jmp	0x3a7c	; 0x3a7c <__fp_mpack>
    397a:	0c 94 16 1a 	jmp	0x342c	; 0x342c <__fp_nan>
    397e:	68 94       	set
    3980:	0c 94 10 1a 	jmp	0x3420	; 0x3420 <__fp_inf>

00003984 <log>:
log():
    3984:	0e 94 40 1a 	call	0x3480	; 0x3480 <__fp_splitA>
    3988:	a8 f3       	brcs	.-22     	; 0x3974 <ldexp+0x6c>
    398a:	99 23       	and	r25, r25
    398c:	c1 f3       	breq	.-16     	; 0x397e <ldexp+0x76>
    398e:	ae f3       	brts	.-22     	; 0x397a <ldexp+0x72>
    3990:	df 93       	push	r29
    3992:	cf 93       	push	r28
    3994:	1f 93       	push	r17
    3996:	0f 93       	push	r16
    3998:	ff 92       	push	r15
    399a:	c9 2f       	mov	r28, r25
    399c:	dd 27       	eor	r29, r29
    399e:	88 23       	and	r24, r24
    39a0:	2a f0       	brmi	.+10     	; 0x39ac <log+0x28>
    39a2:	21 97       	sbiw	r28, 0x01	; 1
    39a4:	66 0f       	add	r22, r22
    39a6:	77 1f       	adc	r23, r23
    39a8:	88 1f       	adc	r24, r24
    39aa:	da f7       	brpl	.-10     	; 0x39a2 <log+0x1e>
    39ac:	20 e0       	ldi	r18, 0x00	; 0
    39ae:	30 e0       	ldi	r19, 0x00	; 0
    39b0:	40 e8       	ldi	r20, 0x80	; 128
    39b2:	5f eb       	ldi	r21, 0xBF	; 191
    39b4:	9f e3       	ldi	r25, 0x3F	; 63
    39b6:	88 39       	cpi	r24, 0x98	; 152
    39b8:	20 f0       	brcs	.+8      	; 0x39c2 <log+0x3e>
    39ba:	80 3e       	cpi	r24, 0xE0	; 224
    39bc:	38 f0       	brcs	.+14     	; 0x39cc <log+0x48>
    39be:	21 96       	adiw	r28, 0x01	; 1
    39c0:	8f 77       	andi	r24, 0x7F	; 127
    39c2:	0e 94 b3 1a 	call	0x3566	; 0x3566 <__addsf3>
    39c6:	e0 e9       	ldi	r30, 0x90	; 144
    39c8:	f0 e0       	ldi	r31, 0x00	; 0
    39ca:	04 c0       	rjmp	.+8      	; 0x39d4 <log+0x50>
    39cc:	0e 94 b3 1a 	call	0x3566	; 0x3566 <__addsf3>
    39d0:	ed eb       	ldi	r30, 0xBD	; 189
    39d2:	f0 e0       	ldi	r31, 0x00	; 0
    39d4:	0e 94 51 1c 	call	0x38a2	; 0x38a2 <__fp_powser>
    39d8:	8b 01       	movw	r16, r22
    39da:	be 01       	movw	r22, r28
    39dc:	ec 01       	movw	r28, r24
    39de:	fb 2e       	mov	r15, r27
    39e0:	6f 57       	subi	r22, 0x7F	; 127
    39e2:	71 09       	sbc	r23, r1
    39e4:	75 95       	asr	r23
    39e6:	77 1f       	adc	r23, r23
    39e8:	88 0b       	sbc	r24, r24
    39ea:	99 0b       	sbc	r25, r25
    39ec:	0e 94 68 19 	call	0x32d0	; 0x32d0 <__floatsisf>
    39f0:	28 e1       	ldi	r18, 0x18	; 24
    39f2:	32 e7       	ldi	r19, 0x72	; 114
    39f4:	41 e3       	ldi	r20, 0x31	; 49
    39f6:	5f e3       	ldi	r21, 0x3F	; 63
    39f8:	0e 94 b6 19 	call	0x336c	; 0x336c <__mulsf3x>
    39fc:	af 2d       	mov	r26, r15
    39fe:	98 01       	movw	r18, r16
    3a00:	ae 01       	movw	r20, r28
    3a02:	ff 90       	pop	r15
    3a04:	0f 91       	pop	r16
    3a06:	1f 91       	pop	r17
    3a08:	cf 91       	pop	r28
    3a0a:	df 91       	pop	r29
    3a0c:	0e 94 ca 1a 	call	0x3594	; 0x3594 <__addsf3x>
    3a10:	0c 94 27 1a 	jmp	0x344e	; 0x344e <__fp_round>

00003a14 <modf>:
    3a14:	fa 01       	movw	r30, r20
    3a16:	dc 01       	movw	r26, r24
    3a18:	aa 0f       	add	r26, r26
    3a1a:	bb 1f       	adc	r27, r27
    3a1c:	9b 01       	movw	r18, r22
    3a1e:	ac 01       	movw	r20, r24
    3a20:	bf 57       	subi	r27, 0x7F	; 127
    3a22:	28 f4       	brcc	.+10     	; 0x3a2e <modf+0x1a>
modf():
    3a24:	22 27       	eor	r18, r18
    3a26:	33 27       	eor	r19, r19
    3a28:	44 27       	eor	r20, r20
    3a2a:	50 78       	andi	r21, 0x80	; 128
    3a2c:	20 c0       	rjmp	.+64     	; 0x3a6e <modf+0x5a>
    3a2e:	b7 51       	subi	r27, 0x17	; 23
    3a30:	90 f4       	brcc	.+36     	; 0x3a56 <modf+0x42>
    3a32:	ab 2f       	mov	r26, r27
    3a34:	00 24       	eor	r0, r0
    3a36:	46 95       	lsr	r20
    3a38:	37 95       	ror	r19
    3a3a:	27 95       	ror	r18
    3a3c:	01 1c       	adc	r0, r1
    3a3e:	a3 95       	inc	r26
    3a40:	d2 f3       	brmi	.-12     	; 0x3a36 <modf+0x22>
    3a42:	00 20       	and	r0, r0
    3a44:	71 f0       	breq	.+28     	; 0x3a62 <modf+0x4e>
    3a46:	22 0f       	add	r18, r18
    3a48:	33 1f       	adc	r19, r19
    3a4a:	44 1f       	adc	r20, r20
    3a4c:	b3 95       	inc	r27
    3a4e:	da f3       	brmi	.-10     	; 0x3a46 <modf+0x32>
    3a50:	0e d0       	rcall	.+28     	; 0x3a6e <modf+0x5a>
    3a52:	0c 94 b2 1a 	jmp	0x3564	; 0x3564 <__subsf3>
    3a56:	61 30       	cpi	r22, 0x01	; 1
    3a58:	71 05       	cpc	r23, r1
    3a5a:	a0 e8       	ldi	r26, 0x80	; 128
    3a5c:	8a 07       	cpc	r24, r26
    3a5e:	b9 46       	sbci	r27, 0x69	; 105
    3a60:	30 f4       	brcc	.+12     	; 0x3a6e <modf+0x5a>
    3a62:	9b 01       	movw	r18, r22
    3a64:	ac 01       	movw	r20, r24
    3a66:	66 27       	eor	r22, r22
    3a68:	77 27       	eor	r23, r23
    3a6a:	88 27       	eor	r24, r24
    3a6c:	90 78       	andi	r25, 0x80	; 128
    3a6e:	30 96       	adiw	r30, 0x00	; 0
    3a70:	21 f0       	breq	.+8      	; 0x3a7a <modf+0x66>
    3a72:	20 83       	st	Z, r18
    3a74:	31 83       	std	Z+1, r19	; 0x01
    3a76:	42 83       	std	Z+2, r20	; 0x02
    3a78:	53 83       	std	Z+3, r21	; 0x03
    3a7a:	08 95       	ret

00003a7c <__fp_mpack>:
__fp_mpack():
    3a7c:	9f 3f       	cpi	r25, 0xFF	; 255
    3a7e:	31 f0       	breq	.+12     	; 0x3a8c <__fp_mpack_finite+0xc>

00003a80 <__fp_mpack_finite>:
    3a80:	91 50       	subi	r25, 0x01	; 1
    3a82:	20 f4       	brcc	.+8      	; 0x3a8c <__fp_mpack_finite+0xc>
    3a84:	87 95       	ror	r24
    3a86:	77 95       	ror	r23
    3a88:	67 95       	ror	r22
    3a8a:	b7 95       	ror	r27
    3a8c:	88 0f       	add	r24, r24
    3a8e:	91 1d       	adc	r25, r1
    3a90:	96 95       	lsr	r25
    3a92:	87 95       	ror	r24
    3a94:	97 f9       	bld	r25, 7
    3a96:	08 95       	ret

00003a98 <__mulsi3>:
__mulsi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    3a98:	db 01       	movw	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    3a9a:	8f 93       	push	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    3a9c:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    3a9e:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    3aa2:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    3aa4:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    3aa6:	a2 9f       	mul	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    3aa8:	80 0d       	add	r24, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    3aaa:	91 1d       	adc	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    3aac:	a3 9f       	mul	r26, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    3aae:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    3ab0:	b2 9f       	mul	r27, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    3ab2:	90 0d       	add	r25, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    3ab4:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    3ab6:	08 95       	ret

00003ab8 <__udivmodqi4>:
__udivmodqi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    3ab8:	99 1b       	sub	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    3aba:	79 e0       	ldi	r23, 0x09	; 9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    3abc:	04 c0       	rjmp	.+8      	; 0x3ac6 <__udivmodqi4_ep>

00003abe <__udivmodqi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    3abe:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    3ac0:	96 17       	cp	r25, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    3ac2:	08 f0       	brcs	.+2      	; 0x3ac6 <__udivmodqi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    3ac4:	96 1b       	sub	r25, r22

00003ac6 <__udivmodqi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    3ac6:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    3ac8:	7a 95       	dec	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    3aca:	c9 f7       	brne	.-14     	; 0x3abe <__udivmodqi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    3acc:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    3ace:	08 95       	ret

00003ad0 <__udivmodhi4>:
__udivmodhi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    3ad0:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    3ad2:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    3ad4:	51 e1       	ldi	r21, 0x11	; 17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    3ad6:	07 c0       	rjmp	.+14     	; 0x3ae6 <__udivmodhi4_ep>

00003ad8 <__udivmodhi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    3ad8:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    3ada:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    3adc:	a6 17       	cp	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    3ade:	b7 07       	cpc	r27, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    3ae0:	10 f0       	brcs	.+4      	; 0x3ae6 <__udivmodhi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    3ae2:	a6 1b       	sub	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    3ae4:	b7 0b       	sbc	r27, r23

00003ae6 <__udivmodhi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    3ae6:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    3ae8:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    3aea:	5a 95       	dec	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    3aec:	a9 f7       	brne	.-22     	; 0x3ad8 <__udivmodhi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    3aee:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    3af0:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    3af2:	bc 01       	movw	r22, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    3af4:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    3af6:	08 95       	ret

00003af8 <__udivmodsi4>:
__udivmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    3af8:	a1 e2       	ldi	r26, 0x21	; 33
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    3afa:	1a 2e       	mov	r1, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    3afc:	aa 1b       	sub	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    3afe:	bb 1b       	sub	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    3b00:	fd 01       	movw	r30, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    3b02:	0d c0       	rjmp	.+26     	; 0x3b1e <__udivmodsi4_ep>

00003b04 <__udivmodsi4_loop>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    3b04:	aa 1f       	adc	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    3b06:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    3b08:	ee 1f       	adc	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    3b0a:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    3b0c:	a2 17       	cp	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    3b0e:	b3 07       	cpc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    3b10:	e4 07       	cpc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    3b12:	f5 07       	cpc	r31, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    3b14:	20 f0       	brcs	.+8      	; 0x3b1e <__udivmodsi4_ep>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    3b16:	a2 1b       	sub	r26, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    3b18:	b3 0b       	sbc	r27, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    3b1a:	e4 0b       	sbc	r30, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    3b1c:	f5 0b       	sbc	r31, r21

00003b1e <__udivmodsi4_ep>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    3b1e:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    3b20:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    3b22:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    3b24:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    3b26:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    3b28:	69 f7       	brne	.-38     	; 0x3b04 <__udivmodsi4_loop>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    3b2a:	60 95       	com	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    3b2c:	70 95       	com	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    3b2e:	80 95       	com	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    3b30:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    3b32:	9b 01       	movw	r18, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    3b34:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    3b36:	bd 01       	movw	r22, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    3b38:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    3b3a:	08 95       	ret

00003b3c <__divmodsi4>:
__divmodsi4():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    3b3c:	05 2e       	mov	r0, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    3b3e:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    3b40:	1e f4       	brtc	.+6      	; 0x3b48 <__divmodsi4+0xc>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    3b42:	00 94       	com	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    3b44:	0e 94 b5 1d 	call	0x3b6a	; 0x3b6a <__negsi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    3b48:	57 fd       	sbrc	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1693
    3b4a:	07 d0       	rcall	.+14     	; 0x3b5a <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    3b4c:	0e 94 7c 1d 	call	0x3af8	; 0x3af8 <__udivmodsi4>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    3b50:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1696
    3b52:	03 d0       	rcall	.+6      	; 0x3b5a <__divmodsi4_neg2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    3b54:	4e f4       	brtc	.+18     	; 0x3b68 <__divmodsi4_exit>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    3b56:	0c 94 b5 1d 	jmp	0x3b6a	; 0x3b6a <__negsi2>

00003b5a <__divmodsi4_neg2>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    3b5a:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    3b5c:	40 95       	com	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    3b5e:	30 95       	com	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    3b60:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    3b62:	3f 4f       	sbci	r19, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    3b64:	4f 4f       	sbci	r20, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    3b66:	5f 4f       	sbci	r21, 0xFF	; 255

00003b68 <__divmodsi4_exit>:
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    3b68:	08 95       	ret

00003b6a <__negsi2>:
__negsi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    3b6a:	90 95       	com	r25
    3b6c:	80 95       	com	r24
    3b6e:	70 95       	com	r23
    3b70:	61 95       	neg	r22
    3b72:	7f 4f       	sbci	r23, 0xFF	; 255
    3b74:	8f 4f       	sbci	r24, 0xFF	; 255
    3b76:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    3b78:	08 95       	ret

00003b7a <__mulshisi3>:
__mulshisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    3b7a:	b7 ff       	sbrs	r27, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    3b7c:	0c 94 61 1a 	jmp	0x34c2	; 0x34c2 <__muluhisi3>

00003b80 <__mulohisi3>:
__mulohisi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    3b80:	0e 94 61 1a 	call	0x34c2	; 0x34c2 <__muluhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    3b84:	82 1b       	sub	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    3b86:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    3b88:	08 95       	ret

00003b8a <__muldi3>:
__muldi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:894
    3b8a:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:895
    3b8c:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:896
    3b8e:	1f 93       	push	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:897
    3b90:	0f 93       	push	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:902
    3b92:	9a 9d       	mul	r25, r10
    3b94:	f0 2d       	mov	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:903
    3b96:	21 9f       	mul	r18, r17
    3b98:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:904
    3b9a:	8b 9d       	mul	r24, r11
    3b9c:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:905
    3b9e:	8a 9d       	mul	r24, r10
    3ba0:	e0 2d       	mov	r30, r0
    3ba2:	f1 0d       	add	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:906
    3ba4:	03 9f       	mul	r16, r19
    3ba6:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:907
    3ba8:	02 9f       	mul	r16, r18
    3baa:	e0 0d       	add	r30, r0
    3bac:	f1 1d       	adc	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:910
    3bae:	4e 9d       	mul	r20, r14
    3bb0:	e0 0d       	add	r30, r0
    3bb2:	f1 1d       	adc	r31, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:911
    3bb4:	5e 9d       	mul	r21, r14
    3bb6:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:912
    3bb8:	4f 9d       	mul	r20, r15
    3bba:	f0 0d       	add	r31, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:914
    3bbc:	7f 93       	push	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:915
    3bbe:	6f 93       	push	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:916
    3bc0:	bf 92       	push	r11
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:917
    3bc2:	af 92       	push	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:918
    3bc4:	5f 93       	push	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:919
    3bc6:	4f 93       	push	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:922
    3bc8:	d5 01       	movw	r26, r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:923
    3bca:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:924
    3bce:	8b 01       	movw	r16, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:925
    3bd0:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:928
    3bd2:	d7 01       	movw	r26, r14
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:929
    3bd4:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
    3bd8:	eb 01       	movw	r28, r22
    3bda:	e8 0f       	add	r30, r24
    3bdc:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:931
    3bde:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:933
    3be0:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:935
    3be4:	2f 91       	pop	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:936
    3be6:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:938
    3be8:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:939
    3bea:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
    3bee:	c6 0f       	add	r28, r22
    3bf0:	d7 1f       	adc	r29, r23
    3bf2:	e8 1f       	adc	r30, r24
    3bf4:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:941
    3bf6:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:942
    3bf8:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:944
    3bfa:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:946
    3bfe:	2f 91       	pop	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:947
    3c00:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:949
    3c02:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
    3c06:	c6 0f       	add	r28, r22
    3c08:	d7 1f       	adc	r29, r23
    3c0a:	e8 1f       	adc	r30, r24
    3c0c:	f9 1f       	adc	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:952
    3c0e:	d6 01       	movw	r26, r12
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:953
    3c10:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
    3c14:	e6 0f       	add	r30, r22
    3c16:	f7 1f       	adc	r31, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:956
    3c18:	98 01       	movw	r18, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:958
    3c1a:	be 01       	movw	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:959
    3c1c:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:961
    3c1e:	0f 91       	pop	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:962
    3c20:	1f 91       	pop	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:963
    3c22:	cf 91       	pop	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:964
    3c24:	df 91       	pop	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:965
    3c26:	08 95       	ret

00003c28 <__muldi3_6>:
__muldi3_6():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:973
    3c28:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:974
    3c2c:	46 0f       	add	r20, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:975
    3c2e:	57 1f       	adc	r21, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:976
    3c30:	c8 1f       	adc	r28, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:977
    3c32:	d9 1f       	adc	r29, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:978
    3c34:	08 f4       	brcc	.+2      	; 0x3c38 <__muldi3_6+0x10>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:979
    3c36:	31 96       	adiw	r30, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:980
    3c38:	08 95       	ret

00003c3a <__mulsidi3>:
__mulsidi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1194
    3c3a:	97 fb       	bst	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1195
    3c3c:	57 ff       	sbrs	r21, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1196
    3c3e:	0c 94 2d 1e 	jmp	0x3c5a	; 0x3c5a <__umulsidi3_helper>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1199
    3c42:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1200
    3c44:	8f 93       	push	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1201
    3c46:	0e 94 2d 1e 	call	0x3c5a	; 0x3c5a <__umulsidi3_helper>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1203
    3c4a:	6e 1b       	sub	r22, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1204
    3c4c:	7f 0b       	sbc	r23, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1205
    3c4e:	af 91       	pop	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1206
    3c50:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1207
    3c52:	8a 0b       	sbc	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1208
    3c54:	9b 0b       	sbc	r25, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1209
    3c56:	08 95       	ret

00003c58 <__umulsidi3>:
__umulsidi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1130
    3c58:	e8 94       	clt

00003c5a <__umulsidi3_helper>:
__umulsidi3_helper():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1135
    3c5a:	df 93       	push	r29
    3c5c:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1136
    3c5e:	fc 01       	movw	r30, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1139
    3c60:	db 01       	movw	r26, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1140
    3c62:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1141
    3c66:	7f 93       	push	r23
    3c68:	6f 93       	push	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1142
    3c6a:	e9 01       	movw	r28, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1143
    3c6c:	9a 01       	movw	r18, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1144
    3c6e:	ac 01       	movw	r20, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1145
    3c70:	bf 93       	push	r27
    3c72:	af 93       	push	r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1146
    3c74:	3f 93       	push	r19
    3c76:	2f 93       	push	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1151
    3c78:	df 01       	movw	r26, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1152
    3c7a:	0e 94 a3 1a 	call	0x3546	; 0x3546 <__umulhisi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1154
    3c7e:	26 f4       	brtc	.+8      	; 0x3c88 <__umulsidi3_helper+0x2e>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1156
    3c80:	6c 1b       	sub	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1157
    3c82:	7d 0b       	sbc	r23, r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1158
    3c84:	82 0b       	sbc	r24, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1159
    3c86:	93 0b       	sbc	r25, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1160
    3c88:	9e 01       	movw	r18, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1161
    3c8a:	eb 01       	movw	r28, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1162
    3c8c:	fc 01       	movw	r30, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1168
    3c8e:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1170
    3c92:	af 91       	pop	r26
    3c94:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1171
    3c96:	2f 91       	pop	r18
    3c98:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1172
    3c9a:	0e 94 14 1e 	call	0x3c28	; 0x3c28 <__muldi3_6>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1175
    3c9e:	be 01       	movw	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1176
    3ca0:	cf 01       	movw	r24, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1177
    3ca2:	f9 01       	movw	r30, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1178
    3ca4:	2f 91       	pop	r18
    3ca6:	3f 91       	pop	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1181
    3ca8:	cf 91       	pop	r28
    3caa:	df 91       	pop	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1182
    3cac:	08 95       	ret

00003cae <__moddi3>:
__moddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1964
    3cae:	68 94       	set
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1965
    3cb0:	01 c0       	rjmp	.+2      	; 0x3cb4 <__divdi3_moddi3>

00003cb2 <__divdi3>:
__divdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1972
    3cb2:	e8 94       	clt

00003cb4 <__divdi3_moddi3>:
__divdi3_moddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1977
    3cb4:	f9 2f       	mov	r31, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1978
    3cb6:	f1 2b       	or	r31, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1979
    3cb8:	12 f0       	brmi	.+4      	; 0x3cbe <__divdi3_moddi3+0xa>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1981
    3cba:	0c 94 8b 1e 	jmp	0x3d16	; 0x3d16 <__udivdi3_umoddi3>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1987
    3cbe:	a0 e0       	ldi	r26, 0x00	; 0
    3cc0:	b0 e0       	ldi	r27, 0x00	; 0
    3cc2:	e5 e6       	ldi	r30, 0x65	; 101
    3cc4:	fe e1       	ldi	r31, 0x1E	; 30
    3cc6:	0c 94 72 1a 	jmp	0x34e4	; 0x34e4 <__prologue_saves__+0xc>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1991
    3cca:	09 2e       	mov	r0, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1992
    3ccc:	05 94       	asr	r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1997
    3cce:	22 f4       	brpl	.+8      	; 0x3cd8 <__divdi3_moddi3+0x24>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2002
    3cd0:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <__negdi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2005
    3cd4:	11 23       	and	r17, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2006
    3cd6:	92 f4       	brpl	.+36     	; 0x3cfc <__divdi3_moddi3+0x48>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2007
    3cd8:	f0 e8       	ldi	r31, 0x80	; 128
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2008
    3cda:	0f 26       	eor	r0, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2010
    3cdc:	ff ef       	ldi	r31, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2011
    3cde:	e0 94       	com	r14
    3ce0:	f0 94       	com	r15
    3ce2:	00 95       	com	r16
    3ce4:	10 95       	com	r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2012
    3ce6:	b0 94       	com	r11
    3ce8:	c0 94       	com	r12
    3cea:	d0 94       	com	r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2013
    3cec:	a1 94       	neg	r10
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2014
    3cee:	bf 0a       	sbc	r11, r31
    3cf0:	cf 0a       	sbc	r12, r31
    3cf2:	df 0a       	sbc	r13, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2015
    3cf4:	ef 0a       	sbc	r14, r31
    3cf6:	ff 0a       	sbc	r15, r31
    3cf8:	0f 0b       	sbc	r16, r31
    3cfa:	1f 0b       	sbc	r17, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2018
    3cfc:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <__udivmod64>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2025
    3d00:	07 fc       	sbrc	r0, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2027
    3d02:	0e 94 e7 1e 	call	0x3dce	; 0x3dce <__negdi2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2030
    3d06:	cd b7       	in	r28, 0x3d	; 61
    3d08:	de b7       	in	r29, 0x3e	; 62
    3d0a:	ec e0       	ldi	r30, 0x0C	; 12
    3d0c:	0c 94 8e 1a 	jmp	0x351c	; 0x351c <__epilogue_restores__+0xc>

00003d10 <__umoddi3>:
__umoddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1806
    3d10:	68 94       	set
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1807
    3d12:	01 c0       	rjmp	.+2      	; 0x3d16 <__udivdi3_umoddi3>

00003d14 <__udivdi3>:
__udivdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1814
    3d14:	e8 94       	clt

00003d16 <__udivdi3_umoddi3>:
__udivdi3_umoddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1818
    3d16:	8f 92       	push	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1819
    3d18:	9f 92       	push	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1820
    3d1a:	cf 93       	push	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1821
    3d1c:	df 93       	push	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1822
    3d1e:	0e 94 96 1e 	call	0x3d2c	; 0x3d2c <__udivmod64>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1823
    3d22:	df 91       	pop	r29
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1824
    3d24:	cf 91       	pop	r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1825
    3d26:	9f 90       	pop	r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1826
    3d28:	8f 90       	pop	r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1827
    3d2a:	08 95       	ret

00003d2c <__udivmod64>:
__udivmod64():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1842
    3d2c:	88 24       	eor	r8, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1843
    3d2e:	99 24       	eor	r9, r9
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1844
    3d30:	f4 01       	movw	r30, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1845
    3d32:	e4 01       	movw	r28, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1846
    3d34:	b0 e4       	ldi	r27, 0x40	; 64
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1856
    3d36:	9f 93       	push	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1857
    3d38:	aa 27       	eor	r26, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1861
    3d3a:	9a 15       	cp	r25, r10
    3d3c:	8b 04       	cpc	r8, r11
    3d3e:	9c 04       	cpc	r9, r12
    3d40:	ed 05       	cpc	r30, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1862
    3d42:	fe 05       	cpc	r31, r14
    3d44:	cf 05       	cpc	r28, r15
    3d46:	d0 07       	cpc	r29, r16
    3d48:	a1 07       	cpc	r26, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1863
    3d4a:	98 f4       	brcc	.+38     	; 0x3d72 <__udivmod64+0x46>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1866
    3d4c:	ad 2f       	mov	r26, r29
    3d4e:	dc 2f       	mov	r29, r28
    3d50:	cf 2f       	mov	r28, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1867
    3d52:	fe 2f       	mov	r31, r30
    3d54:	e9 2d       	mov	r30, r9
    3d56:	98 2c       	mov	r9, r8
    3d58:	89 2e       	mov	r8, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1868
    3d5a:	98 2f       	mov	r25, r24
    3d5c:	87 2f       	mov	r24, r23
    3d5e:	76 2f       	mov	r23, r22
    3d60:	65 2f       	mov	r22, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1869
    3d62:	54 2f       	mov	r21, r20
    3d64:	43 2f       	mov	r20, r19
    3d66:	32 2f       	mov	r19, r18
    3d68:	22 27       	eor	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1872
    3d6a:	b8 50       	subi	r27, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1873
    3d6c:	31 f7       	brne	.-52     	; 0x3d3a <__udivmod64+0xe>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1876
    3d6e:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1881
    3d70:	27 c0       	rjmp	.+78     	; 0x3dc0 <__udivmod64+0x94>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1884
    3d72:	1b 2e       	mov	r1, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1887
    3d74:	bf 91       	pop	r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1888
    3d76:	bb 27       	eor	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1916
    3d78:	22 0f       	add	r18, r18
    3d7a:	33 1f       	adc	r19, r19
    3d7c:	44 1f       	adc	r20, r20
    3d7e:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1917
    3d80:	66 1f       	adc	r22, r22
    3d82:	77 1f       	adc	r23, r23
    3d84:	88 1f       	adc	r24, r24
    3d86:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1920
    3d88:	88 1c       	adc	r8, r8
    3d8a:	99 1c       	adc	r9, r9
    3d8c:	ee 1f       	adc	r30, r30
    3d8e:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1921
    3d90:	cc 1f       	adc	r28, r28
    3d92:	dd 1f       	adc	r29, r29
    3d94:	aa 1f       	adc	r26, r26
    3d96:	bb 1f       	adc	r27, r27
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1924
    3d98:	8a 14       	cp	r8, r10
    3d9a:	9b 04       	cpc	r9, r11
    3d9c:	ec 05       	cpc	r30, r12
    3d9e:	fd 05       	cpc	r31, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1925
    3da0:	ce 05       	cpc	r28, r14
    3da2:	df 05       	cpc	r29, r15
    3da4:	a0 07       	cpc	r26, r16
    3da6:	b1 07       	cpc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1927
    3da8:	48 f0       	brcs	.+18     	; 0x3dbc <__udivmod64+0x90>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1930
    3daa:	8a 18       	sub	r8, r10
    3dac:	9b 08       	sbc	r9, r11
    3dae:	ec 09       	sbc	r30, r12
    3db0:	fd 09       	sbc	r31, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1931
    3db2:	ce 09       	sbc	r28, r14
    3db4:	df 09       	sbc	r29, r15
    3db6:	a0 0b       	sbc	r26, r16
    3db8:	b1 0b       	sbc	r27, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1935
    3dba:	21 60       	ori	r18, 0x01	; 1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1938
    3dbc:	1a 94       	dec	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1939
    3dbe:	e1 f6       	brne	.-72     	; 0x3d78 <__udivmod64+0x4c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1944
    3dc0:	2e f4       	brtc	.+10     	; 0x3dcc <__udivmod64+0xa0>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1945
    3dc2:	94 01       	movw	r18, r8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1946
    3dc4:	af 01       	movw	r20, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1947
    3dc6:	be 01       	movw	r22, r28
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1948
    3dc8:	cd 01       	movw	r24, r26
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1950
    3dca:	00 0c       	add	r0, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1952
    3dcc:	08 95       	ret

00003dce <__negdi2>:
__negdi2():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2117
    3dce:	60 95       	com	r22
    3dd0:	70 95       	com	r23
    3dd2:	80 95       	com	r24
    3dd4:	90 95       	com	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2118
    3dd6:	30 95       	com	r19
    3dd8:	40 95       	com	r20
    3dda:	50 95       	com	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2119
    3ddc:	21 95       	neg	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2120
    3dde:	3f 4f       	sbci	r19, 0xFF	; 255
    3de0:	4f 4f       	sbci	r20, 0xFF	; 255
    3de2:	5f 4f       	sbci	r21, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2121
    3de4:	6f 4f       	sbci	r22, 0xFF	; 255
    3de6:	7f 4f       	sbci	r23, 0xFF	; 255
    3de8:	8f 4f       	sbci	r24, 0xFF	; 255
    3dea:	9f 4f       	sbci	r25, 0xFF	; 255
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2122
    3dec:	08 95       	ret

00003dee <__ashldi3>:
__ashldi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3169
    3dee:	00 2e       	mov	r0, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3170
    3df0:	08 30       	cpi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3171
    3df2:	90 f0       	brcs	.+36     	; 0x3e18 <__ashldi3+0x2a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3172
    3df4:	98 2f       	mov	r25, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3173
    3df6:	87 2f       	mov	r24, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3174
    3df8:	76 2f       	mov	r23, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3175
    3dfa:	65 2f       	mov	r22, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3176
    3dfc:	54 2f       	mov	r21, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3177
    3dfe:	43 2f       	mov	r20, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3178
    3e00:	32 2f       	mov	r19, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3179
    3e02:	22 27       	eor	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3180
    3e04:	08 50       	subi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3181
    3e06:	f4 cf       	rjmp	.-24     	; 0x3df0 <__ashldi3+0x2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3182
    3e08:	22 0f       	add	r18, r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3183
    3e0a:	33 1f       	adc	r19, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3184
    3e0c:	44 1f       	adc	r20, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3185
    3e0e:	55 1f       	adc	r21, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3186
    3e10:	66 1f       	adc	r22, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3187
    3e12:	77 1f       	adc	r23, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3188
    3e14:	88 1f       	adc	r24, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3189
    3e16:	99 1f       	adc	r25, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3190
    3e18:	0a 95       	dec	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3191
    3e1a:	b2 f7       	brpl	.-20     	; 0x3e08 <__ashldi3+0x1a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3192
    3e1c:	00 2d       	mov	r16, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3193
    3e1e:	08 95       	ret

00003e20 <__ashrdi3>:
__ashrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3122
    3e20:	97 fd       	sbrc	r25, 7
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3123
    3e22:	10 94       	com	r1

00003e24 <__lshrdi3>:
__lshrdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3131
    3e24:	00 2e       	mov	r0, r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3132
    3e26:	08 30       	cpi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3133
    3e28:	98 f0       	brcs	.+38     	; 0x3e50 <__lshrdi3+0x2c>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3134
    3e2a:	08 50       	subi	r16, 0x08	; 8
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3135
    3e2c:	23 2f       	mov	r18, r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3136
    3e2e:	34 2f       	mov	r19, r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3137
    3e30:	45 2f       	mov	r20, r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3138
    3e32:	56 2f       	mov	r21, r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3139
    3e34:	67 2f       	mov	r22, r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3140
    3e36:	78 2f       	mov	r23, r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3141
    3e38:	89 2f       	mov	r24, r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3142
    3e3a:	91 2d       	mov	r25, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3143
    3e3c:	f4 cf       	rjmp	.-24     	; 0x3e26 <__lshrdi3+0x2>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3144
    3e3e:	15 94       	asr	r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3145
    3e40:	97 95       	ror	r25
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3146
    3e42:	87 95       	ror	r24
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3147
    3e44:	77 95       	ror	r23
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3148
    3e46:	67 95       	ror	r22
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3149
    3e48:	57 95       	ror	r21
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3150
    3e4a:	47 95       	ror	r20
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3151
    3e4c:	37 95       	ror	r19
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3152
    3e4e:	27 95       	ror	r18
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3153
    3e50:	0a 95       	dec	r16
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3154
    3e52:	aa f7       	brpl	.-22     	; 0x3e3e <__lshrdi3+0x1a>
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3155
    3e54:	11 24       	eor	r1, r1
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3156
    3e56:	00 2d       	mov	r16, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:3157
    3e58:	08 95       	ret

00003e5a <__adddi3>:
__adddi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2051
    3e5a:	2a 0d       	add	r18, r10
    3e5c:	3b 1d       	adc	r19, r11
    3e5e:	4c 1d       	adc	r20, r12
    3e60:	5d 1d       	adc	r21, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2052
    3e62:	6e 1d       	adc	r22, r14
    3e64:	7f 1d       	adc	r23, r15
    3e66:	80 1f       	adc	r24, r16
    3e68:	91 1f       	adc	r25, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2053
    3e6a:	08 95       	ret

00003e6c <__subdi3>:
__subdi3():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2080
    3e6c:	2a 19       	sub	r18, r10
    3e6e:	3b 09       	sbc	r19, r11
    3e70:	4c 09       	sbc	r20, r12
    3e72:	5d 09       	sbc	r21, r13
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2081
    3e74:	6e 09       	sbc	r22, r14
    3e76:	7f 09       	sbc	r23, r15
    3e78:	80 0b       	sbc	r24, r16
    3e7a:	91 0b       	sbc	r25, r17
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2082
    3e7c:	08 95       	ret

00003e7e <__tablejump2__>:
__tablejump2__():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    3e7e:	ee 0f       	add	r30, r30
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    3e80:	ff 1f       	adc	r31, r31
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2328
    3e82:	05 90       	lpm	r0, Z+
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2329
    3e84:	f4 91       	lpm	r31, Z
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2330
    3e86:	e0 2d       	mov	r30, r0
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2331
    3e88:	09 94       	ijmp

00003e8a <sprintf>:
sprintf():
    3e8a:	ae e0       	ldi	r26, 0x0E	; 14
    3e8c:	b0 e0       	ldi	r27, 0x00	; 0
    3e8e:	eb e4       	ldi	r30, 0x4B	; 75
    3e90:	ff e1       	ldi	r31, 0x1F	; 31
    3e92:	0c 94 7a 1a 	jmp	0x34f4	; 0x34f4 <__prologue_saves__+0x1c>
    3e96:	0d 89       	ldd	r16, Y+21	; 0x15
    3e98:	1e 89       	ldd	r17, Y+22	; 0x16
    3e9a:	86 e0       	ldi	r24, 0x06	; 6
    3e9c:	8c 83       	std	Y+4, r24	; 0x04
    3e9e:	1a 83       	std	Y+2, r17	; 0x02
    3ea0:	09 83       	std	Y+1, r16	; 0x01
    3ea2:	8f ef       	ldi	r24, 0xFF	; 255
    3ea4:	9f e7       	ldi	r25, 0x7F	; 127
    3ea6:	9e 83       	std	Y+6, r25	; 0x06
    3ea8:	8d 83       	std	Y+5, r24	; 0x05
    3eaa:	ae 01       	movw	r20, r28
    3eac:	47 5e       	subi	r20, 0xE7	; 231
    3eae:	5f 4f       	sbci	r21, 0xFF	; 255
    3eb0:	6f 89       	ldd	r22, Y+23	; 0x17
    3eb2:	78 8d       	ldd	r23, Y+24	; 0x18
    3eb4:	ce 01       	movw	r24, r28
    3eb6:	01 96       	adiw	r24, 0x01	; 1
    3eb8:	0e 94 e8 16 	call	0x2dd0	; 0x2dd0 <vfprintf>
    3ebc:	2f 81       	ldd	r18, Y+7	; 0x07
    3ebe:	38 85       	ldd	r19, Y+8	; 0x08
    3ec0:	02 0f       	add	r16, r18
    3ec2:	13 1f       	adc	r17, r19
    3ec4:	f8 01       	movw	r30, r16
    3ec6:	10 82       	st	Z, r1
    3ec8:	2e 96       	adiw	r28, 0x0e	; 14
    3eca:	e4 e0       	ldi	r30, 0x04	; 4
    3ecc:	0c 94 96 1a 	jmp	0x352c	; 0x352c <__epilogue_restores__+0x1c>

00003ed0 <_exit>:
exit():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    3ed0:	f8 94       	cli

00003ed2 <__stop_program>:
__stop_program():
/home/jenkins-mingw32/workspace/avr-gcc-staging/label/Ubuntu14.04x64-mingw32/gcc-build/avr/avr5/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    3ed2:	ff cf       	rjmp	.-2      	; 0x3ed2 <__stop_program>
